{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "build/src/config.js",
    "build/src/constraint/base.js",
    "build/src/constraint/encoding.js",
    "build/src/constraint/index.js",
    "build/src/constraint/spec.js",
    "build/src/cql.js",
    "build/src/enumerator.js",
    "build/src/generate.js",
    "build/src/model.js",
    "build/src/nest.js",
    "build/src/property.js",
    "build/src/propindex.js",
    "build/src/query/encoding.js",
    "build/src/query/groupby.js",
    "build/src/query/index.js",
    "build/src/query/normalize.js",
    "build/src/query/shorthand.js",
    "build/src/query/spec.js",
    "build/src/query/transform.js",
    "build/src/ranking/aggregation.js",
    "build/src/ranking/effectiveness/axis.js",
    "build/src/ranking/effectiveness/base.js",
    "build/src/ranking/effectiveness/dimension.js",
    "build/src/ranking/effectiveness/facet.js",
    "build/src/ranking/effectiveness/index.js",
    "build/src/ranking/effectiveness/mark.js",
    "build/src/ranking/effectiveness/sizechannel.js",
    "build/src/ranking/effectiveness/type.js",
    "build/src/ranking/effectiveness/typechannel.js",
    "build/src/ranking/fieldorder.js",
    "build/src/ranking/ranking.js",
    "build/src/recommend.js",
    "build/src/schema.js",
    "build/src/stylize.js",
    "build/src/util.js",
    "build/src/wildcard.js",
    "build/src/wildcardindex.js",
    "node_modules/browser-resolve/empty.js",
    "node_modules/datalib/node_modules/d3-time/build/d3-time.js",
    "node_modules/datalib/src/bins/bins.js",
    "node_modules/datalib/src/generate.js",
    "node_modules/datalib/src/import/type.js",
    "node_modules/datalib/src/stats.js",
    "node_modules/datalib/src/time.js",
    "node_modules/datalib/src/util.js",
    "node_modules/json-stable-stringify/index.js",
    "node_modules/jsonify/index.js",
    "node_modules/jsonify/lib/parse.js",
    "node_modules/jsonify/lib/stringify.js",
    "node_modules/vega-lite/build/src/aggregate.js",
    "node_modules/vega-lite/build/src/axis.js",
    "node_modules/vega-lite/build/src/bin.js",
    "node_modules/vega-lite/build/src/channel.js",
    "node_modules/vega-lite/build/src/compile/scale/type.js",
    "node_modules/vega-lite/build/src/datetime.js",
    "node_modules/vega-lite/build/src/fielddef.js",
    "node_modules/vega-lite/build/src/legend.js",
    "node_modules/vega-lite/build/src/log.js",
    "node_modules/vega-lite/build/src/mark.js",
    "node_modules/vega-lite/build/src/scale.js",
    "node_modules/vega-lite/build/src/timeunit.js",
    "node_modules/vega-lite/build/src/type.js",
    "node_modules/vega-lite/build/src/util.js",
    "node_modules/vega-util/build/vega-util.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrbA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACltBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar property_1 = require(\"./property\");\nvar wildcard_1 = require(\"./wildcard\");\nexports.DEFAULT_QUERY_CONFIG = {\n    verbose: false,\n    defaultSpecConfig: {\n        overlay: { line: true },\n        scale: { useUnaggregatedDomain: true }\n    },\n    propertyPrecedence: property_1.DEFAULT_PROP_PRECEDENCE.map(property_1.toKey),\n    enum: wildcard_1.DEFAULT_ENUM_INDEX,\n    numberNominalProportion: 0.05,\n    numberNominalLimit: 40,\n    // CONSTRAINTS\n    constraintManuallySpecifiedValue: false,\n    // Spec Constraints -- See description inside src/constraints/spec.ts\n    autoAddCount: false,\n    hasAppropriateGraphicTypeForMark: true,\n    omitAggregate: false,\n    omitAggregatePlotWithDimensionOnlyOnFacet: true,\n    omitAggregatePlotWithoutDimension: false,\n    omitBarLineAreaWithOcclusion: true,\n    omitBarTickWithSize: true,\n    omitMultipleNonPositionalChannels: true,\n    omitNonSumStack: true,\n    omitRaw: false,\n    omitRawContinuousFieldForAggregatePlot: true,\n    omitRepeatedField: true,\n    omitNonPositionalOrFacetOverPositionalChannels: true,\n    omitTableWithOcclusionIfAutoAddCount: true,\n    omitVerticalDotPlot: false,\n    preferredBinAxis: channel_1.Channel.X,\n    preferredTemporalAxis: channel_1.Channel.X,\n    preferredOrdinalAxis: channel_1.Channel.Y,\n    preferredNominalAxis: channel_1.Channel.Y,\n    preferredFacet: channel_1.Channel.ROW,\n    // Encoding Constraints -- See description inside src/constraints/encoding.ts\n    maxCardinalityForCategoricalColor: 20,\n    maxCardinalityForFacet: 20,\n    maxCardinalityForShape: 6,\n    timeUnitShouldHaveVariation: true,\n    typeMatchesSchemaType: true,\n    // STYLIZE\n    stylize: true,\n    smallRangeStepForHighCardinalityOrFacet: { maxCardinality: 10, rangeStep: 12 },\n    nominalColorScaleForHighCardinality: { maxCardinality: 10, palette: 'category20' },\n    xAxisOnTopForHighYCardinalityWithoutColumn: { maxCardinality: 30 },\n    // RANKING PREFERENCE\n    maxGoodCardinalityForFacet: 5,\n    maxGoodCardinalityForColor: 7,\n};\nfunction extendConfig(opt) {\n    return __assign({}, exports.DEFAULT_QUERY_CONFIG, opt, { enum: extendEnumIndex(opt.enum) });\n}\nexports.extendConfig = extendConfig;\nfunction extendEnumIndex(enumIndex) {\n    var enumOpt = __assign({}, wildcard_1.DEFAULT_ENUM_INDEX, enumIndex, { binProps: extendNestedEnumIndex(enumIndex, 'bin'), scaleProps: extendNestedEnumIndex(enumIndex, 'scale'), axisProps: extendNestedEnumIndex(enumIndex, 'axis'), legendProps: extendNestedEnumIndex(enumIndex, 'legend') });\n    return enumOpt;\n}\nfunction extendNestedEnumIndex(enumIndex, prop) {\n    return __assign({}, wildcard_1.DEFAULT_ENUM_INDEX[prop + 'Props'], enumIndex[prop + 'Props']);\n}\n//# sourceMappingURL=config.js.map",
    "\"use strict\";\n/**\n * Abstract model for a constraint.\n */\nvar AbstractConstraintModel = (function () {\n    function AbstractConstraintModel(constraint) {\n        this.constraint = constraint;\n    }\n    AbstractConstraintModel.prototype.name = function () {\n        return this.constraint.name;\n    };\n    AbstractConstraintModel.prototype.description = function () {\n        return this.constraint.description;\n    };\n    AbstractConstraintModel.prototype.properties = function () {\n        return this.constraint.properties;\n    };\n    AbstractConstraintModel.prototype.strict = function () {\n        return this.constraint.strict;\n    };\n    return AbstractConstraintModel;\n}());\nexports.AbstractConstraintModel = AbstractConstraintModel;\n//# sourceMappingURL=base.js.map",
    "\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar fielddef_1 = require(\"vega-lite/build/src/fielddef\");\nvar scale_1 = require(\"vega-lite/build/src/scale\");\nvar type_1 = require(\"vega-lite/build/src/type\");\nvar base_1 = require(\"./base\");\nvar property_1 = require(\"../property\");\nvar propindex_1 = require(\"../propindex\");\nvar wildcard_1 = require(\"../wildcard\");\nvar schema_1 = require(\"../schema\");\nvar util_1 = require(\"../util\");\nvar encoding_1 = require(\"../query/encoding\");\nvar EncodingConstraintModel = (function (_super) {\n    __extends(EncodingConstraintModel, _super);\n    function EncodingConstraintModel(constraint) {\n        return _super.call(this, constraint) || this;\n    }\n    EncodingConstraintModel.prototype.hasAllRequiredPropertiesSpecific = function (encQ) {\n        return util_1.every(this.constraint.properties, function (prop) {\n            if (property_1.isEncodingNestedProp(prop)) {\n                var parent_1 = prop.parent;\n                var child = prop.child;\n                if (!encQ[parent_1]) {\n                    return true;\n                }\n                return !wildcard_1.isWildcard(encQ[parent_1][child]);\n            }\n            if (!encQ[prop]) {\n                return true;\n            }\n            return !wildcard_1.isWildcard(encQ[prop]);\n        });\n    };\n    EncodingConstraintModel.prototype.satisfy = function (encQ, schema, encWildcardIndex, opt) {\n        // TODO: Re-order logic to optimize the \"allowWildcardForProperties\" check\n        if (!this.constraint.allowWildcardForProperties) {\n            // TODO: extract as a method and do unit test\n            if (!this.hasAllRequiredPropertiesSpecific(encQ)) {\n                return true;\n            }\n        }\n        return this.constraint.satisfy(encQ, schema, encWildcardIndex, opt);\n    };\n    return EncodingConstraintModel;\n}(base_1.AbstractConstraintModel));\nexports.EncodingConstraintModel = EncodingConstraintModel;\nexports.FIELD_CONSTRAINTS = [\n    {\n        name: 'aggregateOpSupportedByType',\n        description: 'Aggregate function should be supported by data type.',\n        properties: [property_1.Property.TYPE, property_1.Property.AGGREGATE],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            if (fieldQ.aggregate) {\n                return fieldQ.type !== type_1.Type.ORDINAL && fieldQ.type !== type_1.Type.NOMINAL;\n            }\n            // TODO: some aggregate function are actually supported by ordinal\n            return true; // no aggregate is okay with any type.\n        }\n    }, {\n        name: 'asteriskFieldWithCountOnly',\n        description: 'Field=\"*\" should be disallowed except aggregate=\"count\"',\n        properties: [property_1.Property.FIELD, property_1.Property.AGGREGATE],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            return (fieldQ.field === '*') === (fieldQ.aggregate === 'count');\n        }\n    }, {\n        name: 'binAppliedForQuantitative',\n        description: 'bin should be applied to quantitative field only.',\n        properties: [property_1.Property.TYPE, property_1.Property.BIN],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            if (fieldQ.bin) {\n                // If binned, the type must be quantitative\n                return fieldQ.type === type_1.Type.QUANTITATIVE;\n            }\n            return true;\n        }\n    }, {\n        name: 'channelFieldCompatible',\n        description: \"encoding channel's range type be compatible with channel type.\",\n        properties: [property_1.Property.CHANNEL, property_1.Property.TYPE, property_1.Property.BIN, property_1.Property.TIMEUNIT],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (fieldQ, _, encWildcardIndex, opt) {\n            var fieldDef = __assign({ field: 'f' }, encoding_1.toFieldDef(fieldQ, ['bin', 'timeUnit', 'type']));\n            return fielddef_1.channelCompatibility(fieldDef, fieldQ.channel).compatible;\n        }\n    }, {\n        name: 'hasFn',\n        description: 'A field with as hasFn flag should have one of aggregate, timeUnit, or bin.',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.BIN, property_1.Property.TIMEUNIT],\n        allowWildcardForProperties: true,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            if (fieldQ.hasFn) {\n                return !!fieldQ.aggregate || !!fieldQ.bin || !!fieldQ.timeUnit;\n            }\n            return true;\n        }\n    }, {\n        name: 'omitScaleZeroWithBinnedField',\n        description: 'Do not use scale zero with binned field',\n        properties: [property_1.Property.SCALE, property_1.getEncodingNestedProp('scale', 'zero'), property_1.Property.BIN],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            if (fieldQ.bin && fieldQ.scale) {\n                if (fieldQ.scale.zero === true) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }, {\n        name: 'onlyOneTypeOfFunction',\n        description: 'Only of of aggregate, autoCount, timeUnit, or bin should be applied at the same time.',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.TIMEUNIT, property_1.Property.BIN],\n        allowWildcardForProperties: true,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            var numFn = (!wildcard_1.isWildcard(fieldQ.aggregate) && !!fieldQ.aggregate ? 1 : 0) +\n                (!wildcard_1.isWildcard(fieldQ.autoCount) && !!fieldQ.autoCount ? 1 : 0) +\n                (!wildcard_1.isWildcard(fieldQ.bin) && !!fieldQ.bin ? 1 : 0) +\n                (!wildcard_1.isWildcard(fieldQ.timeUnit) && !!fieldQ.timeUnit ? 1 : 0);\n            return numFn <= 1;\n        }\n    }, {\n        name: 'timeUnitAppliedForTemporal',\n        description: 'Time unit should be applied to temporal field only.',\n        properties: [property_1.Property.TYPE, property_1.Property.TIMEUNIT],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            if (fieldQ.timeUnit && fieldQ.type !== type_1.Type.TEMPORAL) {\n                return false;\n            }\n            return true;\n        }\n    }, {\n        name: 'timeUnitShouldHaveVariation',\n        description: 'A particular time unit should be applied only if they produce unique values.',\n        properties: [property_1.Property.TIMEUNIT, property_1.Property.TYPE],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (fieldQ, schema, encWildcardIndex, opt) {\n            if (fieldQ.timeUnit && fieldQ.type === type_1.Type.TEMPORAL) {\n                if (!encWildcardIndex.has('timeUnit') && !opt.constraintManuallySpecifiedValue) {\n                    // Do not have to check this as this is manually specified by users.\n                    return true;\n                }\n                return schema.timeUnitHasVariation(fieldQ);\n            }\n            return true;\n        }\n    }, {\n        name: 'scalePropertiesSupportedByScaleType',\n        description: 'Scale properties must be supported by correct scale type',\n        properties: [].concat(property_1.SCALE_PROPS, [property_1.Property.SCALE, property_1.Property.TYPE]),\n        allowWildcardForProperties: true,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            if (fieldQ.scale) {\n                var scale = fieldQ.scale;\n                //  If fieldQ.type is an Wildcard and scale.type is undefined, it is equivalent\n                //  to scale type is Wildcard. If scale type is an Wildcard, we do not yet know\n                //  what the scale type is, and thus can ignore the constraint.\n                var sType = encoding_1.scaleType(fieldQ);\n                if (sType === undefined || sType === null) {\n                    // If still ambiguous, doesn't check the constraint\n                    return true;\n                }\n                for (var scaleProp in scale) {\n                    if (scaleProp === 'type' || scaleProp === 'name' || scaleProp === 'enum') {\n                        // ignore type and properties of wildcards\n                        continue;\n                    }\n                    var sProp = scaleProp;\n                    if (sType === 'point') {\n                        // HACK: our current implementation of scaleType() can return point\n                        // when the scaleType is a band since we didn't pass all parameter to Vega-Lite's scale type method.\n                        if (!scale_1.scaleTypeSupportProperty('point', sProp) && !scale_1.scaleTypeSupportProperty('band', sProp)) {\n                            return false;\n                        }\n                    }\n                    else if (!scale_1.scaleTypeSupportProperty(sType, sProp)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    }, {\n        name: 'scalePropertiesSupportedByChannel',\n        description: 'Not all scale properties are supported by all encoding channels',\n        properties: [].concat(property_1.SCALE_PROPS, [property_1.Property.SCALE, property_1.Property.CHANNEL]),\n        allowWildcardForProperties: true,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            if (fieldQ) {\n                var channel = fieldQ.channel;\n                var scale = fieldQ.scale;\n                if (channel && !wildcard_1.isWildcard(channel) && scale) {\n                    for (var scaleProp in scale) {\n                        if (!scale.hasOwnProperty(scaleProp))\n                            continue;\n                        if (scaleProp === 'type' || scaleProp === 'name' || scaleProp === 'enum') {\n                            // ignore type and properties of wildcards\n                            continue;\n                        }\n                        var isSupported = scale_1.channelScalePropertyIncompatability(channel, scaleProp) === undefined;\n                        if (!isSupported) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n    }, {\n        name: 'typeMatchesPrimitiveType',\n        description: 'Data type should be supported by field\\'s primitive type.',\n        properties: [property_1.Property.FIELD, property_1.Property.TYPE],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (fieldQ, schema, encWildcardIndex, opt) {\n            if (fieldQ.field === '*') {\n                return true;\n            }\n            var primitiveType = schema.primitiveType(fieldQ.field);\n            var type = fieldQ.type;\n            if (!encWildcardIndex.has('field') && !encWildcardIndex.has('type') && !opt.constraintManuallySpecifiedValue) {\n                // Do not have to check this as this is manually specified by users.\n                return true;\n            }\n            switch (primitiveType) {\n                case schema_1.PrimitiveType.BOOLEAN:\n                case schema_1.PrimitiveType.STRING:\n                    return type !== type_1.Type.QUANTITATIVE && type !== type_1.Type.TEMPORAL;\n                case schema_1.PrimitiveType.NUMBER:\n                case schema_1.PrimitiveType.INTEGER:\n                    return type !== type_1.Type.TEMPORAL;\n                case schema_1.PrimitiveType.DATE:\n                    // TODO: add NOMINAL, ORDINAL support after we support this in Vega-Lite\n                    return type === type_1.Type.TEMPORAL;\n                case null:\n                    // field does not exist in the schema\n                    return false;\n            }\n            throw new Error('Not implemented');\n        }\n    },\n    {\n        name: 'typeMatchesSchemaType',\n        description: 'Enumerated data type of a field should match the field\\'s type in the schema.',\n        properties: [property_1.Property.FIELD, property_1.Property.TYPE],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (fieldQ, schema, encWildcardIndex, opt) {\n            if (!encWildcardIndex.has('field') && !encWildcardIndex.has('type') && !opt.constraintManuallySpecifiedValue) {\n                // Do not have to check this as this is manually specified by users.\n                return true;\n            }\n            if (fieldQ.field === '*') {\n                return fieldQ.type === type_1.Type.QUANTITATIVE;\n            }\n            return schema.type(fieldQ.field) === fieldQ.type;\n        }\n    }, {\n        name: 'maxCardinalityForCategoricalColor',\n        description: 'Categorical channel should not have too high cardinality',\n        properties: [property_1.Property.CHANNEL, property_1.Property.FIELD],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (fieldQ, schema, _, opt) {\n            // TODO: missing case where ordinal / temporal use categorical color\n            // (once we do so, need to add Property.BIN, Property.TIMEUNIT)\n            if (fieldQ.channel === channel_1.Channel.COLOR && fieldQ.type === type_1.Type.NOMINAL) {\n                return schema.cardinality(fieldQ) <= opt.maxCardinalityForCategoricalColor;\n            }\n            return true; // other channel is irrelevant to this constraint\n        }\n    }, {\n        name: 'maxCardinalityForFacet',\n        description: 'Row/column channel should not have too high cardinality',\n        properties: [property_1.Property.CHANNEL, property_1.Property.FIELD, property_1.Property.BIN, property_1.Property.TIMEUNIT],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (fieldQ, schema, _, opt) {\n            if (fieldQ.channel === channel_1.Channel.ROW || fieldQ.channel === channel_1.Channel.COLUMN) {\n                return schema.cardinality(fieldQ) <= opt.maxCardinalityForFacet;\n            }\n            return true; // other channel is irrelevant to this constraint\n        }\n    }, {\n        name: 'maxCardinalityForShape',\n        description: 'Shape channel should not have too high cardinality',\n        properties: [property_1.Property.CHANNEL, property_1.Property.FIELD, property_1.Property.BIN, property_1.Property.TIMEUNIT],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (fieldQ, schema, _, opt) {\n            if (fieldQ.channel === channel_1.Channel.SHAPE) {\n                return schema.cardinality(fieldQ) <= opt.maxCardinalityForShape;\n            }\n            return true; // other channel is irrelevant to this constraint\n        }\n    }, {\n        name: 'dataTypeAndFunctionMatchScaleType',\n        description: 'Scale type must match data type',\n        properties: [property_1.Property.TYPE, property_1.Property.SCALE, property_1.getEncodingNestedProp('scale', 'type'), property_1.Property.TIMEUNIT, property_1.Property.BIN],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            if (fieldQ.scale) {\n                var type = fieldQ.type;\n                var sType = encoding_1.scaleType(fieldQ);\n                if (util_1.contains([type_1.Type.ORDINAL, type_1.Type.NOMINAL], type)) {\n                    return sType === undefined || scale_1.hasDiscreteDomain(sType);\n                }\n                else if (type === type_1.Type.TEMPORAL) {\n                    if (!fieldQ.timeUnit) {\n                        return util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, undefined], sType);\n                    }\n                    else {\n                        return util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, undefined], sType) || scale_1.hasDiscreteDomain(sType);\n                    }\n                }\n                else if (type === type_1.Type.QUANTITATIVE) {\n                    if (fieldQ.bin) {\n                        return util_1.contains([scale_1.ScaleType.LINEAR, undefined], sType);\n                    }\n                    else {\n                        return util_1.contains([scale_1.ScaleType.LOG, scale_1.ScaleType.POW, scale_1.ScaleType.SQRT, scale_1.ScaleType.QUANTILE, scale_1.ScaleType.QUANTIZE, scale_1.ScaleType.LINEAR, undefined], sType);\n                    }\n                }\n            }\n            return true;\n        }\n    }\n].map(function (ec) { return new EncodingConstraintModel(ec); });\nexports.FIELD_CONSTRAINT_INDEX = exports.FIELD_CONSTRAINTS.reduce(function (m, ec) {\n    m[ec.name()] = ec;\n    return m;\n}, {});\nvar FIELD_CONSTRAINTS_BY_PROPERTY = exports.FIELD_CONSTRAINTS.reduce(function (index, c) {\n    for (var _i = 0, _a = c.properties(); _i < _a.length; _i++) {\n        var prop = _a[_i];\n        // Initialize array and use it\n        index.set(prop, index.get(prop) || []);\n        index.get(prop).push(c);\n    }\n    return index;\n}, new propindex_1.PropIndex());\nexports.VALUE_CONSTRAINTS = [\n    {\n        name: 'doesNotSupportConstantValue',\n        description: 'row, column, x, y, and detail should not work with constant values.',\n        properties: [property_1.Property.TYPE, property_1.Property.AGGREGATE],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (valueQ, _, __, ___) {\n            return !(util_1.contains(['row', 'column', 'x', 'y', 'detail'], valueQ.channel));\n        }\n    }\n].map(function (ec) { return new EncodingConstraintModel(ec); });\nexports.VALUE_CONSTRAINT_INDEX = exports.VALUE_CONSTRAINTS.reduce(function (m, ec) {\n    m[ec.name()] = ec;\n    return m;\n}, {});\nvar VALUE_CONSTRAINTS_BY_PROPERTY = exports.FIELD_CONSTRAINTS.reduce(function (index, c) {\n    for (var _i = 0, _a = c.properties(); _i < _a.length; _i++) {\n        var prop = _a[_i];\n        index.set(prop, index.get(prop) || []);\n        index.get(prop).push(c);\n    }\n    return index;\n}, new propindex_1.PropIndex());\n/**\n * Check all encoding constraints for a particular property and index tuple\n */\nfunction checkEncoding(prop, wildcard, index, specM, schema, opt) {\n    // Check encoding constraint\n    var encodingConstraints = FIELD_CONSTRAINTS_BY_PROPERTY.get(prop) || [];\n    var encQ = specM.getEncodingQueryByIndex(index);\n    for (var _i = 0, encodingConstraints_1 = encodingConstraints; _i < encodingConstraints_1.length; _i++) {\n        var c = encodingConstraints_1[_i];\n        // Check if the constraint is enabled\n        if (c.strict() || !!opt[c.name()]) {\n            // For strict constraint, or enabled non-strict, check the constraints\n            var satisfy = c.satisfy(encQ, schema, specM.wildcardIndex.encodings[index], opt);\n            if (!satisfy) {\n                var violatedConstraint = '(enc) ' + c.name();\n                /* istanbul ignore if */\n                if (opt.verbose) {\n                    console.log(violatedConstraint + ' failed with ' + specM.toShorthand() + ' for ' + wildcard.name);\n                }\n                return violatedConstraint;\n            }\n        }\n    }\n    var valueContraints = VALUE_CONSTRAINTS_BY_PROPERTY.get(prop) || [];\n    for (var _a = 0, valueContraints_1 = valueContraints; _a < valueContraints_1.length; _a++) {\n        var c = valueContraints_1[_a];\n        // Check if the constraint is enabled\n        if ((c.strict() || !!opt[c.name()]) && encoding_1.isValueQuery(encQ)) {\n            // For strict constraint, or enabled non-strict, check the constraints\n            var satisfy = c.satisfy(encQ, schema, specM.wildcardIndex.encodings[index], opt);\n            if (!satisfy) {\n                var violatedConstraint = '(enc) ' + c.name();\n                /* istanbul ignore if */\n                if (opt.verbose) {\n                    console.log(violatedConstraint + ' failed with ' + specM.toShorthand() + ' for ' + wildcard.name);\n                }\n                return violatedConstraint;\n            }\n        }\n    }\n    return null;\n}\nexports.checkEncoding = checkEncoding;\n//# sourceMappingURL=encoding.js.map",
    "\"use strict\";\nvar encoding = require(\"./encoding\");\nexports.encoding = encoding;\nvar spec = require(\"./spec\");\nexports.spec = spec;\n//# sourceMappingURL=index.js.map",
    "\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar aggregate_1 = require(\"vega-lite/build/src/aggregate\");\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar mark_1 = require(\"vega-lite/build/src/mark\");\nvar scale_1 = require(\"vega-lite/build/src/scale\");\nvar type_1 = require(\"vega-lite/build/src/type\");\nvar base_1 = require(\"./base\");\nvar wildcard_1 = require(\"../wildcard\");\nvar property_1 = require(\"../property\");\nvar propindex_1 = require(\"../propindex\");\nvar util_1 = require(\"../util\");\nvar encoding_1 = require(\"../query/encoding\");\nvar NONSPATIAL_CHANNELS_INDEX = channel_1.NONSPATIAL_CHANNELS.reduce(function (m, channel) {\n    m[channel] = true;\n    return m;\n}, {});\nvar SpecConstraintModel = (function (_super) {\n    __extends(SpecConstraintModel, _super);\n    function SpecConstraintModel(specConstraint) {\n        return _super.call(this, specConstraint) || this;\n    }\n    SpecConstraintModel.prototype.hasAllRequiredPropertiesSpecific = function (specM) {\n        return util_1.every(this.constraint.properties, function (prop) {\n            if (prop === property_1.Property.MARK) {\n                return !wildcard_1.isWildcard(specM.getMark());\n            }\n            // TODO: transform\n            if (property_1.isEncodingNestedProp(prop)) {\n                var parent_1 = prop.parent;\n                var child_1 = prop.child;\n                return util_1.every(specM.getEncodings(), function (encQ) {\n                    if (!encQ[parent_1]) {\n                        return true;\n                    }\n                    return !wildcard_1.isWildcard(encQ[parent_1][child_1]);\n                });\n            }\n            if (!property_1.isEncodingProperty(prop)) {\n                throw new Error('UNIMPLEMENTED');\n            }\n            return util_1.every(specM.getEncodings(), function (encQ) {\n                if (!encQ[prop]) {\n                    return true;\n                }\n                return !wildcard_1.isWildcard(encQ[prop]);\n            });\n        });\n    };\n    SpecConstraintModel.prototype.satisfy = function (specM, schema, opt) {\n        // TODO: Re-order logic to optimize the \"allowWildcardForProperties\" check\n        if (!this.constraint.allowWildcardForProperties) {\n            if (!this.hasAllRequiredPropertiesSpecific(specM)) {\n                return true;\n            }\n        }\n        return this.constraint.satisfy(specM, schema, opt);\n    };\n    return SpecConstraintModel;\n}(base_1.AbstractConstraintModel));\nexports.SpecConstraintModel = SpecConstraintModel;\nexports.SPEC_CONSTRAINTS = [\n    {\n        name: 'noRepeatedChannel',\n        description: 'Each encoding channel should only be used once.',\n        properties: [property_1.Property.CHANNEL],\n        allowWildcardForProperties: true,\n        strict: true,\n        satisfy: function (specM, _, __) {\n            var usedChannel = {};\n            // channel for all encodings should be valid\n            return util_1.every(specM.getEncodings(), function (encQ) {\n                if (!wildcard_1.isWildcard(encQ.channel)) {\n                    // If channel is specified, it should no be used already\n                    if (usedChannel[encQ.channel]) {\n                        return false;\n                    }\n                    usedChannel[encQ.channel] = true;\n                    return true;\n                }\n                return true; // unspecified channel is valid\n            });\n        }\n    },\n    {\n        name: 'alwaysIncludeZeroInScaleWithBarMark',\n        description: 'Do not recommend bar mark if scale does not start at zero',\n        properties: [property_1.Property.MARK, property_1.Property.SCALE, property_1.getEncodingNestedProp('scale', 'zero'), property_1.Property.CHANNEL, property_1.Property.TYPE],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (specM, _, __) {\n            var mark = specM.getMark();\n            var encodings = specM.getEncodings();\n            if (mark === mark_1.Mark.BAR) {\n                for (var _i = 0, encodings_1 = encodings; _i < encodings_1.length; _i++) {\n                    var encQ = encodings_1[_i];\n                    if (encoding_1.isFieldQuery(encQ) &&\n                        (encQ.channel === channel_1.Channel.X || encQ.channel === channel_1.Channel.Y) &&\n                        (encQ.type === type_1.Type.QUANTITATIVE) &&\n                        (encQ.scale && encQ.scale.zero === false)) {\n                        // TODO: zero shouldn't be manually specified\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'autoAddCount',\n        description: 'Automatically adding count only for plots with only ordinal, binned quantitative, or temporal with timeunit fields.',\n        properties: [property_1.Property.BIN, property_1.Property.TIMEUNIT, property_1.Property.TYPE, property_1.Property.AUTOCOUNT],\n        allowWildcardForProperties: true,\n        strict: false,\n        satisfy: function (specM, _, __) {\n            var hasAutoCount = util_1.some(specM.getEncodings(), function (encQ) { return encoding_1.isFieldQuery(encQ) && encQ.autoCount === true; });\n            if (hasAutoCount) {\n                // Auto count should only be applied if all fields are nominal, ordinal, temporal with timeUnit, binned quantitative, or autoCount\n                return util_1.every(specM.getEncodings(), function (encQ) {\n                    // TODO(akshatsh): should value query return false?\n                    if (encoding_1.isValueQuery(encQ)) {\n                        return false;\n                    }\n                    if (encQ.autoCount !== undefined) {\n                        return true;\n                    }\n                    switch (encQ.type) {\n                        case type_1.Type.QUANTITATIVE:\n                            return !!encQ.bin;\n                        case type_1.Type.TEMPORAL:\n                            return !!encQ.timeUnit;\n                        case type_1.Type.ORDINAL:\n                        case type_1.Type.NOMINAL:\n                            return true;\n                    }\n                    /* istanbul ignore next */\n                    throw new Error('Unsupported Type');\n                });\n            }\n            else {\n                var autoCountEncIndex = specM.wildcardIndex.encodingIndicesByProperty.get('autoCount') || [];\n                var neverHaveAutoCount = util_1.every(autoCountEncIndex, function (index) {\n                    var encQ = specM.getEncodingQueryByIndex(index);\n                    return encoding_1.isFieldQuery(encQ) && !wildcard_1.isWildcard(encQ.autoCount);\n                });\n                if (neverHaveAutoCount) {\n                    // If the query surely does not have autoCount\n                    // then one of the field should be\n                    // (1) unbinned quantitative\n                    // (2) temporal without time unit\n                    // (3) nominal or ordinal field\n                    // or at least have potential to be (still ambiguous).\n                    return util_1.some(specM.getEncodings(), function (encQ) {\n                        if (encoding_1.isFieldQuery(encQ) && encQ.type === type_1.Type.QUANTITATIVE) {\n                            if (encQ.autoCount === false) {\n                                return false;\n                            }\n                            else {\n                                return !encQ.bin || wildcard_1.isWildcard(encQ.bin);\n                            }\n                        }\n                        else if (encoding_1.isFieldQuery(encQ) && encQ.type === type_1.Type.TEMPORAL) {\n                            return !encQ.timeUnit || wildcard_1.isWildcard(encQ.timeUnit);\n                        }\n                        return false; // nominal or ordinal\n                    });\n                }\n            }\n            return true; // no auto count, no constraint\n        }\n    },\n    {\n        name: 'channelPermittedByMarkType',\n        description: 'Each encoding channel should be supported by the mark type',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK],\n        allowWildcardForProperties: true,\n        strict: true,\n        satisfy: function (specM, _, __) {\n            var mark = specM.getMark();\n            // if mark is unspecified, no need to check\n            if (wildcard_1.isWildcard(mark))\n                return true;\n            // TODO: can optimize this to detect only what's the changed property if needed.\n            return util_1.every(specM.getEncodings(), function (encQ) {\n                // channel unspecified, no need to check\n                if (wildcard_1.isWildcard(encQ.channel))\n                    return true;\n                return channel_1.supportMark(encQ.channel, mark);\n            });\n        }\n    },\n    {\n        name: 'hasAllRequiredChannelsForMark',\n        description: 'All required channels for the specified mark should be specified',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (specM, _, __) {\n            var mark = specM.getMark();\n            switch (mark) {\n                case mark_1.Mark.AREA:\n                case mark_1.Mark.LINE:\n                    return specM.channelUsed(channel_1.Channel.X) && specM.channelUsed(channel_1.Channel.Y);\n                case mark_1.Mark.TEXT:\n                    return specM.channelUsed(channel_1.Channel.TEXT);\n                case mark_1.Mark.BAR:\n                case mark_1.Mark.CIRCLE:\n                case mark_1.Mark.SQUARE:\n                case mark_1.Mark.TICK:\n                case mark_1.Mark.RULE:\n                    return specM.channelUsed(channel_1.Channel.X) || specM.channelUsed(channel_1.Channel.Y);\n                case mark_1.Mark.POINT:\n                    // This allows generating a point plot if channel was not a wildcard.\n                    return !specM.wildcardIndex.hasProperty(property_1.Property.CHANNEL) ||\n                        specM.channelUsed(channel_1.Channel.X) || specM.channelUsed(channel_1.Channel.Y);\n            }\n            /* istanbul ignore next */\n            throw new Error('hasAllRequiredChannelsForMark not implemented for mark' + JSON.stringify(mark));\n        }\n    },\n    {\n        name: 'omitAggregate',\n        description: 'Omit aggregate plots.',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowWildcardForProperties: true,\n        strict: false,\n        satisfy: function (specM, _, __) {\n            if (specM.isAggregate()) {\n                return false;\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitAggregatePlotWithDimensionOnlyOnFacet',\n        description: 'All required channels for the specified mark should be specified',\n        properties: [property_1.Property.CHANNEL, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (specM, _, opt) {\n            if (specM.isAggregate()) {\n                var hasNonFacetDim_1 = false, hasDim_1 = false, hasEnumeratedFacetDim_1 = false;\n                specM.specQuery.encodings.forEach(function (encQ, index) {\n                    if (encoding_1.isValueQuery(encQ) || encQ.autoCount === false)\n                        return; // skip unused field\n                    if (!encQ.aggregate && !encQ.autoCount) {\n                        hasDim_1 = true;\n                        if (util_1.contains([channel_1.Channel.ROW, channel_1.Channel.COLUMN], encQ.channel)) {\n                            if (specM.wildcardIndex.hasEncodingProperty(index, property_1.Property.CHANNEL)) {\n                                hasEnumeratedFacetDim_1 = true;\n                            }\n                        }\n                        else {\n                            hasNonFacetDim_1 = true;\n                        }\n                    }\n                });\n                if (hasDim_1 && !hasNonFacetDim_1) {\n                    if (hasEnumeratedFacetDim_1 || opt.constraintManuallySpecifiedValue) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitAggregatePlotWithoutDimension',\n        description: 'Aggregate plots without dimension should be omitted',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.BIN, property_1.Property.TIMEUNIT, property_1.Property.TYPE],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (specM, _, __) {\n            if (specM.isAggregate()) {\n                // TODO relax\n                return util_1.some(specM.getEncodings(), function (encQ) {\n                    if (encoding_1.isDiscrete(encQ)) {\n                        return true;\n                    }\n                    return false;\n                });\n            }\n            return true;\n        }\n    },\n    {\n        // TODO: we can be smarter and check if bar has occlusion based on profiling statistics\n        name: 'omitBarLineAreaWithOcclusion',\n        description: 'Don\\'t use bar, line or area to visualize raw plot as they often lead to occlusion.',\n        properties: [property_1.Property.MARK, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (specM, _, __) {\n            if (util_1.contains([mark_1.Mark.BAR, mark_1.Mark.LINE, mark_1.Mark.AREA], specM.getMark())) {\n                return specM.isAggregate();\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitBarTickWithSize',\n        description: 'Do not map field to size channel with bar and tick mark',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK],\n        allowWildcardForProperties: true,\n        strict: false,\n        satisfy: function (specM, _, opt) {\n            var mark = specM.getMark();\n            if (util_1.contains([mark_1.Mark.TICK, mark_1.Mark.BAR], mark)) {\n                if (specM.channelUsed(channel_1.Channel.SIZE)) {\n                    if (opt.constraintManuallySpecifiedValue) {\n                        // If size is used and we constraintManuallySpecifiedValue,\n                        // then the spec violates this constraint.\n                        return false;\n                    }\n                    else {\n                        // Otherwise have to search for the size channel and check if it is enumerated\n                        var encodings = specM.specQuery.encodings;\n                        for (var i = 0; i < encodings.length; i++) {\n                            var encQ = encodings[i];\n                            if (encQ.channel === channel_1.Channel.SIZE) {\n                                if (specM.wildcardIndex.hasEncodingProperty(i, property_1.Property.CHANNEL)) {\n                                    // If enumerated, then this is bad\n                                    return false;\n                                }\n                                else {\n                                    // If it's manually specified, no need to continue searching, just return.\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return true; // skip\n        }\n    },\n    {\n        name: 'omitBarAreaForLogScale',\n        description: 'Do not use bar and area mark for x and y\\'s log scale',\n        properties: [property_1.Property.MARK, property_1.Property.CHANNEL, property_1.Property.SCALE, property_1.getEncodingNestedProp('scale', 'type'), property_1.Property.TYPE],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (specM, _, __) {\n            var mark = specM.getMark();\n            var encodings = specM.getEncodings();\n            // TODO: mark or scale type should be enumerated\n            if (mark === mark_1.Mark.AREA || mark === mark_1.Mark.BAR) {\n                for (var _i = 0, encodings_2 = encodings; _i < encodings_2.length; _i++) {\n                    var encQ = encodings_2[_i];\n                    if (encoding_1.isFieldQuery(encQ) && ((encQ.channel === channel_1.Channel.X || encQ.channel === channel_1.Channel.Y) && encQ.scale)) {\n                        var sType = encoding_1.scaleType(encQ);\n                        if (sType === scale_1.ScaleType.LOG) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitMultipleNonPositionalChannels',\n        description: 'Unless manually specified, do not use multiple non-positional encoding channel to avoid over-encoding.',\n        properties: [property_1.Property.CHANNEL],\n        allowWildcardForProperties: true,\n        strict: false,\n        satisfy: function (specM, _, opt) {\n            // have to use specM.specQuery.encodings insetad of specM.getEncodings()\n            // since specM.getEncodings() remove encQ with autoCount===false from the array\n            // and thus might shift the index\n            var encodings = specM.specQuery.encodings;\n            var nonPositionChannelCount = 0;\n            var hasEnumeratedNonPositionChannel = false;\n            for (var i = 0; i < encodings.length; i++) {\n                var encQ = encodings[i];\n                if (encoding_1.isValueQuery(encQ) || encQ.autoCount === false)\n                    continue; // ignore skipped encoding\n                var channel = encQ.channel;\n                if (!wildcard_1.isWildcard(channel)) {\n                    if (NONSPATIAL_CHANNELS_INDEX[channel + '']) {\n                        nonPositionChannelCount += 1;\n                        if (specM.wildcardIndex.hasEncodingProperty(i, property_1.Property.CHANNEL)) {\n                            hasEnumeratedNonPositionChannel = true;\n                        }\n                        if (nonPositionChannelCount > 1 &&\n                            (hasEnumeratedNonPositionChannel || opt.constraintManuallySpecifiedValue)) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitNonPositionalOrFacetOverPositionalChannels',\n        description: 'Do not use non-positional channels unless all positional channels are used',\n        properties: [property_1.Property.CHANNEL],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (specM, _, opt) {\n            var encodings = specM.specQuery.encodings;\n            var hasNonPositionalChannelOrFacet = false;\n            var hasEnumeratedNonPositionOrFacetChannel = false;\n            var hasX = false, hasY = false;\n            for (var i = 0; i < encodings.length; i++) {\n                var encQ = encodings[i];\n                if (encoding_1.isValueQuery(encQ) || encQ.autoCount === false)\n                    continue; // ignore skipped encoding\n                var channel = encQ.channel;\n                if (channel === channel_1.Channel.X) {\n                    hasX = true;\n                }\n                else if (channel === channel_1.Channel.Y) {\n                    hasY = true;\n                }\n                else if (!wildcard_1.isWildcard(channel)) {\n                    // All non positional channel / Facet\n                    hasNonPositionalChannelOrFacet = true;\n                    if (specM.wildcardIndex.hasEncodingProperty(i, property_1.Property.CHANNEL)) {\n                        hasEnumeratedNonPositionOrFacetChannel = true;\n                    }\n                }\n            }\n            if (hasEnumeratedNonPositionOrFacetChannel ||\n                (opt.constraintManuallySpecifiedValue && hasNonPositionalChannelOrFacet)) {\n                return hasX && hasY;\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitRaw',\n        description: 'Omit raw plots.',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (specM, _, __) {\n            if (!specM.isAggregate()) {\n                return false;\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitRawContinuousFieldForAggregatePlot',\n        description: 'Aggregate plot should not use raw continuous field as group by values. ' +\n            '(Quantitative should be binned. Temporal should have time unit.)',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.TIMEUNIT, property_1.Property.BIN, property_1.Property.TYPE],\n        allowWildcardForProperties: true,\n        strict: false,\n        satisfy: function (specM, _, opt) {\n            if (specM.isAggregate()) {\n                var encodings = specM.specQuery.encodings;\n                for (var i = 0; i < encodings.length; i++) {\n                    var encQ = encodings[i];\n                    if (encoding_1.isValueQuery(encQ) || encQ.autoCount === false)\n                        continue; // skip unused encoding\n                    // TODO: aggregate for ordinal and temporal\n                    if (encQ.type === type_1.Type.TEMPORAL) {\n                        // Temporal fields should have timeUnit or is still a wildcard\n                        if (!encQ.timeUnit && (specM.wildcardIndex.hasEncodingProperty(i, property_1.Property.TIMEUNIT) ||\n                            opt.constraintManuallySpecifiedValue)) {\n                            return false;\n                        }\n                    }\n                    if (encQ.type === type_1.Type.QUANTITATIVE) {\n                        if (!encQ.bin && !encQ.aggregate && !encQ.autoCount) {\n                            // If Raw Q\n                            if (specM.wildcardIndex.hasEncodingProperty(i, property_1.Property.BIN) ||\n                                specM.wildcardIndex.hasEncodingProperty(i, property_1.Property.AGGREGATE) ||\n                                specM.wildcardIndex.hasEncodingProperty(i, property_1.Property.AUTOCOUNT)) {\n                                // and it's raw from enumeration\n                                return false;\n                            }\n                            if (opt.constraintManuallySpecifiedValue) {\n                                // or if we constraintManuallySpecifiedValue\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitRawDetail',\n        description: 'Do not use detail channel with raw plot.',\n        properties: [property_1.Property.CHANNEL, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (specM, _, opt) {\n            if (specM.isAggregate()) {\n                return true;\n            }\n            return util_1.every(specM.specQuery.encodings, function (encQ, index) {\n                if (encoding_1.isValueQuery(encQ) || encQ.autoCount === false)\n                    return true; // ignore autoCount field\n                if (encQ.channel === channel_1.Channel.DETAIL) {\n                    // Detail channel for raw plot is not good, except when its enumerated\n                    // or when it's manually specified but we constraintManuallySpecifiedValue.\n                    if (specM.wildcardIndex.hasEncodingProperty(index, property_1.Property.CHANNEL) ||\n                        opt.constraintManuallySpecifiedValue) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n    },\n    {\n        name: 'omitRepeatedField',\n        description: 'Each field should be mapped to only one channel',\n        properties: [property_1.Property.FIELD],\n        allowWildcardForProperties: true,\n        strict: false,\n        satisfy: function (specM, _, opt) {\n            var fieldUsed = {};\n            var fieldEnumerated = {};\n            var encodings = specM.specQuery.encodings;\n            for (var i = 0; i < encodings.length; i++) {\n                var encQ = encodings[i];\n                if (encoding_1.isValueQuery(encQ))\n                    continue;\n                if (encQ.field && !wildcard_1.isWildcard(encQ.field)) {\n                    var field = encQ.field;\n                    if (specM.wildcardIndex.hasEncodingProperty(i, property_1.Property.FIELD)) {\n                        fieldEnumerated[field] = true;\n                    }\n                    // When the field is specified previously,\n                    // if it is enumerated (either previously or in this encQ)\n                    // or if the opt.constraintManuallySpecifiedValue is true,\n                    // then it violates the constraint.\n                    if (fieldUsed[field]) {\n                        if (fieldEnumerated[field] || opt.constraintManuallySpecifiedValue) {\n                            return false;\n                        }\n                    }\n                    fieldUsed[field] = true;\n                }\n            }\n            return true;\n        }\n    },\n    // TODO: omitShapeWithBin\n    {\n        name: 'omitVerticalDotPlot',\n        description: 'Do not output vertical dot plot.',\n        properties: [property_1.Property.CHANNEL],\n        allowWildcardForProperties: true,\n        strict: false,\n        satisfy: function (specM, _, __) {\n            var encodings = specM.getEncodings();\n            if (encodings.length === 1 && encodings[0].channel === channel_1.Channel.Y) {\n                return false;\n            }\n            return true;\n        }\n    },\n    // EXPENSIVE CONSTRAINTS -- check them later!\n    {\n        name: 'hasAppropriateGraphicTypeForMark',\n        description: 'Has appropriate graphic type for mark',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK, property_1.Property.TYPE, property_1.Property.TIMEUNIT, property_1.Property.BIN, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (specM, _, __) {\n            var mark = specM.getMark();\n            switch (mark) {\n                case mark_1.Mark.AREA:\n                case mark_1.Mark.LINE:\n                    if (specM.isAggregate()) {\n                        var xEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.X);\n                        var yEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.Y);\n                        var xIsMeasure = xEncQ && encoding_1.isContinuous(xEncQ);\n                        var yIsMeasure = yEncQ && encoding_1.isContinuous(yEncQ);\n                        // for aggregate line / area, we need at least one group-by axis and one measure axis.\n                        return xEncQ && yEncQ && (xIsMeasure !== yIsMeasure) &&\n                            // and the dimension axis should not be nominal\n                            // TODO: make this clause optional\n                            !(encoding_1.isFieldQuery(xEncQ) && !xIsMeasure && xEncQ.type === type_1.Type.NOMINAL) &&\n                            !(encoding_1.isFieldQuery(yEncQ) && !yIsMeasure && yEncQ.type === type_1.Type.NOMINAL);\n                    }\n                    return true;\n                case mark_1.Mark.TEXT:\n                    // FIXME correctly when we add text\n                    return true;\n                case mark_1.Mark.BAR:\n                case mark_1.Mark.TICK:\n                    // Bar and tick should not use size.\n                    if (specM.channelUsed(channel_1.Channel.SIZE)) {\n                        return false;\n                    }\n                    else {\n                        // Tick and Bar should have one and only one continuous axis\n                        var xEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.X);\n                        var yEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.Y);\n                        var xIsContinuous = xEncQ && encoding_1.isContinuous(xEncQ);\n                        var yIsContinuous = yEncQ && encoding_1.isContinuous(yEncQ);\n                        if (xIsContinuous !== yIsContinuous) {\n                            // TODO: Bar and tick's dimension should not be continuous (quant/time) scale\n                            return true;\n                        }\n                        return false;\n                    }\n                case mark_1.Mark.CIRCLE:\n                case mark_1.Mark.POINT:\n                case mark_1.Mark.SQUARE:\n                case mark_1.Mark.RULE:\n                    return true;\n            }\n            /* istanbul ignore next */\n            throw new Error('hasAllRequiredChannelsForMark not implemented for mark' + mark);\n        }\n    },\n    {\n        name: 'omitNonLinearScaleTypeWithStack',\n        description: 'Stacked plot should only use linear scale',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.SCALE, property_1.getEncodingNestedProp('scale', 'type'), property_1.Property.TYPE],\n        // TODO: Property.STACK\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (specM, _, __) {\n            var stack = specM.stack();\n            if (stack) {\n                for (var _i = 0, _a = specM.getEncodings(); _i < _a.length; _i++) {\n                    var encQ = _a[_i];\n                    if (encoding_1.isValueQuery(encQ))\n                        continue;\n                    if ((!!encQ.aggregate || encQ.autoCount === true) &&\n                        encQ.type === type_1.Type.QUANTITATIVE &&\n                        util_1.contains([channel_1.Channel.X, channel_1.Channel.Y], encQ.channel)) {\n                        if (encoding_1.scaleType(encQ) !== scale_1.ScaleType.LINEAR) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitNonSumStack',\n        description: 'Stacked plot should use summative aggregation such as sum, count, or distinct',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (specM, _, __) {\n            var stack = specM.stack();\n            if (stack) {\n                var measureEncQ = specM.getEncodingQueryByChannel(stack.fieldChannel);\n                return encoding_1.isFieldQuery(measureEncQ) && (util_1.contains(aggregate_1.SUM_OPS, measureEncQ.aggregate) || !!measureEncQ.autoCount);\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitTableWithOcclusionIfAutoAddCount',\n        description: 'Plots without aggregation or autocount where x and y are both discrete should be omitted if autoAddCount is enabled as they often lead to occlusion',\n        properties: [property_1.Property.CHANNEL, property_1.Property.TYPE, property_1.Property.TIMEUNIT, property_1.Property.BIN, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (specM, _, opt) {\n            if (opt.autoAddCount) {\n                var xEncQ = specM.getEncodingQueryByChannel('x');\n                var yEncQ = specM.getEncodingQueryByChannel('y');\n                // TODO(#186): take mark properties channel into account\n                if (encoding_1.isDiscrete(xEncQ) &&\n                    encoding_1.isDiscrete(yEncQ) &&\n                    !specM.isAggregate() // TODO: refactor based on statistics\n                ) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n].map(function (sc) { return new SpecConstraintModel(sc); });\n// For testing\nexports.SPEC_CONSTRAINT_INDEX = exports.SPEC_CONSTRAINTS.reduce(function (m, c) {\n    m[c.name()] = c;\n    return m;\n}, {});\nvar SPEC_CONSTRAINTS_BY_PROPERTY = exports.SPEC_CONSTRAINTS.reduce(function (index, c) {\n    for (var _i = 0, _a = c.properties(); _i < _a.length; _i++) {\n        var prop = _a[_i];\n        // Initialize array and use it\n        index.set(prop, index.get(prop) || []);\n        index.get(prop).push(c);\n    }\n    return index;\n}, new propindex_1.PropIndex());\n/**\n * Check all encoding constraints for a particular property and index tuple\n */\nfunction checkSpec(prop, wildcard, specM, schema, opt) {\n    // Check encoding constraint\n    var specConstraints = SPEC_CONSTRAINTS_BY_PROPERTY.get(prop) || [];\n    for (var _i = 0, specConstraints_1 = specConstraints; _i < specConstraints_1.length; _i++) {\n        var c = specConstraints_1[_i];\n        // Check if the constraint is enabled\n        if (c.strict() || !!opt[c.name()]) {\n            // For strict constraint, or enabled non-strict, check the constraints\n            var satisfy = c.satisfy(specM, schema, opt);\n            if (!satisfy) {\n                var violatedConstraint = '(spec) ' + c.name();\n                /* istanbul ignore if */\n                if (opt.verbose) {\n                    console.log(violatedConstraint + ' failed with ' + specM.toShorthand() + ' for ' + wildcard.name);\n                }\n                return violatedConstraint;\n            }\n        }\n    }\n    return null;\n}\nexports.checkSpec = checkSpec;\n//# sourceMappingURL=spec.js.map",
    "\"use strict\";\nexports.version = '0.11.0';\nexports.config = require(\"./config\");\nexports.constraint = require(\"./constraint\");\nexports.enumerate = require(\"./enumerator\");\nexports.wildcard = require(\"./wildcard\");\nvar generate_1 = require(\"./generate\");\nexports.generate = generate_1.generate;\nexports.model = require(\"./model\");\nexports.nest = require(\"./nest\");\nexports.property = require(\"./property\");\nexports.query = require(\"./query\");\nexports.ranking = require(\"./ranking/ranking\");\nvar recommend_1 = require(\"./recommend\");\nexports.recommend = recommend_1.recommend;\nexports.schema = require(\"./schema\");\nexports.util = require(\"./util\");\n//# sourceMappingURL=cql.js.map",
    "\"use strict\";\nvar encoding_1 = require(\"./constraint/encoding\");\nvar spec_1 = require(\"./constraint/spec\");\nvar property_1 = require(\"./property\");\nvar propindex_1 = require(\"./propindex\");\nvar encoding_2 = require(\"./query/encoding\");\nvar ENUMERATOR_INDEX = new propindex_1.PropIndex();\nfunction getEnumerator(prop) {\n    return ENUMERATOR_INDEX.get(prop);\n}\nexports.getEnumerator = getEnumerator;\nENUMERATOR_INDEX.set('mark', function (wildcardIndex, schema, opt) {\n    return function (answerSet, specM) {\n        var markWildcard = specM.getMark();\n        // enumerate the value\n        markWildcard.enum.forEach(function (mark) {\n            specM.setMark(mark);\n            // Check spec constraint\n            var violatedSpecConstraint = spec_1.checkSpec('mark', wildcardIndex.mark, specM, schema, opt);\n            if (!violatedSpecConstraint) {\n                // emit\n                answerSet.push(specM.duplicate());\n            }\n        });\n        // Reset to avoid side effect\n        specM.resetMark();\n        return answerSet;\n    };\n});\nproperty_1.ENCODING_TOPLEVEL_PROPS.forEach(function (prop) {\n    ENUMERATOR_INDEX.set(prop, EncodingPropertyGeneratorFactory(prop));\n});\nproperty_1.ENCODING_NESTED_PROPS.forEach(function (nestedProp) {\n    ENUMERATOR_INDEX.set(nestedProp, EncodingPropertyGeneratorFactory(nestedProp));\n});\n/**\n * @param prop property type.\n * @return an answer set reducer factory for the given prop.\n */\nfunction EncodingPropertyGeneratorFactory(prop) {\n    /**\n     * @return as reducer that takes a specQueryModel as input and output an answer set array.\n     */\n    return function (wildcardIndex, schema, opt) {\n        return function (answerSet, specM) {\n            // index of encoding mappings that require enumeration\n            var indices = wildcardIndex.encodingIndicesByProperty.get(prop);\n            function enumerate(jobIndex) {\n                if (jobIndex === indices.length) {\n                    // emit and terminate\n                    answerSet.push(specM.duplicate());\n                    return;\n                }\n                var index = indices[jobIndex];\n                var wildcard = wildcardIndex.encodings[index].get(prop);\n                var encQ = specM.getEncodingQueryByIndex(index);\n                var propWildcard = specM.getEncodingProperty(index, prop);\n                if (encoding_2.isValueQuery(encQ) || (\n                // TODO: encQ.exclude\n                // If this encoding query is an excluded autoCount, there is no point enumerating other properties\n                // for this encoding query because they will be excluded anyway.\n                // Thus, we can just move on to the next encoding to enumerate.\n                encQ.autoCount === false ||\n                    // nested encoding property might have its parent set to false\n                    // therefore, we no longer have to enumerate them\n                    !propWildcard)) {\n                    enumerate(jobIndex + 1);\n                }\n                else {\n                    wildcard.enum.forEach(function (propVal) {\n                        if (propVal === null) {\n                            // our duplicate() method use JSON.stringify, parse and thus can accidentally\n                            // convert undefined in an array into null\n                            propVal = undefined;\n                        }\n                        specM.setEncodingProperty(index, prop, propVal, wildcard);\n                        // Check encoding constraint\n                        var violatedEncodingConstraint = encoding_1.checkEncoding(prop, wildcard, index, specM, schema, opt);\n                        if (violatedEncodingConstraint) {\n                            return; // do not keep searching\n                        }\n                        // Check spec constraint\n                        var violatedSpecConstraint = spec_1.checkSpec(prop, wildcard, specM, schema, opt);\n                        if (violatedSpecConstraint) {\n                            return; // do not keep searching\n                        }\n                        // If qualify all of the constraints, keep enumerating\n                        enumerate(jobIndex + 1);\n                    });\n                    // Reset to avoid side effect\n                    specM.resetEncodingProperty(index, prop, wildcard);\n                }\n            }\n            // start enumerating from 0\n            enumerate(0);\n            return answerSet;\n        };\n    };\n}\nexports.EncodingPropertyGeneratorFactory = EncodingPropertyGeneratorFactory;\n//# sourceMappingURL=enumerator.js.map",
    "\"use strict\";\nvar config_1 = require(\"./config\");\nvar enumerator_1 = require(\"./enumerator\");\nvar model_1 = require(\"./model\");\nvar property_1 = require(\"./property\");\nvar stylize_1 = require(\"./stylize\");\nfunction generate(specQ, schema, opt) {\n    if (opt === void 0) { opt = config_1.DEFAULT_QUERY_CONFIG; }\n    // 1. Build a SpecQueryModel, which also contains wildcardIndex\n    var specM = model_1.SpecQueryModel.build(specQ, schema, opt);\n    var wildcardIndex = specM.wildcardIndex;\n    // 2. Enumerate each of the properties based on propPrecedence.\n    var answerSet = [specM]; // Initialize Answer Set with only the input spec query.\n    opt.propertyPrecedence.forEach(function (propKey) {\n        var prop = property_1.fromKey(propKey);\n        // If the original specQuery contains wildcard for this prop\n        if (wildcardIndex.hasProperty(prop)) {\n            // update answerset\n            var enumerator = enumerator_1.getEnumerator(prop);\n            var reducer = enumerator(wildcardIndex, schema, opt);\n            answerSet = answerSet.reduce(reducer, []);\n        }\n    });\n    if (opt.stylize) {\n        if ((opt.nominalColorScaleForHighCardinality !== null) ||\n            (opt.smallRangeStepForHighCardinalityOrFacet !== null) ||\n            (opt.xAxisOnTopForHighYCardinalityWithoutColumn !== null)) {\n            return stylize_1.stylize(answerSet, schema, opt);\n        }\n    }\n    return answerSet;\n}\nexports.generate = generate;\n//# sourceMappingURL=generate.js.map",
    "\"use strict\";\nvar type_1 = require(\"vega-lite/build/src/type\");\nvar property_1 = require(\"./property\");\nvar wildcard_1 = require(\"./wildcard\");\nvar wildcardindex_1 = require(\"./wildcardindex\");\nvar spec_1 = require(\"./query/spec\");\nvar encoding_1 = require(\"./query/encoding\");\nvar groupby_1 = require(\"./query/groupby\");\nvar shorthand_1 = require(\"./query/shorthand\");\nvar util_1 = require(\"./util\");\n/**\n * Internal class for specQuery that provides helper for the enumeration process.\n */\nvar SpecQueryModel = (function () {\n    function SpecQueryModel(spec, wildcardIndex, schema, opt, wildcardAssignment) {\n        this._rankingScore = {};\n        this._spec = spec;\n        this._channelFieldCount = spec.encodings.reduce(function (m, encQ) {\n            // TODO(akshatsh): add a test case\n            if (encoding_1.isFieldQuery(encQ) && !wildcard_1.isWildcard(encQ.channel) && encQ.autoCount !== false) {\n                m[encQ.channel + ''] = 1;\n            }\n            return m;\n        }, {});\n        this._wildcardIndex = wildcardIndex;\n        this._assignedWildcardIndex = wildcardAssignment;\n        this._opt = opt;\n        this._schema = schema;\n    }\n    /**\n     * Build an WildcardIndex by detecting enumeration specifiers\n     * in the input specQuery and replace short wildcards with\n     * full ones that includes both names and enumValues.\n     *\n     * @return a SpecQueryModel that wraps the specQuery and the WildcardIndex.\n     */\n    SpecQueryModel.build = function (specQ, schema, opt) {\n        var wildcardIndex = new wildcardindex_1.WildcardIndex();\n        // mark\n        if (wildcard_1.isWildcard(specQ.mark)) {\n            var name_1 = wildcard_1.getDefaultName(property_1.Property.MARK);\n            specQ.mark = wildcard_1.initWildcard(specQ.mark, name_1, opt.enum.mark);\n            wildcardIndex.setMark(specQ.mark);\n        }\n        // TODO: transform\n        // encodings\n        specQ.encodings.forEach(function (encQ, index) {\n            if (encoding_1.isFieldQuery(encQ) && encQ.autoCount !== undefined) {\n                // This is only for testing purpose\n                console.warn('A field with autoCount should not be included as autoCount meant to be an internal object.');\n                encQ.type = type_1.Type.QUANTITATIVE; // autoCount is always quantitative\n            }\n            if (encoding_1.isFieldQuery(encQ) && encQ.type === undefined) {\n                // type is optional -- we automatically augment wildcard if not specified\n                encQ.type = wildcard_1.SHORT_WILDCARD;\n            }\n            // For each property of the encodingQuery, enumerate\n            property_1.ENCODING_TOPLEVEL_PROPS.forEach(function (prop) {\n                if (wildcard_1.isWildcard(encQ[prop])) {\n                    // Assign default wildcard name and enum values.\n                    var defaultWildcardName = wildcard_1.getDefaultName(prop) + index;\n                    var defaultEnumValues = wildcard_1.getDefaultEnumValues(prop, schema, opt);\n                    var wildcard = encQ[prop] = wildcard_1.initWildcard(encQ[prop], defaultWildcardName, defaultEnumValues);\n                    // Add index of the encoding mapping to the property's wildcard index.\n                    wildcardIndex.setEncodingProperty(index, prop, wildcard);\n                }\n            });\n            // For each nested property of the encoding query  (e.g., encQ.bin.maxbins)\n            property_1.ENCODING_NESTED_PROPS.forEach(function (prop) {\n                var propObj = encQ[prop.parent]; // the property object e.g., encQ.bin\n                if (propObj) {\n                    var child = prop.child;\n                    if (wildcard_1.isWildcard(propObj[child])) {\n                        // Assign default wildcard name and enum values.\n                        var defaultWildcardName = wildcard_1.getDefaultName(prop) + index;\n                        var defaultEnumValues = wildcard_1.getDefaultEnumValues(prop, schema, opt);\n                        var wildcard = propObj[child] = wildcard_1.initWildcard(propObj[child], defaultWildcardName, defaultEnumValues);\n                        // Add index of the encoding mapping to the property's wildcard index.\n                        wildcardIndex.setEncodingProperty(index, prop, wildcard);\n                    }\n                }\n            });\n        });\n        // AUTO COUNT\n        // Add Auto Count Field\n        if (opt.autoAddCount) {\n            var countEncQ = {\n                channel: {\n                    name: wildcard_1.getDefaultName(property_1.Property.CHANNEL) + specQ.encodings.length,\n                    enum: wildcard_1.getDefaultEnumValues(property_1.Property.CHANNEL, schema, opt)\n                },\n                autoCount: {\n                    name: wildcard_1.getDefaultName(property_1.Property.AUTOCOUNT) + specQ.encodings.length,\n                    enum: [false, true]\n                },\n                type: type_1.Type.QUANTITATIVE\n            };\n            specQ.encodings.push(countEncQ);\n            var index = specQ.encodings.length - 1;\n            // Add index of the encoding mapping to the property's wildcard index.\n            wildcardIndex.setEncodingProperty(index, property_1.Property.CHANNEL, countEncQ.channel);\n            wildcardIndex.setEncodingProperty(index, property_1.Property.AUTOCOUNT, countEncQ.autoCount);\n        }\n        return new SpecQueryModel(specQ, wildcardIndex, schema, opt, {});\n    };\n    Object.defineProperty(SpecQueryModel.prototype, \"wildcardIndex\", {\n        get: function () {\n            return this._wildcardIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecQueryModel.prototype, \"schema\", {\n        get: function () {\n            return this._schema;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecQueryModel.prototype, \"specQuery\", {\n        get: function () {\n            return this._spec;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SpecQueryModel.prototype.duplicate = function () {\n        return new SpecQueryModel(util_1.duplicate(this._spec), this._wildcardIndex, this._schema, this._opt, util_1.duplicate(this._assignedWildcardIndex));\n    };\n    SpecQueryModel.prototype.setMark = function (mark) {\n        var name = this._spec.mark.name;\n        this._assignedWildcardIndex[name] = this._spec.mark = mark;\n    };\n    SpecQueryModel.prototype.resetMark = function () {\n        var wildcard = this._spec.mark = this._wildcardIndex.mark;\n        delete this._assignedWildcardIndex[wildcard.name];\n    };\n    SpecQueryModel.prototype.getMark = function () {\n        return this._spec.mark;\n    };\n    SpecQueryModel.prototype.getEncodingProperty = function (index, prop) {\n        var encQ = this._spec.encodings[index];\n        if (property_1.isEncodingNestedProp(prop)) {\n            return encQ[prop.parent][prop.child];\n        }\n        return encQ[prop]; // encoding property (non-nested)\n    };\n    SpecQueryModel.prototype.setEncodingProperty = function (index, prop, value, wildcard) {\n        var encQ = this._spec.encodings[index];\n        if (prop === property_1.Property.CHANNEL && encQ.channel && !wildcard_1.isWildcard(encQ.channel)) {\n            // If there is an old channel\n            this._channelFieldCount[encQ.channel]--;\n        }\n        if (property_1.isEncodingNestedProp(prop)) {\n            encQ[prop.parent][prop.child] = value;\n        }\n        else if (property_1.hasNestedProperty(prop) && value === true) {\n            encQ[prop] = util_1.extend({}, encQ[prop], // copy all existing properties\n            { enum: undefined, name: undefined } // except name and values to it no longer an wildcard\n            );\n        }\n        else {\n            encQ[prop] = value;\n        }\n        this._assignedWildcardIndex[wildcard.name] = value;\n        if (prop === property_1.Property.CHANNEL) {\n            // If there is a new channel, make sure it exists and add it to the count.\n            this._channelFieldCount[value] = (this._channelFieldCount[value] || 0) + 1;\n        }\n    };\n    SpecQueryModel.prototype.resetEncodingProperty = function (index, prop, wildcard) {\n        var encQ = this._spec.encodings[index];\n        if (prop === property_1.Property.CHANNEL) {\n            this._channelFieldCount[encQ.channel]--;\n        }\n        // reset it to wildcard\n        if (property_1.isEncodingNestedProp(prop)) {\n            encQ[prop.parent][prop.child] = wildcard;\n        }\n        else {\n            encQ[prop] = wildcard;\n        }\n        // add remove value that is reset from the assignment map\n        delete this._assignedWildcardIndex[wildcard.name];\n    };\n    SpecQueryModel.prototype.channelUsed = function (channel) {\n        // do not include encoding that has autoCount = false because it is not a part of the output spec.\n        return this._channelFieldCount[channel] > 0;\n    };\n    SpecQueryModel.prototype.stack = function () {\n        return spec_1.stack(this._spec);\n    };\n    SpecQueryModel.prototype.getEncodings = function () {\n        // do not include encoding that has autoCount = false because it is not a part of the output spec.\n        return this._spec.encodings.filter(function (encQ) { return (encoding_1.isValueQuery(encQ) || encQ.autoCount !== false); });\n    };\n    SpecQueryModel.prototype.getEncodingQueryByChannel = function (channel) {\n        for (var _i = 0, _a = this._spec.encodings; _i < _a.length; _i++) {\n            var specEncoding = _a[_i];\n            if (specEncoding.channel === channel) {\n                return specEncoding;\n            }\n        }\n        return undefined;\n    };\n    SpecQueryModel.prototype.getEncodingQueryByIndex = function (i) {\n        return this._spec.encodings[i];\n    };\n    SpecQueryModel.prototype.isAggregate = function () {\n        return spec_1.isAggregate(this._spec);\n    };\n    SpecQueryModel.prototype.toShorthand = function (groupBy) {\n        if (groupBy) {\n            var parsedGroupBy = groupby_1.parseGroupBy(groupBy);\n            return shorthand_1.spec(this._spec, parsedGroupBy.include, parsedGroupBy.replacer);\n        }\n        return shorthand_1.spec(this._spec);\n    };\n    SpecQueryModel.prototype._encoding = function () {\n        var encoding = {};\n        for (var _i = 0, _a = this._spec.encodings; _i < _a.length; _i++) {\n            var encQ = _a[_i];\n            var fieldDef = {};\n            // For count field that is automatically added, convert to correct vega-lite fieldDef\n            if (encoding_1.isFieldQuery(encQ) && encQ.autoCount === true) {\n                fieldDef.aggregate = 'count';\n                fieldDef.field = '*';\n                fieldDef.type = type_1.Type.QUANTITATIVE;\n            }\n            else if (encoding_1.isValueQuery(encQ) || encQ.autoCount === false) {\n                continue; // Do not include this in the output.\n            }\n            // if channel is a wildcard, return null\n            if (wildcard_1.isWildcard(encQ.channel))\n                return null;\n            // assemble other property into a field def.\n            var PROPERTIES = [property_1.Property.AGGREGATE, property_1.Property.BIN, property_1.Property.TIMEUNIT, property_1.Property.FIELD, property_1.Property.TYPE, property_1.Property.SCALE, property_1.Property.SORT, property_1.Property.AXIS, property_1.Property.LEGEND];\n            // TODO(#226):\n            // write toSpec() and toShorthand() in a way that prevents outputting inapplicable scale, sort, axis / legend\n            for (var _b = 0, PROPERTIES_1 = PROPERTIES; _b < PROPERTIES_1.length; _b++) {\n                var prop = PROPERTIES_1[_b];\n                // if the property is a wildcard, return null\n                if (wildcard_1.isWildcard(encQ[prop]))\n                    return null;\n                // otherwise, assign the proper to the field def\n                if (encQ[prop] !== undefined) {\n                    if (!shorthand_1.PROPERTY_SUPPORTED_CHANNELS[prop] ||\n                        shorthand_1.PROPERTY_SUPPORTED_CHANNELS[prop][encQ.channel]) {\n                        fieldDef[prop] = encQ[prop];\n                    }\n                }\n            }\n            if (fieldDef.bin === false) {\n                // exclude bin false\n                delete fieldDef.bin;\n            }\n            encoding[encQ.channel] = fieldDef;\n        }\n        return encoding;\n    };\n    /**\n     * Convert a query to a Vega-Lite spec if it is completed.\n     * @return a Vega-Lite spec if completed, null otherwise.\n     */\n    SpecQueryModel.prototype.toSpec = function (data) {\n        if (wildcard_1.isWildcard(this._spec.mark))\n            return null;\n        var spec = {};\n        data = data || this._spec.data;\n        if (data) {\n            spec.data = data;\n        }\n        if (this._spec.transform) {\n            spec.transform = this._spec.transform;\n        }\n        spec.mark = this._spec.mark;\n        spec.encoding = this._encoding();\n        if (spec.encoding === null) {\n            return null;\n        }\n        if (this._spec.config || this._opt.defaultSpecConfig)\n            spec.config = util_1.extend({}, this._opt.defaultSpecConfig, this._spec.config);\n        return spec;\n    };\n    SpecQueryModel.prototype.getRankingScore = function (rankingName) {\n        return this._rankingScore[rankingName];\n    };\n    SpecQueryModel.prototype.setRankingScore = function (rankingName, score) {\n        this._rankingScore[rankingName] = score;\n    };\n    return SpecQueryModel;\n}());\nexports.SpecQueryModel = SpecQueryModel;\nvar SpecQueryModelGroup = (function () {\n    function SpecQueryModelGroup(name, path, items, groupBy, orderGroupBy) {\n        if (name === void 0) { name = ''; }\n        if (path === void 0) { path = ''; }\n        if (items === void 0) { items = []; }\n        if (groupBy === void 0) { groupBy = undefined; }\n        if (orderGroupBy === void 0) { orderGroupBy = undefined; }\n        this._name = name;\n        this._path = path;\n        this._items = items;\n        this._groupBy = groupBy;\n        this._orderGroupBy = orderGroupBy;\n    }\n    SpecQueryModelGroup.prototype.getTopSpecQueryModel = function () {\n        var topItem = this._items[0];\n        if (topItem instanceof SpecQueryModelGroup) {\n            return topItem.getTopSpecQueryModel();\n        }\n        else {\n            return topItem;\n        }\n    };\n    Object.defineProperty(SpecQueryModelGroup.prototype, \"name\", {\n        get: function () {\n            return this._name;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecQueryModelGroup.prototype, \"items\", {\n        get: function () {\n            return this._items;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecQueryModelGroup.prototype, \"groupBy\", {\n        get: function () {\n            return this._groupBy;\n        },\n        set: function (groupBy) {\n            this._groupBy = groupBy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecQueryModelGroup.prototype, \"orderGroupBy\", {\n        get: function () {\n            return this._orderGroupBy;\n        },\n        set: function (orderGroupBy) {\n            this._orderGroupBy = orderGroupBy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return SpecQueryModelGroup;\n}());\nexports.SpecQueryModelGroup = SpecQueryModelGroup;\n//# sourceMappingURL=model.js.map",
    "\"use strict\";\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar util_1 = require(\"datalib/src/util\");\nvar model_1 = require(\"./model\");\nvar property_1 = require(\"./property\");\nvar propindex_1 = require(\"./propindex\");\nvar groupby_1 = require(\"./query/groupby\");\nvar shorthand_1 = require(\"./query/shorthand\");\nvar spec_1 = require(\"./query/spec\");\n/**\n * Registry for all possible grouping key functions.\n */\nvar groupRegistry = {};\n/**\n * Add a grouping function to the registry.\n */\nfunction registerKeyFn(name, keyFn) {\n    groupRegistry[name] = keyFn;\n}\nexports.registerKeyFn = registerKeyFn;\nexports.FIELD = 'field';\nexports.FIELD_TRANSFORM = 'fieldTransform';\nexports.ENCODING = 'encoding';\nexports.TRANSPOSE = 'transpose';\nexports.SPEC = 'spec';\n/**\n * Group the input spec query model by a key function registered in the group registry\n * @return\n */\nfunction nest(specModels, queryNest) {\n    if (queryNest) {\n        var rootGroup_1 = new model_1.SpecQueryModelGroup();\n        var groupIndex_1 = {};\n        // global `includes` and `replaces` will get augmented by each level's groupBy.\n        // Upper level's `groupBy` will get cascaded to lower-level groupBy.\n        // `replace` can be overriden in a lower-level to support different grouping.\n        var includes_1 = [];\n        var replaces = [];\n        var replacers_1 = [];\n        for (var l = 0; l < queryNest.length; l++) {\n            includes_1.push(l > 0 ? includes_1[l - 1].duplicate() : new propindex_1.PropIndex());\n            replaces.push(l > 0 ? replaces[l - 1].duplicate() : new propindex_1.PropIndex());\n            var groupBy = queryNest[l].groupBy;\n            if (util_1.isArray(groupBy)) {\n                // If group is array, it's an array of extended group by that need to be parsed\n                var parsedGroupBy = groupby_1.parseGroupBy(groupBy, includes_1[l], replaces[l]);\n                replacers_1.push(parsedGroupBy.replacer);\n            }\n        }\n        // With includes and replacers, now we can construct the nesting tree\n        specModels.forEach(function (specM) {\n            var path = '';\n            var group = rootGroup_1;\n            for (var l = 0; l < queryNest.length; l++) {\n                var groupBy = group.groupBy = queryNest[l].groupBy;\n                group.orderGroupBy = queryNest[l].orderGroupBy;\n                var key = util_1.isArray(groupBy) ?\n                    shorthand_1.spec(specM.specQuery, includes_1[l], replacers_1[l]) :\n                    groupRegistry[groupBy](specM);\n                path += '/' + key;\n                if (!groupIndex_1[path]) {\n                    groupIndex_1[path] = new model_1.SpecQueryModelGroup(key, path, []);\n                    group.items.push(groupIndex_1[path]);\n                }\n                group = groupIndex_1[path];\n            }\n            group.items.push(specM);\n        });\n        return rootGroup_1;\n    }\n    else {\n        // no nesting, just return a flat group\n        return new model_1.SpecQueryModelGroup('', '', specModels);\n    }\n}\nexports.nest = nest;\n// TODO: move this to groupBy, rename properly, and export\nvar GROUP_BY_FIELD = [property_1.Property.FIELD];\nvar PARSED_GROUP_BY_FIELD = groupby_1.parseGroupBy(GROUP_BY_FIELD);\nregisterKeyFn(exports.FIELD, function (specM) {\n    return shorthand_1.spec(specM.specQuery, PARSED_GROUP_BY_FIELD.include, PARSED_GROUP_BY_FIELD.replacer);\n});\nexports.PARSED_GROUP_BY_FIELD_TRANSFORM = groupby_1.parseGroupBy(groupby_1.GROUP_BY_FIELD_TRANSFORM);\nregisterKeyFn(exports.FIELD_TRANSFORM, function (specM) {\n    return shorthand_1.spec(specM.specQuery, exports.PARSED_GROUP_BY_FIELD_TRANSFORM.include, exports.PARSED_GROUP_BY_FIELD_TRANSFORM.replacer);\n});\nexports.PARSED_GROUP_BY_ENCODING = groupby_1.parseGroupBy(groupby_1.GROUP_BY_ENCODING);\nregisterKeyFn(exports.ENCODING, function (specM) {\n    return shorthand_1.spec(specM.specQuery, exports.PARSED_GROUP_BY_ENCODING.include, exports.PARSED_GROUP_BY_ENCODING.replacer);\n});\nfunction stringifyStack(specM) {\n    var _stack = spec_1.stack(specM.specQuery);\n    return (!!_stack ? 'stack=' + _stack.offset + '|' : '');\n}\n// TODO: rename, provide similar format\nregisterKeyFn(exports.TRANSPOSE, function (specM) {\n    return specM.getMark() + '|' +\n        stringifyStack(specM) +\n        specM.getEncodings().map(function (encQ) {\n            var fieldDef = shorthand_1.fieldDef(encQ);\n            var channel = (encQ.channel === channel_1.Channel.X || encQ.channel === channel_1.Channel.Y) ? 'xy' :\n                (encQ.channel === channel_1.Channel.ROW || encQ.channel === channel_1.Channel.COLUMN) ? 'facet' :\n                    encQ.channel;\n            return channel + ':' + fieldDef;\n        })\n            .sort()\n            .join('|');\n});\nregisterKeyFn(exports.SPEC, function (specM) { return JSON.stringify(specM.specQuery); });\n//# sourceMappingURL=nest.js.map",
    "\"use strict\";\nvar axis_1 = require(\"vega-lite/build/src/axis\");\nvar scale_1 = require(\"vega-lite/build/src/scale\");\nvar legend_1 = require(\"vega-lite/build/src/legend\");\nvar util_1 = require(\"./util\");\nfunction isEncodingNestedProp(p) {\n    return !!p['parent'];\n}\nexports.isEncodingNestedProp = isEncodingNestedProp;\nexports.ENCODING_TOPLEVEL_PROPS = [\n    // channel\n    'channel',\n    // fn\n    'aggregate', 'autoCount', 'bin', 'timeUnit', 'hasFn',\n    // sort\n    'sort',\n    // field / type\n    'field', 'type',\n    // scale / axis / legend\n    'scale', 'axis', 'legend'\n];\nvar ENCODING_TOPLEVEL_PROPERTY_INDEX = util_1.toMap(exports.ENCODING_TOPLEVEL_PROPS);\nfunction isEncodingTopLevelProperty(p) {\n    return p in ENCODING_TOPLEVEL_PROPERTY_INDEX;\n}\nexports.isEncodingTopLevelProperty = isEncodingTopLevelProperty;\nvar ENCODING_NESTED_PROP_PARENTS = [\n    'bin', 'scale', 'sort', 'axis', 'legend'\n];\nvar ENCODING_NESTED_PROP_PARENT_INDEX = util_1.toMap(ENCODING_NESTED_PROP_PARENTS);\nfunction hasNestedProperty(prop) {\n    return ENCODING_NESTED_PROP_PARENT_INDEX[prop];\n}\nexports.hasNestedProperty = hasNestedProperty;\nexports.BIN_CHILD_PROPS = ['maxbins', 'divide', 'extent', 'base', 'step', 'steps', 'minstep'];\nexports.SORT_CHILD_PROPS = ['field', 'op', 'order'];\nexports.SCALE_CHILD_PROPS = ['clamp', 'domain', 'exponent', 'nice', 'range', 'rangeStep', 'round', 'type', 'zero'];\nvar BIN_PROPS = exports.BIN_CHILD_PROPS.map(function (c) {\n    return { parent: 'bin', child: c };\n});\nexports.SORT_PROPS = exports.SORT_CHILD_PROPS.map(function (c) {\n    return { parent: 'sort', child: c };\n});\nexports.SCALE_PROPS = scale_1.SCALE_PROPERTIES.map(function (c) {\n    return { parent: 'scale', child: c };\n});\nvar AXIS_PROPS = axis_1.AXIS_PROPERTIES.map(function (c) {\n    return { parent: 'axis', child: c };\n});\nvar LEGEND_PROPS = legend_1.LEGEND_PROPERTIES.map(function (c) {\n    return { parent: 'legend', child: c };\n});\nexports.ENCODING_NESTED_PROPS = [].concat(BIN_PROPS, exports.SORT_PROPS, exports.SCALE_PROPS, AXIS_PROPS, LEGEND_PROPS);\nvar PROP_KEY_DELIMITER = '.';\nfunction toKey(p) {\n    if (isEncodingNestedProp(p)) {\n        return p.parent + PROP_KEY_DELIMITER + p.child;\n    }\n    return p;\n}\nexports.toKey = toKey;\nfunction fromKey(k) {\n    var split = k.split(PROP_KEY_DELIMITER);\n    /* istanbul ignore else */\n    if (split.length === 1) {\n        return k;\n    }\n    else if (split.length === 2) {\n        return {\n            parent: split[0],\n            child: split[1]\n        };\n    }\n    else {\n        throw 'Invalid property key with ' + split.length + ' dots: ' + k;\n    }\n}\nexports.fromKey = fromKey;\nvar ENCODING_NESTED_PROP_INDEX = exports.ENCODING_NESTED_PROPS.reduce(function (i, prop) {\n    i[prop.parent] = i[prop.parent] || [];\n    i[prop.parent][prop.child] = prop;\n    return i;\n}, {});\n// FIXME consider using a more general method\nfunction getEncodingNestedProp(parent, child) {\n    return (ENCODING_NESTED_PROP_INDEX[parent] || {})[child];\n}\nexports.getEncodingNestedProp = getEncodingNestedProp;\nfunction isEncodingProperty(prop) {\n    return isEncodingTopLevelProperty(prop) || isEncodingNestedProp(prop);\n}\nexports.isEncodingProperty = isEncodingProperty;\nexports.ALL_ENCODING_PROPS = [].concat(exports.ENCODING_TOPLEVEL_PROPS, exports.ENCODING_NESTED_PROPS);\nexports.DEFAULT_PROP_PRECEDENCE = [\n    'type',\n    'field',\n    // Field Transform\n    'bin', 'timeUnit', 'aggregate', 'autoCount',\n    // Encoding\n    'channel',\n    // Mark\n    'mark',\n    'scale', 'sort',\n    'axis', 'legend'\n].concat(BIN_PROPS, exports.SCALE_PROPS, AXIS_PROPS, LEGEND_PROPS, exports.SORT_PROPS);\nvar Property;\n(function (Property) {\n    Property.MARK = 'mark';\n    Property.FILTER = 'filter';\n    // TODO: Sub-properties for filter\n    Property.CALCULATE = 'calculate';\n    // TODO: Sub-properties for calculate\n    Property.FILTERINVALID = 'filterInvalid';\n    // Layout\n    Property.STACK = 'stack';\n    // TODO: sub parts of stack\n    // Encoding Properties\n    Property.CHANNEL = 'channel';\n    Property.AGGREGATE = 'aggregate';\n    Property.AUTOCOUNT = 'autoCount';\n    Property.BIN = 'bin';\n    Property.HAS_FN = 'hasFn';\n    Property.TIMEUNIT = 'timeUnit';\n    Property.FIELD = 'field';\n    Property.TYPE = 'type';\n    Property.SORT = 'sort';\n    Property.SCALE = 'scale';\n    Property.AXIS = 'axis';\n    Property.LEGEND = 'legend';\n})(Property = exports.Property || (exports.Property = {}));\n//# sourceMappingURL=property.js.map",
    "\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar util_1 = require(\"./util\");\nvar property_1 = require(\"./property\");\n/**\n * Dictionary that takes property as a key.\n */\nvar PropIndex = (function () {\n    function PropIndex(i) {\n        if (i === void 0) { i = null; }\n        this.index = i ? __assign({}, i) : {};\n    }\n    PropIndex.prototype.has = function (p) {\n        return property_1.toKey(p) in this.index;\n    };\n    PropIndex.prototype.get = function (p) {\n        return this.index[property_1.toKey(p)];\n    };\n    PropIndex.prototype.set = function (p, value) {\n        this.index[property_1.toKey(p)] = value;\n        return this;\n    };\n    PropIndex.prototype.setByKey = function (key, value) {\n        this.index[key] = value;\n    };\n    PropIndex.prototype.map = function (f) {\n        var i = new PropIndex();\n        for (var k in this.index) {\n            i.index[k] = f(this.index[k]);\n        }\n        return i;\n    };\n    PropIndex.prototype.size = function () {\n        return util_1.keys(this.index).length;\n    };\n    PropIndex.prototype.duplicate = function () {\n        return new PropIndex(this.index);\n    };\n    return PropIndex;\n}());\nexports.PropIndex = PropIndex;\n//# sourceMappingURL=propindex.js.map",
    "\"use strict\";\nvar vlFieldDef = require(\"vega-lite/build/src/fielddef\");\nvar type_1 = require(\"vega-lite/build/src/compile/scale/type\");\nvar wildcard_1 = require(\"../wildcard\");\nfunction isValueQuery(encQ) {\n    return encQ !== null && encQ !== undefined && encQ['value'];\n}\nexports.isValueQuery = isValueQuery;\nfunction isFieldQuery(encQ) {\n    return encQ !== null && encQ !== undefined && (encQ['field'] || 'autoCount' in encQ);\n}\nexports.isFieldQuery = isFieldQuery;\nfunction toFieldDef(fieldQ, props) {\n    if (props === void 0) { props = ['aggregate', 'autoCount', 'bin', 'timeUnit', 'field', 'type']; }\n    return props.reduce(function (fieldDef, prop) {\n        if (wildcard_1.isWildcard(fieldQ[prop])) {\n            throw new Error(\"Cannot convert \" + JSON.stringify(fieldQ) + \" to fielddef: \" + prop + \" is wildcard\");\n        }\n        else if (fieldQ[prop] !== undefined) {\n            if (prop === 'autoCount') {\n                if (fieldQ[prop]) {\n                    fieldDef.aggregate = 'count';\n                }\n                else {\n                    throw new Error(\"Cannot convert {autoCount: false} into a field def\");\n                }\n            }\n            else {\n                fieldDef[prop] = fieldQ[prop];\n            }\n        }\n        return fieldDef;\n    }, {});\n}\nexports.toFieldDef = toFieldDef;\n/**\n * Is a field query continuous field?\n * This method is applicable only for fieldQuery without wildcard\n */\nfunction isContinuous(fieldQ) {\n    return vlFieldDef.isContinuous(toFieldDef(fieldQ, ['bin', 'timeUnit', 'field', 'type']));\n}\nexports.isContinuous = isContinuous;\n/**\n * Is a field query discrete field?\n * This method is applicable only for fieldQuery without wildcard\n */\nfunction isDiscrete(fieldQ) {\n    return vlFieldDef.isDiscrete(toFieldDef(fieldQ, ['bin', 'timeUnit', 'field', 'type']));\n}\nexports.isDiscrete = isDiscrete;\n/**\n *  Returns the true scale type of an encoding.\n *  @returns {ScaleType} If the scale type was not specified, it is inferred from the encoding's Type.\n *  @returns {undefined} If the scale type was not specified and Type (or TimeUnit if applicable) is a Wildcard, there is no clear scale type\n */\nfunction scaleType(fieldQ) {\n    var scale = fieldQ.scale === true || fieldQ.scale === wildcard_1.SHORT_WILDCARD ? {} : fieldQ.scale || {};\n    var type = fieldQ.type, channel = fieldQ.channel, timeUnit = fieldQ.timeUnit, bin = fieldQ.bin;\n    // HACK: All of markType, hasTopLevelSize, and scaleConfig only affect\n    // sub-type of ordinal to quantitative scales (point or band)\n    // Currently, most of scaleType usage in CompassQL doesn't care about this subtle difference.\n    // Thus, instead of making this method requiring the global mark and topLevelSize,\n    // we will just call it with mark = undefined and hasTopLevelSize = false.\n    // Thus, currently, we will always get a point scale unless a CompassQuery specifies band.\n    var markType = undefined;\n    var hasTopLevelSize = false;\n    var scaleConfig = {};\n    if (wildcard_1.isWildcard(scale.type) || wildcard_1.isWildcard(type) || wildcard_1.isWildcard(channel) || wildcard_1.isWildcard(bin)) {\n        return undefined;\n    }\n    var rangeStep = undefined;\n    // Note: Range step currently does not matter as we don't pass mark into compileScaleType anyway.\n    // However, if we pass mark, we could use a rule like the following.\n    // I also have few test cases listed in encoding.test.ts\n    // if (channel === 'x' || channel === 'y') {\n    //   if (isWildcard(scale.rangeStep)) {\n    //     if (isShortWildcard(scale.rangeStep)) {\n    //       return undefined;\n    //     } else if (scale.rangeStep.enum) {\n    //       const e = scale.rangeStep.enum;\n    //       // if enumerated value contains enum then we can't be sure\n    //       if (contains(e, undefined) || contains(e, null)) {\n    //         return undefined;\n    //       }\n    //       rangeStep = e[0];\n    //     }\n    //   }\n    // }\n    // if type is fixed and it's not temporal, we can ignore time unit.\n    if (type === 'temporal' && wildcard_1.isWildcard(timeUnit)) {\n        return undefined;\n    }\n    // if type is fixed and it's not quantitative, we can ignore bin\n    if (type === 'quantitative' && wildcard_1.isWildcard(bin)) {\n        return undefined;\n    }\n    return type_1.default(scale.type, channel, { type: type, timeUnit: timeUnit, bin: bin }, markType, hasTopLevelSize, rangeStep, scaleConfig);\n}\nexports.scaleType = scaleType;\n//# sourceMappingURL=encoding.js.map",
    "\"use strict\";\nvar util_1 = require(\"datalib/src/util\");\nvar shorthand_1 = require(\"./shorthand\");\nvar property_1 = require(\"../property\");\nvar propindex_1 = require(\"../propindex\");\nvar util_2 = require(\"../util\");\nexports.REPLACE_BLANK_FIELDS = { '*': '' };\nexports.REPLACE_XY_CHANNELS = { x: 'xy', y: 'xy' };\nexports.REPLACE_FACET_CHANNELS = { row: 'facet', column: 'facet' };\nexports.REPLACE_MARK_STYLE_CHANNELS = { color: 'style', opacity: 'style', shape: 'style', size: 'style' };\nfunction isExtendedGroupBy(g) {\n    return util_1.isObject(g) && !!g['property'];\n}\nexports.isExtendedGroupBy = isExtendedGroupBy;\nfunction parseGroupBy(groupBy, include, replaceIndex) {\n    include = include || new propindex_1.PropIndex();\n    replaceIndex = replaceIndex || new propindex_1.PropIndex();\n    groupBy.forEach(function (grpBy) {\n        if (isExtendedGroupBy(grpBy)) {\n            include.setByKey(grpBy.property, true);\n            replaceIndex.setByKey(grpBy.property, grpBy.replace);\n        }\n        else {\n            include.setByKey(grpBy, true);\n        }\n    });\n    return {\n        include: include,\n        replaceIndex: replaceIndex,\n        replacer: shorthand_1.getReplacerIndex(replaceIndex)\n    };\n}\nexports.parseGroupBy = parseGroupBy;\nfunction toString(groupBy) {\n    if (util_1.isArray(groupBy)) {\n        return groupBy.map(function (g) {\n            if (isExtendedGroupBy(g)) {\n                if (g.replace) {\n                    var replaceIndex_1 = util_2.keys(g.replace).reduce(function (index, valFrom) {\n                        var valTo = g.replace[valFrom];\n                        (index[valTo] = index[valTo] || []).push(valFrom);\n                        return index;\n                    }, {});\n                    return g.property + '[' + util_2.keys(replaceIndex_1).map(function (valTo) {\n                        var valsFrom = replaceIndex_1[valTo].sort();\n                        return valsFrom.join(',') + '=>' + valTo;\n                    }).join(';') + ']';\n                }\n                return g.property;\n            }\n            return g;\n        }).join(',');\n    }\n    else {\n        return groupBy;\n    }\n}\nexports.toString = toString;\nexports.GROUP_BY_FIELD_TRANSFORM = [\n    property_1.Property.FIELD, property_1.Property.TYPE,\n    property_1.Property.AGGREGATE, property_1.Property.BIN, property_1.Property.TIMEUNIT, property_1.Property.STACK\n];\nexports.GROUP_BY_ENCODING = exports.GROUP_BY_FIELD_TRANSFORM.concat([\n    {\n        property: property_1.Property.CHANNEL,\n        replace: {\n            'x': 'xy', 'y': 'xy',\n            'color': 'style', 'size': 'style', 'shape': 'style', 'opacity': 'style',\n            'row': 'facet', 'column': 'facet'\n        }\n    }\n]);\n//# sourceMappingURL=groupby.js.map",
    "\"use strict\";\nexports.encoding = require(\"./encoding\");\nvar normalize_1 = require(\"./normalize\");\nexports.normalize = normalize_1.normalize;\nexports.groupBy = require(\"./groupby\");\nexports.shorthand = require(\"./shorthand\");\nexports.spec = require(\"./spec\");\nexports.transform = require(\"./transform\");\n//# sourceMappingURL=index.js.map",
    "\"use strict\";\nvar util_1 = require(\"../util\");\n/**\n * Normalize the non-nested version of the query to a standardize nested\n */\nfunction normalize(q) {\n    if (q.groupBy) {\n        var nest = {\n            groupBy: q.groupBy\n        };\n        if (q.orderBy) {\n            nest.orderGroupBy = q.orderBy;\n        }\n        var normalizedQ = {\n            spec: util_1.duplicate(q.spec),\n            nest: [nest],\n        };\n        if (q.chooseBy) {\n            normalizedQ.chooseBy = q.chooseBy;\n        }\n        if (q.config) {\n            normalizedQ.config = q.config;\n        }\n        return normalizedQ;\n    }\n    return util_1.duplicate(q); // We will cause side effect to q.spec in SpecQueryModel.build\n}\nexports.normalize = normalize;\n//# sourceMappingURL=normalize.js.map",
    "\"use strict\";\nvar aggregate_1 = require(\"vega-lite/build/src/aggregate\");\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar timeunit_1 = require(\"vega-lite/build/src/timeunit\");\nvar type_1 = require(\"vega-lite/build/src/type\");\nvar util_1 = require(\"datalib/src/util\");\nvar encoding_1 = require(\"./encoding\");\nvar spec_1 = require(\"./spec\");\nvar wildcard_1 = require(\"../wildcard\");\nvar property_1 = require(\"../property\");\nvar propindex_1 = require(\"../propindex\");\nvar util_2 = require(\"../util\");\nfunction getReplacerIndex(replaceIndex) {\n    return replaceIndex.map(function (r) { return getReplacer(r); });\n}\nexports.getReplacerIndex = getReplacerIndex;\nfunction getReplacer(replace) {\n    return function (s) {\n        if (replace[s] !== undefined) {\n            return replace[s];\n        }\n        return s;\n    };\n}\nexports.getReplacer = getReplacer;\nfunction value(v, replacer) {\n    if (wildcard_1.isWildcard(v)) {\n        // Return the enum array if it's a full wildcard, or just return SHORT_WILDCARD for short ones.\n        if (!wildcard_1.isShortWildcard(v) && v.enum) {\n            return wildcard_1.SHORT_WILDCARD + JSON.stringify(v.enum);\n        }\n        else {\n            return wildcard_1.SHORT_WILDCARD;\n        }\n    }\n    if (replacer) {\n        return replacer(v);\n    }\n    return v;\n}\nexports.value = value;\nfunction replace(v, replacer) {\n    if (replacer) {\n        return replacer(v);\n    }\n    return v;\n}\nexports.replace = replace;\nexports.REPLACE_NONE = new propindex_1.PropIndex();\nexports.INCLUDE_ALL = \n// FIXME: remove manual STACK, FILTER, CALCULATE concat once we really support enumerating it.\nproperty_1.DEFAULT_PROP_PRECEDENCE\n    .concat(property_1.SORT_PROPS, [property_1.Property.CALCULATE, property_1.Property.FILTER, property_1.Property.FILTERINVALID, property_1.Property.STACK])\n    .reduce(function (pi, prop) { return pi.set(prop, true); }, new propindex_1.PropIndex());\nfunction vlSpec(vlspec, include, replace) {\n    if (include === void 0) { include = exports.INCLUDE_ALL; }\n    if (replace === void 0) { replace = exports.REPLACE_NONE; }\n    var specQ = spec_1.fromSpec(vlspec);\n    return spec(specQ, include, replace);\n}\nexports.vlSpec = vlSpec;\nexports.PROPERTY_SUPPORTED_CHANNELS = {\n    axis: { x: true, y: true, row: true, column: true },\n    legend: { color: true, opacity: true, size: true, shape: true },\n    scale: { x: true, y: true, color: true, opacity: true, row: true, column: true, size: true, shape: true },\n    sort: { x: true, y: true, path: true, order: true }\n};\n/**\n * Returns a shorthand for a spec query\n * @param specQ a spec query\n * @param include Dict Set listing property types (key) to be included in the shorthand\n * @param replace Dictionary of replace function for values of a particular property type (key)\n */\nfunction spec(specQ, include, replace) {\n    if (include === void 0) { include = exports.INCLUDE_ALL; }\n    if (replace === void 0) { replace = exports.REPLACE_NONE; }\n    var parts = [];\n    if (include.get(property_1.Property.MARK)) {\n        parts.push(value(specQ.mark, replace.get(property_1.Property.MARK)));\n    }\n    if (specQ.transform) {\n        if (include.get(property_1.Property.CALCULATE)) {\n            if (specQ.transform.calculate !== undefined) {\n                parts.push('calculate:' + calculate(specQ.transform.calculate));\n            }\n        }\n        if (include.get(property_1.Property.FILTER)) {\n            if (specQ.transform.filter !== undefined) {\n                parts.push('filter:' + JSON.stringify(specQ.transform.filter));\n            }\n        }\n        if (include.get(property_1.Property.FILTERINVALID)) {\n            if (specQ.transform.filterInvalid !== undefined) {\n                parts.push('filterInvalid:' + specQ.transform.filterInvalid);\n            }\n        }\n    }\n    // TODO: extract this to its own stack method\n    if (include.get(property_1.Property.STACK)) {\n        var _stack = spec_1.stack(specQ);\n        if (_stack) {\n            // TODO: Refactor this once we have child stack property.\n            // Exclude type since we don't care about type in stack\n            var includeExceptType = include.duplicate().set('type', false);\n            var field = fieldDef(_stack.fieldEncQ, includeExceptType, replace);\n            var groupby = fieldDef(_stack.groupByEncQ, includeExceptType, replace);\n            parts.push('stack={field:' + field + ',' +\n                (groupby ? 'by:' + groupby + ',' : '') +\n                'offset:' + _stack.offset + '}');\n        }\n    }\n    if (specQ.encodings) {\n        var encodings = specQ.encodings.reduce(function (encQs, encQ) {\n            // Exclude encoding mapping with autoCount=false as they are basically disabled.\n            if (encoding_1.isFieldQuery(encQ) && encQ.autoCount !== false) {\n                var str = encoding(encQ, include, replace);\n                if (str) {\n                    encQs.push(str);\n                }\n            }\n            return encQs;\n        }, [])\n            .sort() // sort at the end to ignore order\n            .join('|');\n        if (encodings) {\n            parts.push(encodings);\n        }\n    }\n    return parts.join('|');\n}\nexports.spec = spec;\nfunction calculate(formulaArr) {\n    return JSON.stringify(formulaArr.reduce(function (m, calculateItem) {\n        m[calculateItem.as] = calculateItem.expr;\n        return m;\n    }, {}));\n}\nexports.calculate = calculate;\n/**\n * Returns a shorthand for an encoding query\n * @param encQ an encoding query\n * @param include Dict Set listing property types (key) to be included in the shorthand\n * @param replace Dictionary of replace function for values of a particular property type (key)\n */\nfunction encoding(encQ, include, replace) {\n    if (include === void 0) { include = exports.INCLUDE_ALL; }\n    if (replace === void 0) { replace = exports.REPLACE_NONE; }\n    var parts = [];\n    if (include.get(property_1.Property.CHANNEL)) {\n        parts.push(value(encQ.channel, replace.get(property_1.Property.CHANNEL)));\n    }\n    if (encoding_1.isFieldQuery(encQ)) {\n        var fieldDefStr = fieldDef(encQ, include, replace);\n        if (fieldDefStr) {\n            parts.push(fieldDefStr);\n        }\n    }\n    else if (encoding_1.isValueQuery(encQ)) {\n        parts.push(encQ.value);\n    }\n    return parts.join(':');\n}\nexports.encoding = encoding;\n/**\n * Returns a field definition shorthand for an encoding query\n * @param encQ an encoding query\n * @param include Dict Set listing property types (key) to be included in the shorthand\n * @param replace Dictionary of replace function for values of a particular property type (key)\n */\nfunction fieldDef(fieldQ, include, replacer) {\n    if (include === void 0) { include = exports.INCLUDE_ALL; }\n    if (replacer === void 0) { replacer = exports.REPLACE_NONE; }\n    if (include.get(property_1.Property.AGGREGATE) && fieldQ.autoCount === false) {\n        return '-';\n    }\n    var fn = func(fieldQ, include, replacer);\n    var props = fieldDefProps(fieldQ, include, replacer);\n    // field\n    var fieldAndParams = include.get('field') ? value(fieldQ.field || '*', replacer.get('field')) : '...';\n    // type\n    if (include.get(property_1.Property.TYPE)) {\n        if (wildcard_1.isWildcard(fieldQ.type)) {\n            fieldAndParams += ',' + value(fieldQ.type, replacer.get(property_1.Property.TYPE));\n        }\n        else {\n            var typeShort = ((fieldQ.type || type_1.Type.QUANTITATIVE) + '').substr(0, 1);\n            fieldAndParams += ',' + value(typeShort, replacer.get(property_1.Property.TYPE));\n        }\n    }\n    // encoding properties\n    fieldAndParams += props.map(function (p) {\n        var val = p.value instanceof Array ? '[' + p.value + ']' : p.value;\n        return ',' + p.key + '=' + val;\n    }).join('');\n    if (fn) {\n        var fnPrefix = util_1.isString(fn) ? fn : wildcard_1.SHORT_WILDCARD +\n            (util_2.keys(fn).length > 0 ? JSON.stringify(fn) : '');\n        return fnPrefix + '(' + fieldAndParams + ')';\n    }\n    return fieldAndParams;\n}\nexports.fieldDef = fieldDef;\n/**\n * Return function part of\n */\nfunction func(fieldQ, include, replacer) {\n    if (include.get(property_1.Property.AGGREGATE) && fieldQ.aggregate && !wildcard_1.isWildcard(fieldQ.aggregate)) {\n        return replace(fieldQ.aggregate, replacer.get(property_1.Property.AGGREGATE));\n    }\n    else if (include.get(property_1.Property.AGGREGATE) && fieldQ.autoCount && !wildcard_1.isWildcard(fieldQ.autoCount)) {\n        // autoCount is considered a part of aggregate\n        return replace('count', replacer.get(property_1.Property.AGGREGATE));\n        ;\n    }\n    else if (include.get(property_1.Property.TIMEUNIT) && fieldQ.timeUnit && !wildcard_1.isWildcard(fieldQ.timeUnit)) {\n        return replace(fieldQ.timeUnit, replacer.get(property_1.Property.TIMEUNIT));\n    }\n    else if (include.get(property_1.Property.BIN) && fieldQ.bin && !wildcard_1.isWildcard(fieldQ.bin)) {\n        return 'bin';\n    }\n    else {\n        var fn = null;\n        for (var _i = 0, _a = [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.TIMEUNIT, property_1.Property.BIN]; _i < _a.length; _i++) {\n            var prop = _a[_i];\n            var val = fieldQ[prop];\n            if (include.get(prop) && fieldQ[prop] && wildcard_1.isWildcard(val)) {\n                // assign fnEnumIndex[prop] = array of enum values or just \"?\" if it is SHORT_WILDCARD\n                fn = fn || {};\n                fn[prop] = wildcard_1.isShortWildcard(val) ? val : val.enum;\n            }\n        }\n        if (fn && fieldQ.hasFn) {\n            fn.hasFn = true;\n        }\n        return fn;\n    }\n}\n/**\n * Return key-value of parameters of field defs\n */\nfunction fieldDefProps(fieldQ, include, replacer) {\n    /** Encoding properties e.g., Scale, Axis, Legend */\n    var props = [];\n    // Parameters of function such as bin will be just top-level properties\n    if (!util_2.isBoolean(fieldQ.bin) && !wildcard_1.isShortWildcard(fieldQ.bin)) {\n        var bin = fieldQ.bin;\n        for (var child in bin) {\n            var prop = property_1.getEncodingNestedProp('bin', child);\n            if (prop && include.get(prop) && bin[child] !== undefined) {\n                props.push({\n                    key: child,\n                    value: value(bin[child], replacer.get(prop))\n                });\n            }\n        }\n        // Sort to make sure that parameter are ordered consistently\n        props.sort(function (a, b) { return a.key.localeCompare(b.key); });\n    }\n    for (var _i = 0, _a = [property_1.Property.SCALE, property_1.Property.SORT, property_1.Property.AXIS, property_1.Property.LEGEND]; _i < _a.length; _i++) {\n        var parent_1 = _a[_i];\n        if (!wildcard_1.isWildcard(fieldQ.channel) && !exports.PROPERTY_SUPPORTED_CHANNELS[parent_1][fieldQ.channel]) {\n            continue;\n        }\n        if (include.get(parent_1) && fieldQ[parent_1] !== undefined) {\n            var parentValue = fieldQ[parent_1];\n            if (util_2.isBoolean(parentValue) || parentValue === null) {\n                // `scale`, `axis`, `legend` can be false/null.\n                props.push({\n                    key: parent_1 + '',\n                    value: parentValue || false // return true or false (false if null)\n                });\n            }\n            else if (util_1.isString(parentValue)) {\n                // `sort` can be a string (ascending/descending).\n                props.push({\n                    key: parent_1 + '',\n                    value: replace(JSON.stringify(parentValue), replacer.get(parent_1))\n                });\n            }\n            else {\n                var nestedPropChildren = [];\n                for (var child in parentValue) {\n                    var nestedProp = property_1.getEncodingNestedProp(parent_1, child);\n                    if (nestedProp && include.get(nestedProp) && parentValue[child] !== undefined) {\n                        nestedPropChildren.push({\n                            key: child,\n                            value: value(parentValue[child], replacer.get(nestedProp))\n                        });\n                    }\n                }\n                if (nestedPropChildren.length > 0) {\n                    var nestedPropObject = nestedPropChildren.sort(function (a, b) { return a.key.localeCompare(b.key); })\n                        .reduce(function (o, item) {\n                        o[item.key] = item.value;\n                        return o;\n                    }, {});\n                    // Sort to make sure that parameter are ordered consistently\n                    props.push({\n                        key: parent_1 + '',\n                        value: JSON.stringify(nestedPropObject)\n                    });\n                }\n            }\n        }\n    }\n    return props;\n}\nvar CHANNEL_INDEX = util_1.toMap(channel_1.CHANNELS);\nvar AGGREGATE_OP_INDEX = util_1.toMap(aggregate_1.AGGREGATE_OPS);\nvar SINGLE_TIMEUNIT_INDEX = util_1.toMap(timeunit_1.SINGLE_TIMEUNITS);\nvar MULTI_TIMEUNIT_INDEX = util_1.toMap(timeunit_1.MULTI_TIMEUNITS);\nfunction parse(shorthand) {\n    // TODO(https://github.com/uwdata/compassql/issues/259):\n    // Do not split directly, but use an upgraded version of `getClosingBraceIndex()`\n    var splitShorthand = shorthand.split('|');\n    var specQ = { mark: splitShorthand[0], encodings: [] };\n    for (var i = 1; i < splitShorthand.length; i++) {\n        var part = splitShorthand[i];\n        var splitPart = splitWithTail(part, ':', 1);\n        var splitPartKey = splitPart[0];\n        var splitPartValue = splitPart[1];\n        if (CHANNEL_INDEX[splitPartKey] || splitPartKey === '?') {\n            var encQ = shorthandParser.encoding(splitPartKey, splitPartValue);\n            specQ.encodings.push(encQ);\n            continue;\n        }\n        if (splitPartKey === 'calculate') {\n            specQ.transform = specQ.transform || {};\n            var calculate_1 = [];\n            var fieldExprMapping = JSON.parse(splitPartValue);\n            for (var field in fieldExprMapping) {\n                calculate_1.push({ expr: fieldExprMapping[field], as: field });\n            }\n            specQ.transform.calculate = calculate_1;\n            continue;\n        }\n        if (splitPartKey === 'filter') {\n            specQ.transform = specQ.transform || {};\n            specQ.transform.filter = JSON.parse(splitPartValue);\n            continue;\n        }\n        if (splitPartKey === 'filterInvalid') {\n            specQ.transform = specQ.transform || {};\n            specQ.transform.filterInvalid = JSON.parse(splitPartValue);\n            continue;\n        }\n    }\n    return specQ;\n}\nexports.parse = parse;\n/**\n * Split a string n times into substrings with the specified delimiter and return them as an array.\n * @param str The string to be split\n * @param delim The delimiter string used to separate the string\n * @param number The value used to determine how many times the string is split\n */\nfunction splitWithTail(str, delim, count) {\n    var result = [];\n    var lastIndex = 0;\n    for (var i = 0; i < count; i++) {\n        var indexOfDelim = str.indexOf(delim, lastIndex);\n        if (indexOfDelim !== -1) {\n            result.push(str.substring(lastIndex, indexOfDelim));\n            lastIndex = indexOfDelim + 1;\n        }\n        else {\n            break;\n        }\n    }\n    result.push(str.substr(lastIndex));\n    // If the specified count is greater than the number of delimiters that exist in the string,\n    // an empty string will be pushed count minus number of delimiter occurence times.\n    if (result.length !== count + 1) {\n        while (result.length !== count + 1) {\n            result.push('');\n        }\n    }\n    return result;\n}\nexports.splitWithTail = splitWithTail;\nvar shorthandParser;\n(function (shorthandParser) {\n    function encoding(channel, fieldDefShorthand) {\n        var encQ = { channel: channel };\n        if (fieldDefShorthand.indexOf('(') !== -1) {\n            encQ = fn(encQ, fieldDefShorthand);\n        }\n        else {\n            encQ = rawFieldDef(encQ, splitWithTail(fieldDefShorthand, ',', 2));\n        }\n        return encQ;\n    }\n    shorthandParser.encoding = encoding;\n    function rawFieldDef(fieldQ, fieldDefPart) {\n        fieldQ.field = fieldDefPart[0];\n        fieldQ.type = type_1.getFullName(fieldDefPart[1].toUpperCase()) || '?';\n        var partParams = fieldDefPart[2];\n        var closingBraceIndex = 0;\n        var i = 0;\n        while (i < partParams.length) {\n            var propEqualSignIndex = partParams.indexOf('=', i);\n            var parsedValue = void 0;\n            if (propEqualSignIndex !== -1) {\n                var prop = partParams.substring(i, propEqualSignIndex);\n                if (partParams[i + prop.length + 1] === '{') {\n                    var openingBraceIndex = i + prop.length + 1;\n                    closingBraceIndex = getClosingIndex(openingBraceIndex, partParams, '}');\n                    var value_1 = partParams.substring(openingBraceIndex, closingBraceIndex + 1);\n                    parsedValue = JSON.parse(value_1);\n                    // index after next comma\n                    i = closingBraceIndex + 2;\n                }\n                else if (partParams[i + prop.length + 1] === '[') {\n                    // find closing square bracket\n                    var openingBracketIndex = i + prop.length + 1;\n                    var closingBracketIndex = getClosingIndex(openingBracketIndex, partParams, ']');\n                    var value_2 = partParams.substring(openingBracketIndex, closingBracketIndex + 1);\n                    parsedValue = JSON.parse(value_2);\n                    // index after next comma\n                    i = closingBracketIndex + 2;\n                }\n                else {\n                    var propIndex = i;\n                    // Substring until the next comma (or end of the string)\n                    var nextCommaIndex = partParams.indexOf(',', i + prop.length);\n                    if (nextCommaIndex === -1) {\n                        nextCommaIndex = partParams.length;\n                    }\n                    // index after next comma\n                    i = nextCommaIndex + 1;\n                    parsedValue = JSON.parse(partParams.substring(propIndex + prop.length + 1, nextCommaIndex));\n                }\n                if (property_1.hasNestedProperty(prop)) {\n                    fieldQ[prop] = parsedValue;\n                }\n                else {\n                    // prop is a property of the aggregation function such as bin\n                    fieldQ.bin[prop] = parsedValue;\n                }\n            }\n            else {\n                // something is wrong with the format of the partParams\n                // exits loop if don't have then infintie loop\n                break;\n            }\n        }\n        return fieldQ;\n    }\n    shorthandParser.rawFieldDef = rawFieldDef;\n    function getClosingIndex(openingBraceIndex, str, closingChar) {\n        for (var i = openingBraceIndex; i < str.length; i++) {\n            if (str[i] === closingChar) {\n                return i;\n            }\n        }\n    }\n    shorthandParser.getClosingIndex = getClosingIndex;\n    function fn(fieldQ, fieldDefShorthand) {\n        // Aggregate, Bin, TimeUnit as wildcard case\n        if (fieldDefShorthand[0] === '?') {\n            var closingBraceIndex = getClosingIndex(1, fieldDefShorthand, '}');\n            var fnEnumIndex = JSON.parse(fieldDefShorthand.substring(1, closingBraceIndex + 1));\n            for (var encodingProperty in fnEnumIndex) {\n                if (util_2.isArray(fnEnumIndex[encodingProperty])) {\n                    fieldQ[encodingProperty] = { enum: fnEnumIndex[encodingProperty] };\n                }\n                else {\n                    fieldQ[encodingProperty] = fnEnumIndex[encodingProperty];\n                }\n            }\n            return rawFieldDef(fieldQ, splitWithTail(fieldDefShorthand.substring(closingBraceIndex + 2, fieldDefShorthand.length - 1), ',', 2));\n        }\n        else {\n            var func_1 = fieldDefShorthand.substring(0, fieldDefShorthand.indexOf('('));\n            var insideFn = fieldDefShorthand.substring(func_1.length + 1, fieldDefShorthand.length - 1);\n            var insideFnParts = splitWithTail(insideFn, ',', 2);\n            if (AGGREGATE_OP_INDEX[func_1]) {\n                fieldQ.aggregate = func_1;\n                return rawFieldDef(fieldQ, insideFnParts);\n            }\n            else if (MULTI_TIMEUNIT_INDEX[func_1] || SINGLE_TIMEUNIT_INDEX[func_1]) {\n                fieldQ.timeUnit = func_1;\n                return rawFieldDef(fieldQ, insideFnParts);\n            }\n            else if (func_1 === 'bin') {\n                fieldQ.bin = {};\n                return rawFieldDef(fieldQ, insideFnParts);\n            }\n        }\n    }\n    shorthandParser.fn = fn;\n})(shorthandParser = exports.shorthandParser || (exports.shorthandParser = {}));\n//# sourceMappingURL=shorthand.js.map",
    "\"use strict\";\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar wildcard_1 = require(\"../wildcard\");\nvar property_1 = require(\"../property\");\nvar util_1 = require(\"../util\");\nvar encoding_1 = require(\"./encoding\");\n/**\n * Convert a Vega-Lite's ExtendedUnitSpec into a CompassQL's SpecQuery\n * @param {ExtendedUnitSpec} spec\n * @returns\n */\nfunction fromSpec(spec) {\n    return util_1.extend(spec.data ? { data: spec.data } : {}, spec.transform ? { transform: spec.transform } : {}, {\n        mark: spec.mark,\n        encodings: util_1.keys(spec.encoding).map(function (channel) {\n            var encQ = { channel: channel };\n            var channelDef = spec.encoding[channel];\n            for (var prop in channelDef) {\n                if (property_1.isEncodingTopLevelProperty(prop) && channelDef[prop] !== undefined) {\n                    // Currently bin, scale, axis, legend only support boolean, but not null.\n                    // Therefore convert null to false.\n                    if (util_1.contains(['bin', 'scale', 'axis', 'legend'], prop) && channelDef[prop] === null) {\n                        encQ[prop] = false;\n                    }\n                    else {\n                        encQ[prop] = channelDef[prop];\n                    }\n                }\n            }\n            return encQ;\n        })\n    }, spec.config ? { config: spec.config } : {});\n}\nexports.fromSpec = fromSpec;\nfunction isAggregate(specQ) {\n    return util_1.some(specQ.encodings, function (encQ) {\n        return encoding_1.isFieldQuery(encQ) && ((!wildcard_1.isWildcard(encQ.aggregate) && !!encQ.aggregate) || encQ.autoCount === true);\n    });\n}\nexports.isAggregate = isAggregate;\n/**\n * @return the stack offset type for the specQuery\n */\nfunction stack(specQ) {\n    var config = specQ.config;\n    var stacked = config ? config.stack : undefined;\n    // Should not have stack explicitly disabled\n    if (util_1.contains(['none', null, false], stacked)) {\n        return null;\n    }\n    // Should have stackable mark\n    if (!util_1.contains(['bar', 'area'], specQ.mark)) {\n        return null;\n    }\n    // Should be aggregate plot\n    if (!isAggregate(specQ)) {\n        return null;\n    }\n    var stackBy = specQ.encodings.reduce(function (sc, encQ) {\n        if (util_1.contains(channel_1.STACK_GROUP_CHANNELS, encQ.channel) && (encoding_1.isValueQuery(encQ) || !encQ.aggregate)) {\n            sc.push({\n                channel: encQ.channel,\n                fieldDef: encQ\n            });\n        }\n        return sc;\n    }, []);\n    if (stackBy.length === 0) {\n        return null;\n    }\n    // Has only one aggregate axis\n    var xEncQ = specQ.encodings.reduce(function (f, encQ) {\n        return f || (encQ.channel === channel_1.Channel.X ? encQ : null);\n    }, null);\n    var yEncQ = specQ.encodings.reduce(function (f, encQ) {\n        return f || (encQ.channel === channel_1.Channel.Y ? encQ : null);\n    }, null);\n    var xIsAggregate = encoding_1.isFieldQuery(xEncQ) && (!!xEncQ.aggregate || !!xEncQ.autoCount);\n    var yIsAggregate = encoding_1.isFieldQuery(yEncQ) && (!!yEncQ.aggregate || !!yEncQ.autoCount);\n    if (xIsAggregate !== yIsAggregate) {\n        return {\n            groupbyChannel: xIsAggregate ? (!!yEncQ ? channel_1.Y : null) : (!!xEncQ ? channel_1.X : null),\n            groupByEncQ: xIsAggregate ? yEncQ : xEncQ,\n            fieldChannel: xIsAggregate ? channel_1.X : channel_1.Y,\n            fieldEncQ: xIsAggregate ? xEncQ : yEncQ,\n            stackBy: stackBy,\n            offset: stacked || 'zero'\n        };\n    }\n    return null;\n}\nexports.stack = stack;\n//# sourceMappingURL=spec.js.map",
    "\"use strict\";\n//# sourceMappingURL=transform.js.map",
    "\"use strict\";\nvar type_1 = require(\"vega-lite/build/src/type\");\nvar util_1 = require(\"../util\");\nvar encoding_1 = require(\"../query/encoding\");\nexports.name = 'aggregationQuality';\nfunction score(specM, schema, opt) {\n    var feature = aggregationQualityFeature(specM, schema, opt);\n    return {\n        score: feature.score,\n        features: [feature]\n    };\n}\nexports.score = score;\nfunction isDimension(encQ) {\n    return encoding_1.isDiscrete(encQ) || !!encQ.timeUnit;\n}\nfunction aggregationQualityFeature(specM, _, __) {\n    var encodings = specM.getEncodings();\n    if (specM.isAggregate()) {\n        var isRawContinuous = function (encQ) {\n            return encoding_1.isFieldQuery(encQ) && ((encQ.type === type_1.Type.QUANTITATIVE && !encQ.bin && !encQ.aggregate && !encQ.autoCount) ||\n                (encQ.type === type_1.Type.TEMPORAL && !encQ.timeUnit));\n        };\n        if (util_1.some(encodings, isRawContinuous)) {\n            // These are plots that pollute continuous fields as dimension.\n            // They are often intermediate visualizations rather than what users actually want.\n            return {\n                type: exports.name,\n                score: 0.1,\n                feature: 'Aggregate with raw continuous'\n            };\n        }\n        if (util_1.some(encodings, function (encQ) { return encoding_1.isFieldQuery(encQ) && isDimension(encQ); })) {\n            var hasCount = util_1.some(encodings, function (encQ) {\n                return encoding_1.isFieldQuery(encQ) && (encQ.aggregate === 'count' || encQ.autoCount === true);\n            });\n            var hasBin = util_1.some(encodings, function (encQ) {\n                return encoding_1.isFieldQuery(encQ) && !!encQ.bin;\n            });\n            if (hasCount) {\n                // If there is count, we might add additional count field, making it a little less simple\n                // then when we just apply aggregate to Q field\n                return {\n                    type: exports.name,\n                    score: 0.8,\n                    feature: 'Aggregate with count'\n                };\n            }\n            else if (hasBin) {\n                // This is not as good as binning all the Q and show heatmap\n                return {\n                    type: exports.name,\n                    score: 0.7,\n                    feature: 'Aggregate with bin but without count'\n                };\n            }\n            else {\n                return {\n                    type: exports.name,\n                    score: 0.9,\n                    feature: 'Aggregate without count and without bin'\n                };\n            }\n        }\n        // no dimension -- often not very useful\n        return {\n            type: exports.name,\n            score: 0.3,\n            feature: 'Aggregate without dimension'\n        };\n    }\n    else {\n        if (util_1.some(encodings, function (encQ) { return encoding_1.isFieldQuery(encQ) && !isDimension(encQ); })) {\n            // raw plots with measure -- simplest of all!\n            return {\n                type: exports.name,\n                score: 1,\n                feature: 'Raw with measure'\n            };\n        }\n        // raw plots with no measure -- often a lot of occlusion\n        return {\n            type: exports.name,\n            score: 0.2,\n            feature: 'Raw without measure'\n        };\n    }\n}\n//# sourceMappingURL=aggregation.js.map",
    "/**\n * Field Type (with Bin and TimeUnit) and Channel Score (Cleveland / Mackinlay based)\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar config_1 = require(\"../../config\");\nvar type_1 = require(\"./type\");\nvar base_1 = require(\"./base\");\n/**\n * Effectiveness Score for preferred axis.\n */\nvar AxisScorer = (function (_super) {\n    __extends(AxisScorer, _super);\n    function AxisScorer() {\n        return _super.call(this, 'Axis') || this;\n    }\n    AxisScorer.prototype.initScore = function (opt) {\n        if (opt === void 0) { opt = {}; }\n        opt = __assign({}, config_1.DEFAULT_QUERY_CONFIG, opt);\n        var score = {};\n        var preferredAxes = [{\n                feature: type_1.BIN_Q,\n                opt: 'preferredBinAxis'\n            }, {\n                feature: type_1.T,\n                opt: 'preferredTemporalAxis'\n            }, {\n                feature: type_1.TIMEUNIT_T,\n                opt: 'preferredTemporalAxis'\n            }, {\n                feature: type_1.TIMEUNIT_O,\n                opt: 'preferredTemporalAxis'\n            }, {\n                feature: type_1.O,\n                opt: 'preferredOrdinalAxis'\n            }, {\n                feature: type_1.N,\n                opt: 'preferredNominalAxis'\n            }];\n        preferredAxes.forEach(function (pAxis) {\n            if (opt[pAxis.opt] === channel_1.Channel.X) {\n                // penalize the other axis\n                score[pAxis.feature + '_' + channel_1.Channel.Y] = -0.01;\n            }\n            else if (opt[pAxis.opt] === channel_1.Channel.Y) {\n                // penalize the other axis\n                score[pAxis.feature + '_' + channel_1.Channel.X] = -0.01;\n            }\n        });\n        return score;\n    };\n    AxisScorer.prototype.featurize = function (type, channel) {\n        return type + '_' + channel;\n    };\n    AxisScorer.prototype.getScore = function (specM, _, __) {\n        var _this = this;\n        return specM.getEncodings().reduce(function (features, encQ) {\n            var type = type_1.getExtendedType(encQ);\n            var feature = _this.featurize(type, encQ.channel);\n            var featureScore = _this.getFeatureScore(feature);\n            if (featureScore) {\n                features.push(featureScore);\n            }\n            return features;\n        }, []);\n    };\n    return AxisScorer;\n}(base_1.Scorer));\nexports.AxisScorer = AxisScorer;\n//# sourceMappingURL=axis.js.map",
    "\"use strict\";\nvar Scorer = (function () {\n    function Scorer(type) {\n        this.type = type;\n        this.scoreIndex = this.initScore();\n    }\n    Scorer.prototype.getFeatureScore = function (feature) {\n        var type = this.type;\n        var score = this.scoreIndex[feature];\n        if (score !== undefined) {\n            return { type: type, feature: feature, score: score };\n        }\n        return undefined;\n    };\n    return Scorer;\n}());\nexports.Scorer = Scorer;\n//# sourceMappingURL=base.js.map",
    "\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar base_1 = require(\"./base\");\nvar encoding_1 = require(\"../../query/encoding\");\n/**\n * Penalize if facet channels are the only dimensions\n */\nvar DimensionScorer = (function (_super) {\n    __extends(DimensionScorer, _super);\n    function DimensionScorer() {\n        return _super.call(this, 'Dimension') || this;\n    }\n    DimensionScorer.prototype.initScore = function () {\n        return {\n            row: -2,\n            column: -2,\n            color: 0,\n            opacity: 0,\n            size: 0,\n            shape: 0\n        };\n    };\n    DimensionScorer.prototype.getScore = function (specM, _, __) {\n        var _this = this;\n        if (specM.isAggregate()) {\n            specM.getEncodings().reduce(function (maxFScore, encQ) {\n                if (encoding_1.isFieldQuery(encQ) && !encQ.aggregate && !encQ.autoCount) {\n                    var featureScore = _this.getFeatureScore(encQ.channel + '');\n                    if (featureScore && featureScore.score > maxFScore.score) {\n                        return featureScore;\n                    }\n                }\n                return maxFScore;\n            }, { type: 'Dimension', feature: 'No Dimension', score: -5 });\n        }\n        return [];\n    };\n    return DimensionScorer;\n}(base_1.Scorer));\nexports.DimensionScorer = DimensionScorer;\n//# sourceMappingURL=dimension.js.map",
    "\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar base_1 = require(\"./base\");\nvar config_1 = require(\"../../config\");\nvar channel_1 = require(\"vega-lite/build/src/channel\");\n/**\n * Effective Score for preferred facet\n */\nvar FacetScorer = (function (_super) {\n    __extends(FacetScorer, _super);\n    function FacetScorer() {\n        return _super.call(this, 'Facet') || this;\n    }\n    FacetScorer.prototype.initScore = function (opt) {\n        opt = __assign({}, config_1.DEFAULT_QUERY_CONFIG, opt);\n        var score = {};\n        if (opt.preferredFacet === channel_1.Channel.ROW) {\n            // penalize the other axis\n            score[channel_1.Channel.COLUMN] = -0.01;\n        }\n        else if (opt.preferredFacet === channel_1.Channel.COLUMN) {\n            // penalize the other axis\n            score[channel_1.Channel.ROW] = -0.01;\n        }\n        return score;\n    };\n    FacetScorer.prototype.getScore = function (specM, _, __) {\n        var _this = this;\n        return specM.getEncodings().reduce(function (features, encQ) {\n            var featureScore = _this.getFeatureScore(encQ.channel);\n            if (featureScore) {\n                features.push(featureScore);\n            }\n            return features;\n        }, []);\n    };\n    return FacetScorer;\n}(base_1.Scorer));\nexports.FacetScorer = FacetScorer;\n;\n//# sourceMappingURL=facet.js.map",
    "\"use strict\";\nvar axis_1 = require(\"./axis\");\nvar dimension_1 = require(\"./dimension\");\nvar facet_1 = require(\"./facet\");\nvar sizechannel_1 = require(\"./sizechannel\");\nvar typechannel_1 = require(\"./typechannel\");\nvar mark_1 = require(\"./mark\");\nvar SCORERS = [\n    new axis_1.AxisScorer(),\n    new dimension_1.DimensionScorer(),\n    new facet_1.FacetScorer(),\n    new mark_1.MarkScorer(),\n    new sizechannel_1.SizeChannelScorer(),\n    new typechannel_1.TypeChannelScorer()\n];\n// TODO: x/y, row/column preference\n// TODO: stacking\n// TODO: Channel, Cardinality\n// TODO: Penalize over encoding\nfunction effectiveness(specM, schema, opt) {\n    var features = SCORERS.reduce(function (f, scorer) {\n        var scores = scorer.getScore(specM, schema, opt);\n        return f.concat(scores);\n    }, []);\n    return {\n        score: features.reduce(function (s, f) {\n            return s + f.score;\n        }, 0),\n        features: features\n    };\n}\nexports.effectiveness = effectiveness;\n//# sourceMappingURL=index.js.map",
    "\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar mark_1 = require(\"vega-lite/build/src/mark\");\nvar util_1 = require(\"../../util\");\nvar type_1 = require(\"./type\");\nvar base_1 = require(\"./base\");\nvar MarkScorer = (function (_super) {\n    __extends(MarkScorer, _super);\n    function MarkScorer() {\n        return _super.call(this, 'Mark') || this;\n    }\n    MarkScorer.prototype.initScore = function () {\n        return init();\n    };\n    MarkScorer.prototype.getScore = function (specM, _, __) {\n        var mark = specM.getMark();\n        if (mark === mark_1.Mark.CIRCLE || mark === mark_1.Mark.SQUARE) {\n            mark = mark_1.Mark.POINT;\n        }\n        var xEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.X);\n        var xType = xEncQ ? type_1.getExtendedType(xEncQ) : type_1.NONE;\n        var yEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.Y);\n        var yType = yEncQ ? type_1.getExtendedType(yEncQ) : type_1.NONE;\n        var isOccluded = !specM.isAggregate(); // FIXME\n        var feature = xType + '_' + yType + '_' + isOccluded + '_' + mark;\n        var featureScore = this.getFeatureScore(feature);\n        return [featureScore];\n    };\n    return MarkScorer;\n}(base_1.Scorer));\nexports.MarkScorer = MarkScorer;\nfunction featurize(xType, yType, hasOcclusion, mark) {\n    return xType + '_' + yType + '_' + hasOcclusion + '_' + mark;\n}\nexports.featurize = featurize;\nfunction init() {\n    var MEASURES = [type_1.Q, type_1.T];\n    var DISCRETE = [type_1.BIN_Q, type_1.TIMEUNIT_O, type_1.O, type_1.N];\n    var DISCRETE_OR_NONE = DISCRETE.concat([type_1.NONE]);\n    var SCORE = {};\n    // QxQ\n    MEASURES.forEach(function (xType) {\n        MEASURES.forEach(function (yType) {\n            // has occlusion\n            var occludedQQMark = {\n                point: 0,\n                text: -0.2,\n                tick: -0.5,\n                rect: -1,\n                bar: -2,\n                line: -2,\n                area: -2,\n                rule: -2.5\n            };\n            util_1.forEach(occludedQQMark, function (score, mark) {\n                var feature = featurize(xType, yType, true, mark);\n                SCORE[feature] = score;\n            });\n            // no occlusion\n            // TODO: possible to use connected scatter plot\n            var noOccludedQQMark = {\n                point: 0,\n                text: -0.2,\n                tick: -0.5,\n                bar: -2,\n                line: -2,\n                area: -2,\n                rule: -2.5\n            };\n            util_1.forEach(noOccludedQQMark, function (score, mark) {\n                var feature = featurize(xType, yType, false, mark);\n                SCORE[feature] = score;\n            });\n        });\n    });\n    // DxQ, QxD\n    MEASURES.forEach(function (xType) {\n        // HAS OCCLUSION\n        DISCRETE_OR_NONE.forEach(function (yType) {\n            var occludedDimensionMeasureMark = {\n                tick: 0,\n                point: -0.2,\n                text: -0.5,\n                bar: -2,\n                line: -2,\n                area: -2,\n                rule: -2.5\n            };\n            util_1.forEach(occludedDimensionMeasureMark, function (score, mark) {\n                var feature = featurize(xType, yType, true, mark);\n                SCORE[feature] = score;\n                // also do the inverse\n                var feature2 = featurize(yType, xType, true, mark);\n                SCORE[feature2] = score;\n            });\n        });\n        [type_1.TIMEUNIT_T].forEach(function (yType) {\n            var occludedDimensionMeasureMark = {\n                // For Time Dimension with time scale, tick is not good\n                point: 0,\n                text: -0.5,\n                tick: -1,\n                bar: -2,\n                line: -2,\n                area: -2,\n                rule: -2.5\n            };\n            util_1.forEach(occludedDimensionMeasureMark, function (score, mark) {\n                var feature = featurize(xType, yType, true, mark);\n                SCORE[feature] = score;\n                // also do the inverse\n                var feature2 = featurize(yType, xType, true, mark);\n                SCORE[feature2] = score;\n            });\n        });\n        // NO OCCLUSION\n        [type_1.NONE, type_1.N, type_1.O].forEach(function (yType) {\n            var noOccludedQxN = {\n                bar: 0,\n                point: -0.2,\n                tick: -0.25,\n                text: -0.3,\n                // Line / Area can mislead trend for N\n                line: -2,\n                area: -2,\n                // Non-sense to use rule here\n                rule: -2.5\n            };\n            util_1.forEach(noOccludedQxN, function (score, mark) {\n                var feature = featurize(xType, yType, false, mark);\n                SCORE[feature] = score;\n                // also do the inverse\n                var feature2 = featurize(yType, xType, false, mark);\n                SCORE[feature2] = score;\n            });\n        });\n        [type_1.BIN_Q].forEach(function (yType) {\n            var noOccludedQxBinQ = {\n                bar: 0,\n                point: -0.2,\n                tick: -0.25,\n                text: -0.3,\n                // Line / Area isn't the best fit for bin\n                line: -0.5,\n                area: -0.5,\n                // Non-sense to use rule here\n                rule: -2.5\n            };\n            util_1.forEach(noOccludedQxBinQ, function (score, mark) {\n                var feature = featurize(xType, yType, false, mark);\n                SCORE[feature] = score;\n                // also do the inverse\n                var feature2 = featurize(yType, xType, false, mark);\n                SCORE[feature2] = score;\n            });\n        });\n        [type_1.TIMEUNIT_T, type_1.TIMEUNIT_O].forEach(function (yType) {\n            // For aggregate / surely no occlusion plot, Temporal with time or ordinal\n            // are not that different.\n            var noOccludedQxBinQ = {\n                line: 0,\n                area: -0.1,\n                bar: -0.2,\n                point: -0.3,\n                tick: -0.35,\n                text: -0.4,\n                // Non-sense to use rule here\n                rule: -2.5\n            };\n            util_1.forEach(noOccludedQxBinQ, function (score, mark) {\n                var feature = featurize(xType, yType, false, mark);\n                SCORE[feature] = score;\n                // also do the inverse\n                var feature2 = featurize(yType, xType, false, mark);\n                SCORE[feature2] = score;\n            });\n        });\n    });\n    [type_1.TIMEUNIT_T].forEach(function (xType) {\n        [type_1.TIMEUNIT_T].forEach(function (yType) {\n            // has occlusion\n            var ttMark = {\n                point: 0,\n                rect: -0.1,\n                text: -0.5,\n                tick: -1,\n                bar: -2,\n                line: -2,\n                area: -2,\n                rule: -2.5\n            };\n            // No difference between has occlusion and no occlusion\n            // as most of the time, it will be the occluded case.\n            util_1.forEach(ttMark, function (score, mark) {\n                var feature = featurize(xType, yType, true, mark);\n                SCORE[feature] = score;\n            });\n            util_1.forEach(ttMark, function (score, mark) {\n                var feature = featurize(xType, yType, false, mark);\n                SCORE[feature] = score;\n            });\n        });\n        DISCRETE_OR_NONE.forEach(function (yType) {\n            // has occlusion\n            var tdMark = {\n                tick: 0,\n                point: -0.2,\n                text: -0.5,\n                rect: -1,\n                bar: -2,\n                line: -2,\n                area: -2,\n                rule: -2.5\n            };\n            // No difference between has occlusion and no occlusion\n            // as most of the time, it will be the occluded case.\n            util_1.forEach(tdMark, function (score, mark) {\n                var feature = featurize(xType, yType, true, mark);\n                SCORE[feature] = score;\n            });\n            util_1.forEach(tdMark, function (score, mark) {\n                var feature = featurize(yType, xType, true, mark);\n                SCORE[feature] = score;\n            });\n            util_1.forEach(tdMark, function (score, mark) {\n                var feature = featurize(xType, yType, false, mark);\n                SCORE[feature] = score;\n            });\n            util_1.forEach(tdMark, function (score, mark) {\n                var feature = featurize(yType, xType, false, mark);\n                SCORE[feature] = score;\n            });\n        });\n    });\n    // DxD\n    DISCRETE_OR_NONE.forEach(function (xType) {\n        DISCRETE_OR_NONE.forEach(function (yType) {\n            // has occlusion\n            var ddMark = {\n                point: 0,\n                rect: 0,\n                text: -0.1,\n                tick: -1,\n                bar: -2,\n                line: -2,\n                area: -2,\n                rule: -2.5\n            };\n            // No difference between has occlusion and no occlusion\n            util_1.forEach(ddMark, function (score, mark) {\n                var feature = featurize(xType, yType, true, mark);\n                SCORE[feature] = score;\n            });\n            util_1.forEach(ddMark, function (score, mark) {\n                var feature = featurize(xType, yType, false, mark);\n                SCORE[feature] = score;\n            });\n        });\n    });\n    return SCORE;\n}\n//# sourceMappingURL=mark.js.map",
    "\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar base_1 = require(\"./base\");\n/**\n * Effectivenss score that penalize size for bar and tick\n */\nvar SizeChannelScorer = (function (_super) {\n    __extends(SizeChannelScorer, _super);\n    function SizeChannelScorer() {\n        return _super.call(this, 'SizeChannel') || this;\n    }\n    SizeChannelScorer.prototype.initScore = function () {\n        return {\n            bar_size: -2,\n            tick_size: -2\n        };\n    };\n    SizeChannelScorer.prototype.getScore = function (specM, _, __) {\n        var _this = this;\n        var mark = specM.getMark();\n        return specM.getEncodings().reduce(function (featureScores, encQ) {\n            var feature = mark + '_' + encQ.channel;\n            var featureScore = _this.getFeatureScore(feature);\n            if (featureScore) {\n                featureScores.push(featureScore);\n            }\n            return featureScores;\n        }, []);\n    };\n    return SizeChannelScorer;\n}(base_1.Scorer));\nexports.SizeChannelScorer = SizeChannelScorer;\n//# sourceMappingURL=sizechannel.js.map",
    "\"use strict\";\nvar scale_1 = require(\"vega-lite/build/src/scale\");\nvar type_1 = require(\"vega-lite/build/src/type\");\nvar encoding_1 = require(\"../../query/encoding\");\n/**\n * Finer grained data types that takes binning and timeUnit into account.\n */\nvar ExtendedType;\n(function (ExtendedType) {\n    ExtendedType[ExtendedType[\"Q\"] = type_1.Type.QUANTITATIVE] = \"Q\";\n    ExtendedType[ExtendedType[\"BIN_Q\"] = 'bin_' + type_1.Type.QUANTITATIVE] = \"BIN_Q\";\n    ExtendedType[ExtendedType[\"T\"] = type_1.Type.TEMPORAL] = \"T\";\n    /**\n     * Time Unit Temporal Field with time scale.\n     */\n    ExtendedType[ExtendedType[\"TIMEUNIT_T\"] = 'timeUnit_time'] = \"TIMEUNIT_T\";\n    /**\n     * Time Unit Temporal Field with ordinal scale.\n     */\n    ExtendedType[ExtendedType[\"TIMEUNIT_O\"] = 'timeUnit_' + type_1.Type.ORDINAL] = \"TIMEUNIT_O\";\n    ExtendedType[ExtendedType[\"O\"] = type_1.Type.ORDINAL] = \"O\";\n    ExtendedType[ExtendedType[\"N\"] = type_1.Type.NOMINAL] = \"N\";\n    ExtendedType[ExtendedType[\"NONE\"] = '-'] = \"NONE\";\n})(ExtendedType = exports.ExtendedType || (exports.ExtendedType = {}));\nexports.Q = ExtendedType.Q;\nexports.BIN_Q = ExtendedType.BIN_Q;\nexports.T = ExtendedType.T;\nexports.TIMEUNIT_T = ExtendedType.TIMEUNIT_T;\nexports.TIMEUNIT_O = ExtendedType.TIMEUNIT_O;\nexports.O = ExtendedType.O;\nexports.N = ExtendedType.N;\nexports.NONE = ExtendedType.NONE;\nfunction getExtendedType(fieldQ) {\n    if (fieldQ.bin) {\n        return ExtendedType.BIN_Q;\n    }\n    else if (fieldQ.timeUnit) {\n        var sType = encoding_1.scaleType(fieldQ);\n        return scale_1.hasDiscreteDomain(sType) ? ExtendedType.TIMEUNIT_O : ExtendedType.TIMEUNIT_T;\n    }\n    return fieldQ.type;\n}\nexports.getExtendedType = getExtendedType;\n//# sourceMappingURL=type.js.map",
    "\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar shorthand_1 = require(\"../../query/shorthand\");\nvar util_1 = require(\"../../util\");\nvar type_1 = require(\"./type\");\nvar base_1 = require(\"./base\");\nexports.TERRIBLE = -10;\n/**\n * Effectiveness score for relationship between\n * Field Type (with Bin and TimeUnit) and Channel Score (Cleveland / Mackinlay based)\n */\nvar TypeChannelScorer = (function (_super) {\n    __extends(TypeChannelScorer, _super);\n    function TypeChannelScorer() {\n        return _super.call(this, 'TypeChannel') || this;\n    }\n    TypeChannelScorer.prototype.initScore = function () {\n        var _this = this;\n        var SCORE = {};\n        // Continuous Quantitative / Temporal Fields\n        var CONTINUOUS_TYPE_CHANNEL_SCORE = {\n            x: 0,\n            y: 0,\n            size: -0.575,\n            color: -0.725,\n            text: -2,\n            opacity: -3,\n            shape: exports.TERRIBLE,\n            row: exports.TERRIBLE,\n            column: exports.TERRIBLE,\n            detail: 2 * exports.TERRIBLE\n        };\n        [type_1.Q, type_1.T, type_1.TIMEUNIT_T].forEach(function (type) {\n            util_1.keys(CONTINUOUS_TYPE_CHANNEL_SCORE).forEach(function (channel) {\n                SCORE[_this.featurize(type, channel)] = CONTINUOUS_TYPE_CHANNEL_SCORE[channel];\n            });\n        });\n        // Discretized Quantitative / Temporal Fields / Ordinal\n        var ORDERED_TYPE_CHANNEL_SCORE = util_1.extend({}, CONTINUOUS_TYPE_CHANNEL_SCORE, {\n            row: -0.75,\n            column: -0.75,\n            shape: -3.1,\n            text: -3.2,\n            detail: -4\n        });\n        [type_1.BIN_Q, type_1.TIMEUNIT_O, type_1.O].forEach(function (type) {\n            util_1.keys(ORDERED_TYPE_CHANNEL_SCORE).forEach(function (channel) {\n                SCORE[_this.featurize(type, channel)] = ORDERED_TYPE_CHANNEL_SCORE[channel];\n            });\n        });\n        var NOMINAL_TYPE_CHANNEL_SCORE = {\n            x: 0,\n            y: 0,\n            color: -0.6,\n            shape: -0.65,\n            row: -0.7,\n            column: -0.7,\n            text: -0.8,\n            detail: -2,\n            size: -3,\n            opacity: -3.1,\n        };\n        util_1.keys(NOMINAL_TYPE_CHANNEL_SCORE).forEach(function (channel) {\n            SCORE[_this.featurize(type_1.N, channel)] = NOMINAL_TYPE_CHANNEL_SCORE[channel];\n        });\n        return SCORE;\n    };\n    TypeChannelScorer.prototype.featurize = function (type, channel) {\n        return type + '_' + channel;\n    };\n    TypeChannelScorer.prototype.getScore = function (specM, schema, opt) {\n        var _this = this;\n        var encodingQueryByField = specM.getEncodings().reduce(function (m, encQ) {\n            var fieldKey = shorthand_1.fieldDef(encQ);\n            (m[fieldKey] = m[fieldKey] || []).push(encQ);\n            return m;\n        }, {});\n        var features = [];\n        util_1.forEach(encodingQueryByField, function (encQs) {\n            var bestFieldFeature = encQs.reduce(function (best, encQ) {\n                var type = type_1.getExtendedType(encQ);\n                var feature = _this.featurize(type, encQ.channel);\n                var featureScore = _this.getFeatureScore(feature);\n                if (best === null || featureScore.score > best.score) {\n                    return featureScore;\n                }\n                return best;\n            }, null);\n            features.push(bestFieldFeature);\n            // TODO: add plus for over-encoding of one field\n        });\n        return features;\n    };\n    return TypeChannelScorer;\n}(base_1.Scorer));\nexports.TypeChannelScorer = TypeChannelScorer;\n//# sourceMappingURL=typechannel.js.map",
    "\"use strict\";\nvar encoding_1 = require(\"../query/encoding\");\nexports.name = 'fieldOrder';\n/**\n * Return ranking score based on indices of encoded fields in the schema.\n * If there are multiple fields, prioritize field on the lower indices of encodings.\n *\n * For example, to compare two specs with two encodings each,\n * first we compare the field on the 0-th index\n * and only compare the field on the 1-th index only if the fields on the 0-th index are the same.\n */\nfunction score(specM, schema, _) {\n    var fieldWildcardIndices = specM.wildcardIndex.encodingIndicesByProperty.get('field');\n    if (!fieldWildcardIndices) {\n        return {\n            score: 0,\n            features: []\n        };\n    }\n    var encodings = specM.specQuery.encodings;\n    var numFields = schema.fieldSchemas.length;\n    var features = [];\n    var totalScore = 0, base = 1;\n    for (var i = fieldWildcardIndices.length - 1; i >= 0; i--) {\n        var index = fieldWildcardIndices[i];\n        var encoding = encodings[index];\n        // Skip ValueQuery as we only care about order of fields.\n        if (encoding_1.isValueQuery(encoding))\n            continue;\n        var field = encoding.field;\n        var fieldWildcard = specM.wildcardIndex.encodings[index].get('field');\n        var fieldIndex = schema.fieldSchema(field).index;\n        // reverse order field with lower index should get higher score and come first\n        var score_1 = -fieldIndex * base;\n        totalScore += score_1;\n        features.push({\n            score: score_1,\n            type: 'fieldOrder',\n            feature: \"field \" + fieldWildcard.name + \" is \" + field + \" (#\" + fieldIndex + \" in the schema)\"\n        });\n        base *= numFields;\n    }\n    return {\n        score: totalScore,\n        features: features\n    };\n}\nexports.score = score;\n//# sourceMappingURL=fieldorder.js.map",
    "\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar effectiveness_1 = require(\"./effectiveness\");\n__export(require(\"./effectiveness\"));\nexports.aggregation = require(\"./aggregation\");\nexports.fieldOrder = require(\"./fieldorder\");\n/**\n * Registry for all encoding ranking functions\n */\nvar rankingRegistry = {};\n/**\n * Add an ordering function to the registry.\n */\nfunction register(name, keyFn) {\n    rankingRegistry[name] = keyFn;\n}\nexports.register = register;\nfunction get(name) {\n    return rankingRegistry[name];\n}\nexports.get = get;\nfunction rank(group, query, schema, level) {\n    if (!query.nest || level === query.nest.length) {\n        if (query.orderBy || query.chooseBy) {\n            group.items.sort(comparatorFactory(query.orderBy || query.chooseBy, schema, query.config));\n            if (query.chooseBy) {\n                if (group.items.length > 0) {\n                    // for chooseBy -- only keep the top-item\n                    group.items.splice(1);\n                }\n            }\n        }\n    }\n    else {\n        // sort lower-level nodes first because our ranking takes top-item in the subgroup\n        group.items.forEach(function (subgroup) {\n            rank(subgroup, query, schema, level + 1);\n        });\n        if (query.nest[level].orderGroupBy) {\n            group.items.sort(groupComparatorFactory(query.nest[level].orderGroupBy, schema, query.config));\n        }\n    }\n    return group;\n}\nexports.rank = rank;\nfunction comparatorFactory(name, schema, opt) {\n    return function (m1, m2) {\n        if (name instanceof Array) {\n            return getScoreDifference(name, m1, m2, schema, opt);\n        }\n        else {\n            return getScoreDifference([name], m1, m2, schema, opt);\n        }\n    };\n}\nexports.comparatorFactory = comparatorFactory;\nfunction groupComparatorFactory(name, schema, opt) {\n    return function (g1, g2) {\n        var m1 = g1.getTopSpecQueryModel();\n        var m2 = g2.getTopSpecQueryModel();\n        if (name instanceof Array) {\n            return getScoreDifference(name, m1, m2, schema, opt);\n        }\n        else {\n            return getScoreDifference([name], m1, m2, schema, opt);\n        }\n    };\n}\nexports.groupComparatorFactory = groupComparatorFactory;\nfunction getScoreDifference(name, m1, m2, schema, opt) {\n    for (var _i = 0, name_1 = name; _i < name_1.length; _i++) {\n        var rankingName = name_1[_i];\n        var scoreDifference = getScore(m2, rankingName, schema, opt).score - getScore(m1, rankingName, schema, opt).score;\n        if (scoreDifference !== 0) {\n            return scoreDifference;\n        }\n    }\n    return 0;\n}\nfunction getScore(model, rankingName, schema, opt) {\n    if (model.getRankingScore(rankingName) !== undefined) {\n        return model.getRankingScore(rankingName);\n    }\n    var fn = get(rankingName);\n    var score = fn(model, schema, opt);\n    model.setRankingScore(rankingName, score);\n    return score;\n}\nexports.getScore = getScore;\nexports.EFFECTIVENESS = 'effectiveness';\nregister(exports.EFFECTIVENESS, effectiveness_1.effectiveness);\nregister(exports.aggregation.name, exports.aggregation.score);\nregister(exports.fieldOrder.name, exports.fieldOrder.score);\n//# sourceMappingURL=ranking.js.map",
    "\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar config_1 = require(\"./config\");\nvar generate_1 = require(\"./generate\");\nvar nest_1 = require(\"./nest\");\nvar normalize_1 = require(\"./query/normalize\");\nvar ranking_1 = require(\"./ranking/ranking\");\nfunction recommend(q, schema, config) {\n    // 1. Normalize non-nested `groupBy` to always have `groupBy` inside `nest`\n    //    and merge config with the following precedence\n    //    query.config > config > DEFAULT_QUERY_CONFIG\n    q = __assign({}, normalize_1.normalize(q), { config: __assign({}, config_1.DEFAULT_QUERY_CONFIG, config, q.config) });\n    // 2. Generate\n    var answerSet = generate_1.generate(q.spec, schema, q.config);\n    var nestedAnswerSet = nest_1.nest(answerSet, q.nest);\n    var result = ranking_1.rank(nestedAnswerSet, q, schema, 0);\n    return {\n        query: q,\n        result: result\n    };\n}\nexports.recommend = recommend;\n//# sourceMappingURL=recommend.js.map",
    "\"use strict\";\nvar type_1 = require(\"vega-lite/build/src/type\");\nvar bin_1 = require(\"vega-lite/build/src/bin\");\nvar timeunit_1 = require(\"vega-lite/build/src/timeunit\");\nvar stats_1 = require(\"datalib/src/stats\");\nvar type_2 = require(\"datalib/src/import/type\");\nvar dlBin = require(\"datalib/src/bins/bins\");\nvar config_1 = require(\"./config\");\nvar util_1 = require(\"./util\");\n/**\n * Build a Schema object.\n *\n * @param data - a set of raw data in the same format that Vega-Lite / Vega takes\n * Basically, it's an array in the form of:\n *\n * [\n *   {a: 1, b:2},\n *   {a: 2, b:3},\n *   ...\n * ]\n *\n * @return a Schema object\n */\nfunction build(data, opt) {\n    if (opt === void 0) { opt = {}; }\n    opt = util_1.extend({}, config_1.DEFAULT_QUERY_CONFIG, opt);\n    // create profiles for each variable\n    var summaries = stats_1.summary(data);\n    var types = type_2.inferAll(data); // inferAll does stronger type inference than summary\n    var fieldSchemas = summaries.map(function (fieldProfile) {\n        var field = fieldProfile.field;\n        var primitiveType = types[field];\n        var distinct = fieldProfile.distinct;\n        var type;\n        if (primitiveType === PrimitiveType.NUMBER) {\n            type = type_1.Type.QUANTITATIVE;\n        }\n        else if (primitiveType === PrimitiveType.INTEGER) {\n            // use ordinal or nominal when cardinality of integer type is relatively low and the distinct values are less than an amount specified in options\n            if ((distinct < opt.numberNominalLimit) && (distinct / fieldProfile.count < opt.numberNominalProportion)) {\n                type = type_1.Type.NOMINAL;\n            }\n            else {\n                type = type_1.Type.QUANTITATIVE;\n            }\n        }\n        else if (primitiveType === PrimitiveType.DATE) {\n            type = type_1.Type.TEMPORAL;\n            // need to get correct min/max of date data because datalib's summary method does not\n            // calculate this correctly for date types.\n            fieldProfile.min = new Date(data[0][field]);\n            fieldProfile.max = new Date(data[0][field]);\n            for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\n                var dataEntry = data_1[_i];\n                var time = new Date(dataEntry[field]).getTime();\n                if (time < fieldProfile.min.getTime()) {\n                    fieldProfile.min = new Date(time);\n                }\n                if (time > fieldProfile.max.getTime()) {\n                    fieldProfile.max = new Date(time);\n                }\n            }\n        }\n        else {\n            type = type_1.Type.NOMINAL;\n        }\n        return {\n            field: field,\n            type: type,\n            primitiveType: primitiveType,\n            stats: fieldProfile,\n            timeStats: {},\n            binStats: {}\n        };\n    });\n    // order the fieldSchemas (sort them)\n    var order = {\n        'nominal': 0,\n        'ordinal': 1,\n        'temporal': 2,\n        'quantitative': 3\n    };\n    fieldSchemas.sort(function (a, b) {\n        // first order by type: nominal < temporal < quantitative < ordinal\n        if (order[a.type] < order[b.type]) {\n            return -1;\n        }\n        else if (order[a.type] > order[b.type]) {\n            return 1;\n        }\n        else {\n            // then order by field (alphabetically)\n            return a.field.localeCompare(b.field);\n        }\n    });\n    // Add index for sorting\n    fieldSchemas.forEach(function (fieldSchema, index) { return fieldSchema.index = index; });\n    // calculate preset bins for quantitative and temporal data\n    for (var _i = 0, fieldSchemas_1 = fieldSchemas; _i < fieldSchemas_1.length; _i++) {\n        var fieldSchema = fieldSchemas_1[_i];\n        if (fieldSchema.type === type_1.Type.QUANTITATIVE) {\n            for (var _a = 0, _b = opt.enum.binProps.maxbins; _a < _b.length; _a++) {\n                var maxbins = _b[_a];\n                fieldSchema.binStats[maxbins] = binSummary(maxbins, fieldSchema.stats);\n            }\n        }\n        else if (fieldSchema.type === type_1.Type.TEMPORAL) {\n            for (var _c = 0, _d = opt.enum.timeUnit; _c < _d.length; _c++) {\n                var unit = _d[_c];\n                if (unit !== undefined) {\n                    fieldSchema.timeStats[unit] = timeSummary(unit, fieldSchema.stats);\n                }\n            }\n        }\n    }\n    return new Schema(fieldSchemas);\n}\nexports.build = build;\nvar Schema = (function () {\n    function Schema(fieldSchemas) {\n        this._fieldSchemas = fieldSchemas;\n        this._fieldSchemaIndex = fieldSchemas.reduce(function (m, fieldSchema) {\n            m[fieldSchema.field] = fieldSchema;\n            return m;\n        }, {});\n    }\n    /** @return a list of the field names (for enumerating). */\n    Schema.prototype.fields = function () {\n        return this._fieldSchemas.map(function (fieldSchema) { return fieldSchema.field; });\n    };\n    Object.defineProperty(Schema.prototype, \"fieldSchemas\", {\n        /** @return a list of FieldSchemas */\n        get: function () {\n            return this._fieldSchemas;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Schema.prototype.fieldSchema = function (field) {\n        return this._fieldSchemaIndex[field];\n    };\n    /**\n     * @return primitive type of the field if exist, otherwise return null\n     */\n    Schema.prototype.primitiveType = function (field) {\n        return this._fieldSchemaIndex[field] ? this._fieldSchemaIndex[field].primitiveType : null;\n    };\n    /**\n     * @return type of measturement of the field if exist, otherwise return null\n     */\n    Schema.prototype.type = function (field) {\n        return this._fieldSchemaIndex[field] ? this._fieldSchemaIndex[field].type : null;\n    };\n    /** @return cardinality of the field associated with encQ, null if it doesn't exist.\n     *  @param augmentTimeUnitDomain - TimeUnit field domains will not be augmented if explicitly set to false.\n     */\n    Schema.prototype.cardinality = function (fieldQ, augmentTimeUnitDomain, excludeInvalid) {\n        if (augmentTimeUnitDomain === void 0) { augmentTimeUnitDomain = true; }\n        if (excludeInvalid === void 0) { excludeInvalid = false; }\n        var fieldSchema = this._fieldSchemaIndex[fieldQ.field];\n        if (fieldQ.aggregate || fieldQ.autoCount) {\n            return 1;\n        }\n        else if (fieldQ.bin) {\n            // encQ.bin will either be a boolean or a BinQuery\n            var bin = void 0;\n            if (typeof fieldQ.bin === 'boolean') {\n                // autoMaxBins defaults to 10 if channel is Wildcard\n                bin = {\n                    maxbins: bin_1.autoMaxBins(fieldQ.channel)\n                };\n            }\n            else {\n                bin = fieldQ.bin;\n            }\n            var maxbins = bin.maxbins;\n            if (!fieldSchema.binStats[maxbins]) {\n                // need to calculate\n                fieldSchema.binStats[maxbins] = binSummary(maxbins, fieldSchema.stats);\n            }\n            // don't need to worry about excludeInvalid here because invalid values don't affect linearly binned field's cardinality\n            return fieldSchema.binStats[maxbins].distinct;\n        }\n        else if (fieldQ.timeUnit) {\n            if (augmentTimeUnitDomain) {\n                switch (fieldQ.timeUnit) {\n                    // TODO: this should not always be the case once Vega-Lite supports turning off domain augmenting (VL issue #1385)\n                    case timeunit_1.TimeUnit.SECONDS: return 60;\n                    case timeunit_1.TimeUnit.MINUTES: return 60;\n                    case timeunit_1.TimeUnit.HOURS: return 24;\n                    case timeunit_1.TimeUnit.DAY: return 7;\n                    case timeunit_1.TimeUnit.DATE: return 31;\n                    case timeunit_1.TimeUnit.MONTH: return 12;\n                    case timeunit_1.TimeUnit.QUARTER: return 4;\n                    case timeunit_1.TimeUnit.MILLISECONDS: return 1000;\n                }\n            }\n            var unit = fieldQ.timeUnit;\n            var timeStats = fieldSchema.timeStats;\n            // if the cardinality for the timeUnit is not cached, calculate it\n            if (!timeStats[unit]) {\n                timeStats[unit] = timeSummary(fieldQ.timeUnit, fieldSchema.stats);\n            }\n            if (excludeInvalid) {\n                return timeStats[unit].distinct - invalidCount(timeStats[unit].unique, ['Invalid Date', null]);\n            }\n            else {\n                return timeStats[unit].distinct;\n            }\n        }\n        else {\n            if (fieldSchema) {\n                if (excludeInvalid) {\n                    return fieldSchema.stats.distinct - invalidCount(fieldSchema.stats.unique, [NaN, null]);\n                }\n                else {\n                    return fieldSchema.stats.distinct;\n                }\n            }\n            else {\n                return null;\n            }\n        }\n    };\n    /**\n     * Given an EncodingQuery with a timeUnit, returns true if the date field\n     * has multiple distinct values for all parts of the timeUnit. Returns undefined\n     * if the timeUnit is undefined.\n     * i.e.\n     * ('yearmonth', [Jan 1 2000, Feb 2 2000] returns false)\n     * ('yearmonth', [Jan 1 2000, Feb 2 2001] returns true)\n     */\n    Schema.prototype.timeUnitHasVariation = function (fieldQ) {\n        if (!fieldQ.timeUnit) {\n            return;\n        }\n        // if there is no variation in `date`, there should not be variation in `day`\n        if (fieldQ.timeUnit === timeunit_1.TimeUnit.DAY) {\n            var dateEncQ = util_1.extend({}, fieldQ, { timeUnit: timeunit_1.TimeUnit.DATE });\n            if (this.cardinality(dateEncQ, false, true) <= 1) {\n                return false;\n            }\n        }\n        var fullTimeUnit = fieldQ.timeUnit;\n        for (var _i = 0, SINGLE_TIMEUNITS_1 = timeunit_1.SINGLE_TIMEUNITS; _i < SINGLE_TIMEUNITS_1.length; _i++) {\n            var singleUnit = SINGLE_TIMEUNITS_1[_i];\n            if (timeunit_1.containsTimeUnit(fullTimeUnit, singleUnit)) {\n                // Create a clone of encQ, but with singleTimeUnit\n                var singleUnitEncQ = util_1.extend({}, fieldQ, { timeUnit: singleUnit });\n                if (this.cardinality(singleUnitEncQ, false, true) <= 1) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n    Schema.prototype.domain = function (fieldQ) {\n        // TODO: differentiate for field with bin / timeUnit\n        var fieldSchema = this._fieldSchemaIndex[fieldQ.field];\n        var domain = util_1.keys(fieldSchema.stats.unique);\n        if (fieldSchema.type === type_1.Type.QUANTITATIVE) {\n            // return [min, max], coerced into number types\n            return [+fieldSchema.stats.min, +fieldSchema.stats.max];\n        }\n        else if (fieldSchema.primitiveType === PrimitiveType.DATE) {\n            // return [min, max] dates\n            return [fieldSchema.stats.min, fieldSchema.stats.max];\n        }\n        else if (fieldSchema.primitiveType === PrimitiveType.INTEGER ||\n            fieldSchema.primitiveType === PrimitiveType.NUMBER) {\n            // coerce non-quantitative numerical data into number type\n            domain = domain.map(function (x) { return +x; });\n            return domain.sort(util_1.cmp);\n        }\n        return domain.map(function (x) {\n            // Convert 'null' to null as it is encoded similarly in datalib.\n            // This is wrong when it is a string 'null' but that rarely happens.\n            return x === 'null' ? null : x;\n        }).sort(util_1.cmp);\n    };\n    /**\n     * @return a Summary corresponding to the field of the given EncodingQuery\n     */\n    Schema.prototype.stats = function (fieldQ) {\n        // TODO: differentiate for field with bin / timeUnit vs without\n        var fieldSchema = this._fieldSchemaIndex[fieldQ.field];\n        return fieldSchema ? fieldSchema.stats : null;\n    };\n    return Schema;\n}());\nexports.Schema = Schema;\n/**\n * @return a summary of the binning scheme determined from the given max number of bins\n */\nfunction binSummary(maxbins, summary) {\n    var bin = dlBin({\n        min: summary.min,\n        max: summary.max,\n        maxbins: maxbins\n    });\n    // start with summary, pre-binning\n    var result = util_1.extend({}, summary);\n    result.unique = binUnique(bin, summary.unique);\n    result.distinct = (bin.stop - bin.start) / bin.step;\n    result.min = bin.start;\n    result.max = bin.stop;\n    return result;\n}\n/** @return a modified version of the passed summary with unique and distinct set according to the timeunit.\n *  Maps 'null' (string) keys to the null value and invalid dates to 'Invalid Date' in the unique dictionary.\n */\nfunction timeSummary(timeunit, summary) {\n    var result = util_1.extend({}, summary);\n    var unique = {};\n    util_1.keys(summary.unique).forEach(function (dateString) {\n        // don't convert null value because the Date constructor will actually convert it to a date\n        var date = (dateString === 'null') ? null : new Date(dateString);\n        // at this point, `date` is either the null value, a valid Date object, or \"Invalid Date\" which is a Date\n        var key;\n        if (date === null) {\n            key = null;\n        }\n        else if (isNaN(date.getTime())) {\n            key = 'Invalid Date';\n        }\n        else {\n            key = ((timeunit === timeunit_1.TimeUnit.DAY) ? date.getDay() : timeunit_1.convert(timeunit, date)).toString();\n        }\n        unique[key] = (unique[key] || 0) + summary.unique[dateString];\n    });\n    result.unique = unique;\n    result.distinct = util_1.keys(unique).length;\n    return result;\n}\n/**\n * @return a new unique object based off of the old unique count and a binning scheme\n */\nfunction binUnique(bin, oldUnique) {\n    var newUnique = {};\n    for (var value in oldUnique) {\n        var bucket = void 0;\n        if (value === null) {\n            bucket = null;\n        }\n        else if (isNaN(Number(value))) {\n            bucket = NaN;\n        }\n        else {\n            bucket = bin.value(Number(value));\n        }\n        newUnique[bucket] = (newUnique[bucket] || 0) + oldUnique[value];\n    }\n    return newUnique;\n}\n/** @return the number of items in list that occur as keys of unique */\nfunction invalidCount(unique, list) {\n    return list.reduce(function (prev, cur) {\n        return unique[cur] ? prev + 1 : prev;\n    }, 0);\n}\nvar PrimitiveType;\n(function (PrimitiveType) {\n    PrimitiveType[PrimitiveType[\"STRING\"] = 'string'] = \"STRING\";\n    PrimitiveType[PrimitiveType[\"NUMBER\"] = 'number'] = \"NUMBER\";\n    PrimitiveType[PrimitiveType[\"INTEGER\"] = 'integer'] = \"INTEGER\";\n    PrimitiveType[PrimitiveType[\"BOOLEAN\"] = 'boolean'] = \"BOOLEAN\";\n    PrimitiveType[PrimitiveType[\"DATE\"] = 'date'] = \"DATE\";\n})(PrimitiveType = exports.PrimitiveType || (exports.PrimitiveType = {}));\n//# sourceMappingURL=schema.js.map",
    "\"use strict\";\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar scale_1 = require(\"vega-lite/build/src/scale\");\nvar type_1 = require(\"vega-lite/build/src/type\");\nvar encoding_1 = require(\"./query/encoding\");\nfunction stylize(answerSet, schema, opt) {\n    var encQIndex = {};\n    answerSet = answerSet.map(function (specM) {\n        if (opt.smallRangeStepForHighCardinalityOrFacet) {\n            specM = smallRangeStepForHighCardinalityOrFacet(specM, schema, encQIndex, opt);\n        }\n        if (opt.nominalColorScaleForHighCardinality) {\n            specM = nominalColorScaleForHighCardinality(specM, schema, encQIndex, opt);\n        }\n        if (opt.xAxisOnTopForHighYCardinalityWithoutColumn) {\n            specM = xAxisOnTopForHighYCardinalityWithoutColumn(specM, schema, encQIndex, opt);\n        }\n        return specM;\n    });\n    return answerSet;\n}\nexports.stylize = stylize;\nfunction smallRangeStepForHighCardinalityOrFacet(specM, schema, encQIndex, opt) {\n    [channel_1.Channel.ROW, channel_1.Channel.Y, channel_1.Channel.COLUMN, channel_1.Channel.X].forEach(function (channel) {\n        encQIndex[channel] = specM.getEncodingQueryByChannel(channel);\n    });\n    var yEncQ = encQIndex[channel_1.Channel.Y];\n    if (yEncQ !== undefined && encoding_1.isFieldQuery(yEncQ)) {\n        if (encQIndex[channel_1.Channel.ROW] ||\n            schema.cardinality(yEncQ) > opt.smallRangeStepForHighCardinalityOrFacet.maxCardinality) {\n            // We check for undefined rather than\n            // yEncQ.scale = yEncQ.scale || {} to cover the case where\n            // yEncQ.scale has been set to false/null.\n            // This prevents us from incorrectly overriding scale and\n            // assigning a rangeStep when scale is set to false.\n            if (yEncQ.scale === undefined) {\n                yEncQ.scale = {};\n            }\n            // We do not want to assign a rangeStep if scale is set to false\n            // and we only apply this if the scale is (or can be) an ordinal scale.\n            var yScaleType = encoding_1.scaleType(yEncQ);\n            if (yEncQ.scale && (yScaleType === undefined || scale_1.hasDiscreteDomain(yScaleType))) {\n                if (!yEncQ.scale.rangeStep) {\n                    yEncQ.scale.rangeStep = 12;\n                }\n            }\n        }\n    }\n    var xEncQ = encQIndex[channel_1.Channel.X];\n    if (encoding_1.isFieldQuery(xEncQ)) {\n        if (encQIndex[channel_1.Channel.COLUMN] ||\n            schema.cardinality(xEncQ) > opt.smallRangeStepForHighCardinalityOrFacet.maxCardinality) {\n            // Just like y, we don't want to do this if scale is null/false\n            if (xEncQ.scale === undefined) {\n                xEncQ.scale = {};\n            }\n            // We do not want to assign a rangeStep if scale is set to false\n            // and we only apply this if the scale is (or can be) an ordinal scale.\n            var xScaleType = encoding_1.scaleType(xEncQ);\n            if (xEncQ.scale && (xScaleType === undefined || scale_1.hasDiscreteDomain(xScaleType))) {\n                if (!xEncQ.scale.rangeStep) {\n                    xEncQ.scale.rangeStep = 12;\n                }\n            }\n        }\n    }\n    return specM;\n}\nexports.smallRangeStepForHighCardinalityOrFacet = smallRangeStepForHighCardinalityOrFacet;\nfunction nominalColorScaleForHighCardinality(specM, schema, encQIndex, opt) {\n    encQIndex[channel_1.Channel.COLOR] = specM.getEncodingQueryByChannel(channel_1.Channel.COLOR);\n    var colorEncQ = encQIndex[channel_1.Channel.COLOR];\n    if (encoding_1.isFieldQuery(colorEncQ) && (colorEncQ !== undefined) && (colorEncQ.type === type_1.Type.NOMINAL) &&\n        (schema.cardinality(colorEncQ) > opt.nominalColorScaleForHighCardinality.maxCardinality)) {\n        if (colorEncQ.scale === undefined) {\n            colorEncQ.scale = {};\n        }\n        if (colorEncQ.scale) {\n            if (!colorEncQ.scale.range) {\n                colorEncQ.scale.range = opt.nominalColorScaleForHighCardinality.palette;\n            }\n        }\n    }\n    return specM;\n}\nexports.nominalColorScaleForHighCardinality = nominalColorScaleForHighCardinality;\nfunction xAxisOnTopForHighYCardinalityWithoutColumn(specM, schema, encQIndex, opt) {\n    [channel_1.Channel.COLUMN, channel_1.Channel.X, channel_1.Channel.Y].forEach(function (channel) {\n        encQIndex[channel] = specM.getEncodingQueryByChannel(channel);\n    });\n    if (encQIndex[channel_1.Channel.COLUMN] === undefined) {\n        var xEncQ = encQIndex[channel_1.Channel.X];\n        var yEncQ = encQIndex[channel_1.Channel.Y];\n        if (encoding_1.isFieldQuery(xEncQ) && encoding_1.isFieldQuery(yEncQ) && yEncQ !== undefined && yEncQ.field && scale_1.hasDiscreteDomain(encoding_1.scaleType(yEncQ))) {\n            if (xEncQ !== undefined) {\n                if (schema.cardinality(yEncQ) > opt.xAxisOnTopForHighYCardinalityWithoutColumn.maxCardinality) {\n                    if (xEncQ.axis === undefined) {\n                        xEncQ.axis = {};\n                    }\n                    if (xEncQ.axis && !xEncQ.axis.orient) {\n                        xEncQ.axis.orient = 'top';\n                    }\n                }\n            }\n        }\n    }\n    return specM;\n}\nexports.xAxisOnTopForHighYCardinalityWithoutColumn = xAxisOnTopForHighYCardinalityWithoutColumn;\n//# sourceMappingURL=stylize.js.map",
    "\"use strict\";\nvar util_1 = require(\"datalib/src/util\");\nvar util_2 = require(\"datalib/src/util\");\nexports.cmp = util_2.cmp;\nexports.keys = util_2.keys;\nexports.duplicate = util_2.duplicate;\nexports.extend = util_2.extend;\nexports.isObject = util_2.isObject;\nexports.isArray = util_2.isArray;\nexports.isBoolean = util_2.isBoolean;\nexports.toMap = util_2.toMap;\nfunction contains(array, item) {\n    return array.indexOf(item) !== -1;\n}\nexports.contains = contains;\n;\nfunction every(arr, f) {\n    for (var i = 0; i < arr.length; i++) {\n        if (!f(arr[i], i)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.every = every;\n;\nfunction forEach(obj, f, thisArg) {\n    if (obj.forEach) {\n        obj.forEach.call(thisArg, f);\n    }\n    else {\n        for (var k in obj) {\n            f.call(thisArg, obj[k], k, obj);\n        }\n    }\n}\nexports.forEach = forEach;\n;\nfunction some(arr, f) {\n    var i = 0, k;\n    for (k in arr) {\n        if (f(arr[k], k, i++)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.some = some;\n;\nfunction nestedMap(array, f) {\n    return array.map(function (a) {\n        if (util_1.isArray(a)) {\n            return nestedMap(a, f);\n        }\n        return f(a);\n    });\n}\nexports.nestedMap = nestedMap;\n/** Returns the array without the elements in item */\nfunction without(array, excludedItems) {\n    return array.filter(function (item) {\n        return !contains(excludedItems, item);\n    });\n}\nexports.without = without;\n//# sourceMappingURL=util.js.map",
    "\"use strict\";\nvar property_1 = require(\"./property\");\nvar util_1 = require(\"./util\");\nvar axis_1 = require(\"vega-lite/build/src/axis\");\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar mark_1 = require(\"vega-lite/build/src/mark\");\nvar scale_1 = require(\"vega-lite/build/src/scale\");\nvar legend_1 = require(\"vega-lite/build/src/legend\");\nvar timeunit_1 = require(\"vega-lite/build/src/timeunit\");\nvar type_1 = require(\"vega-lite/build/src/type\");\nexports.SHORT_WILDCARD = '?';\nfunction isWildcard(prop) {\n    return isShortWildcard(prop) || isWildcardDef(prop);\n}\nexports.isWildcard = isWildcard;\nfunction isShortWildcard(prop) {\n    return prop === exports.SHORT_WILDCARD;\n}\nexports.isShortWildcard = isShortWildcard;\nfunction isWildcardDef(prop) {\n    return prop !== undefined && (!!prop.enum || !!prop.name) && !util_1.isArray(prop);\n}\nexports.isWildcardDef = isWildcardDef;\nfunction initWildcard(prop, defaultName, defaultEnumValues) {\n    return util_1.extend({}, {\n        name: defaultName,\n        enum: defaultEnumValues\n    }, prop === exports.SHORT_WILDCARD ? {} : prop);\n}\nexports.initWildcard = initWildcard;\n/**\n * Initial short names from list of full camelCaseNames.\n * For each camelCaseNames, return unique short names based on initial (e.g., `ccn`)\n */\nfunction initNestedPropName(fullNames) {\n    var index = {};\n    var has = {};\n    var _loop_1 = function (fullName) {\n        var initialIndices = [0];\n        for (var i = 0; i < fullName.length; i++) {\n            if (fullName.charAt(i).toUpperCase() === fullName.charAt(i)) {\n                initialIndices.push(i);\n            }\n        }\n        var shortName = initialIndices.map(function (i) { return fullName.charAt(i); }).join('').toLowerCase();\n        if (!has[shortName]) {\n            index[fullName] = shortName;\n            has[shortName] = true;\n            return \"continue\";\n        }\n        // If duplicate, add last character and try again!\n        if (initialIndices[initialIndices.length - 1] !== fullName.length - 1) {\n            shortName = initialIndices.concat([fullName.length - 1]).map(function (i) { return fullName.charAt(i); }).join('').toLowerCase();\n            if (!has[shortName]) {\n                index[fullName] = shortName;\n                has[shortName] = true;\n                return \"continue\";\n            }\n        }\n        for (var i = 1; !index[fullName]; i++) {\n            var shortNameWithNo = shortName + '_' + i;\n            if (!has[shortNameWithNo]) {\n                index[fullName] = shortNameWithNo;\n                has[shortNameWithNo] = true;\n                break;\n            }\n        }\n    };\n    for (var _i = 0, fullNames_1 = fullNames; _i < fullNames_1.length; _i++) {\n        var fullName = fullNames_1[_i];\n        _loop_1(fullName);\n    }\n    return index;\n}\nexports.DEFAULT_NAME = {\n    mark: 'm',\n    channel: 'c',\n    aggregate: 'a',\n    autoCount: '#',\n    hasFn: 'h',\n    bin: 'b',\n    sort: 'so',\n    scale: 's',\n    axis: 'ax',\n    legend: 'l',\n    timeUnit: 'tu',\n    field: 'f',\n    type: 't',\n    binProps: {\n        maxbins: 'mb',\n        min: 'mi',\n        max: 'ma',\n        base: 'b',\n        step: 's',\n        steps: 'ss',\n        minstep: 'ms',\n        divide: 'd'\n    },\n    sortProps: {\n        field: 'f',\n        op: 'o',\n        order: 'or'\n    },\n    scaleProps: initNestedPropName(scale_1.SCALE_PROPERTIES),\n    axisProps: initNestedPropName(axis_1.AXIS_PROPERTIES),\n    legendProps: initNestedPropName(legend_1.LEGEND_PROPERTIES)\n};\nfunction getDefaultName(prop) {\n    if (property_1.isEncodingNestedProp(prop)) {\n        return exports.DEFAULT_NAME[prop.parent] + '-' + exports.DEFAULT_NAME[prop.parent + 'Props'][prop.child];\n    }\n    if (exports.DEFAULT_NAME[prop]) {\n        return exports.DEFAULT_NAME[prop];\n    }\n    /* istanbul ignore next */\n    throw new Error('Default name undefined for ' + prop);\n}\nexports.getDefaultName = getDefaultName;\nvar DEFAULT_BOOLEAN_ENUM = [false, true];\nvar DEFAULT_BIN_PROPS_ENUM = {\n    maxbins: [5, 10, 20],\n    extent: [undefined],\n    base: [10],\n    step: [undefined],\n    steps: [undefined],\n    minstep: [undefined],\n    divide: [[5, 2]]\n};\nvar DEFAULT_SORT_PROPS = {\n    field: [undefined],\n    op: ['min', 'mean'],\n    order: ['ascending', 'descending']\n};\nvar DEFAULT_SCALE_PROPS_ENUM = {\n    type: [undefined, scale_1.ScaleType.LOG],\n    domain: [undefined],\n    exponent: [1, 2],\n    clamp: DEFAULT_BOOLEAN_ENUM,\n    nice: DEFAULT_BOOLEAN_ENUM,\n    round: DEFAULT_BOOLEAN_ENUM,\n    zero: DEFAULT_BOOLEAN_ENUM,\n    padding: [undefined],\n    paddingInner: [undefined],\n    paddingOuter: [undefined],\n    interpolate: [undefined],\n    range: [undefined],\n    rangeStep: [17, 21],\n    scheme: [undefined],\n};\nvar DEFAULT_AXIS_PROPS_ENUM = {\n    zindex: [1, 0],\n    offset: [undefined],\n    orient: [undefined],\n    values: [undefined],\n    domain: DEFAULT_BOOLEAN_ENUM,\n    grid: DEFAULT_BOOLEAN_ENUM,\n    format: [undefined],\n    labels: DEFAULT_BOOLEAN_ENUM,\n    labelAngle: [undefined],\n    labelMaxLength: [undefined],\n    labelPadding: [undefined],\n    maxExtent: [undefined],\n    minExtent: [undefined],\n    position: [undefined],\n    ticks: DEFAULT_BOOLEAN_ENUM,\n    tickCount: [undefined],\n    tickSize: [undefined],\n    title: [undefined],\n    titleMaxLength: [undefined],\n    titlePadding: [undefined]\n};\nvar DEFAULT_LEGEND_PROPS_ENUM = {\n    entryPadding: [undefined],\n    orient: ['left', 'right'],\n    offset: [undefined],\n    format: [undefined],\n    values: [undefined],\n    tickCount: [undefined],\n    title: [undefined],\n    type: [undefined],\n    zindex: [undefined]\n};\n// Use FullEnumIndex to make sure we have all properties specified here!\nexports.DEFAULT_ENUM_INDEX = {\n    mark: [mark_1.Mark.POINT, mark_1.Mark.BAR, mark_1.Mark.LINE, mark_1.Mark.AREA, mark_1.Mark.TICK],\n    channel: [channel_1.X, channel_1.Y, channel_1.ROW, channel_1.COLUMN, channel_1.SIZE, channel_1.COLOR],\n    aggregate: [undefined, 'mean'],\n    autoCount: DEFAULT_BOOLEAN_ENUM,\n    bin: DEFAULT_BOOLEAN_ENUM,\n    hasFn: DEFAULT_BOOLEAN_ENUM,\n    timeUnit: [undefined, timeunit_1.TimeUnit.YEAR, timeunit_1.TimeUnit.MONTH, timeunit_1.TimeUnit.MINUTES, timeunit_1.TimeUnit.SECONDS],\n    field: [undefined],\n    type: [type_1.Type.NOMINAL, type_1.Type.ORDINAL, type_1.Type.QUANTITATIVE, type_1.Type.TEMPORAL],\n    sort: ['ascending', 'descending'],\n    scale: [true],\n    axis: DEFAULT_BOOLEAN_ENUM,\n    legend: DEFAULT_BOOLEAN_ENUM,\n    binProps: DEFAULT_BIN_PROPS_ENUM,\n    sortProps: DEFAULT_SORT_PROPS,\n    scaleProps: DEFAULT_SCALE_PROPS_ENUM,\n    axisProps: DEFAULT_AXIS_PROPS_ENUM,\n    legendProps: DEFAULT_LEGEND_PROPS_ENUM\n};\n// TODO: rename this to getDefaultEnum\nfunction getDefaultEnumValues(prop, schema, opt) {\n    if (prop === 'field' || (property_1.isEncodingNestedProp(prop) && prop.parent === 'sort' && prop.child === 'field')) {\n        // For field, by default enumerate all fields\n        return schema.fields();\n    }\n    var val;\n    if (property_1.isEncodingNestedProp(prop)) {\n        val = opt.enum[prop.parent + 'Props'][prop.child];\n    }\n    else {\n        val = opt.enum[prop];\n    }\n    if (val !== undefined) {\n        return val;\n    }\n    /* istanbul ignore next */\n    throw new Error('No default enumValues for ' + JSON.stringify(prop));\n}\nexports.getDefaultEnumValues = getDefaultEnumValues;\n//# sourceMappingURL=wildcard.js.map",
    "\"use strict\";\nvar property_1 = require(\"./property\");\nvar propindex_1 = require(\"./propindex\");\nvar WildcardIndex = (function () {\n    function WildcardIndex() {\n        this._mark = undefined;\n        this._encodings = {};\n        this._encodingIndicesByProperty = new propindex_1.PropIndex();\n    }\n    WildcardIndex.prototype.setEncodingProperty = function (index, prop, wildcard) {\n        var encodingsIndex = this._encodings;\n        // Init encoding index and set prop\n        var encIndex = encodingsIndex[index] = encodingsIndex[index] || new propindex_1.PropIndex();\n        encIndex.set(prop, wildcard);\n        // Initialize indicesByProperty[prop] and add index\n        var indicesByProp = this._encodingIndicesByProperty;\n        indicesByProp.set(prop, (indicesByProp.get(prop) || []));\n        indicesByProp.get(prop).push(index);\n        return this;\n    };\n    WildcardIndex.prototype.hasEncodingProperty = function (index, prop) {\n        return !!this._encodings[index] && this._encodings[index].has(prop);\n    };\n    WildcardIndex.prototype.hasProperty = function (prop) {\n        if (property_1.isEncodingProperty(prop)) {\n            return this.encodingIndicesByProperty.has(prop);\n        }\n        if (prop === 'mark') {\n            return !!this.mark;\n        }\n        /* istanbul ignore next */\n        throw new Error('Unimplemented for property ' + prop);\n    };\n    WildcardIndex.prototype.isEmpty = function () {\n        return !this.mark && this.encodingIndicesByProperty.size() === 0;\n    };\n    WildcardIndex.prototype.setMark = function (mark) {\n        this._mark = mark;\n        return this;\n    };\n    Object.defineProperty(WildcardIndex.prototype, \"mark\", {\n        get: function () {\n            return this._mark;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WildcardIndex.prototype, \"encodings\", {\n        get: function () {\n            return this._encodings;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WildcardIndex.prototype, \"encodingIndicesByProperty\", {\n        get: function () {\n            return this._encodingIndicesByProperty;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return WildcardIndex;\n}());\nexports.WildcardIndex = WildcardIndex;\n//# sourceMappingURL=wildcardindex.js.map",
    "",
    "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define('d3-time', ['exports'], factory) :\n  factory((global.d3_time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t0 = new Date;\n  var t1 = new Date;\n  function newInterval(floori, offseti, count, field) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) {\n      interval.count = function(start, end) {\n        t0.setTime(+start), t1.setTime(+end);\n        floori(t0), floori(t1);\n        return Math.floor(count(t0, t1));\n      };\n\n      interval.every = function(step) {\n        step = Math.floor(step);\n        return !isFinite(step) || !(step > 0) ? null\n            : !(step > 1) ? interval\n            : interval.filter(field\n                ? function(d) { return field(d) % step === 0; }\n                : function(d) { return interval.count(0, d) % step === 0; });\n      };\n    }\n\n    return interval;\n  };\n\n  var millisecond = newInterval(function() {\n    // noop\n  }, function(date, step) {\n    date.setTime(+date + step);\n  }, function(start, end) {\n    return end - start;\n  });\n\n  // An optimized implementation for this simple case.\n  millisecond.every = function(k) {\n    k = Math.floor(k);\n    if (!isFinite(k) || !(k > 0)) return null;\n    if (!(k > 1)) return millisecond;\n    return newInterval(function(date) {\n      date.setTime(Math.floor(date / k) * k);\n    }, function(date, step) {\n      date.setTime(+date + step * k);\n    }, function(start, end) {\n      return (end - start) / k;\n    });\n  };\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getSeconds();\n  });\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getMinutes();\n  });\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getHours();\n  });\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  }, function(date) {\n    return date.getDate() - 1;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n  var tuesday = weekday(2);\n  var wednesday = weekday(3);\n  var thursday = weekday(4);\n  var friday = weekday(5);\n  var saturday = weekday(6);\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  }, function(date) {\n    return date.getMonth();\n  });\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  }, function(date) {\n    return date.getFullYear();\n  });\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getUTCSeconds();\n  });\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getUTCMinutes();\n  });\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getUTCHours();\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  }, function(date) {\n    return date.getUTCDate() - 1;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n  var utcTuesday = utcWeekday(2);\n  var utcWednesday = utcWeekday(3);\n  var utcThursday = utcWeekday(4);\n  var utcFriday = utcWeekday(5);\n  var utcSaturday = utcWeekday(6);\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  }, function(date) {\n    return date.getUTCMonth();\n  });\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  }, function(date) {\n    return date.getUTCFullYear();\n  });\n\n  var milliseconds = millisecond.range;\n  var seconds = second.range;\n  var minutes = minute.range;\n  var hours = hour.range;\n  var days = day.range;\n  var sundays = sunday.range;\n  var mondays = monday.range;\n  var tuesdays = tuesday.range;\n  var wednesdays = wednesday.range;\n  var thursdays = thursday.range;\n  var fridays = friday.range;\n  var saturdays = saturday.range;\n  var weeks = sunday.range;\n  var months = month.range;\n  var years = year.range;\n\n  var utcMillisecond = millisecond;\n  var utcMilliseconds = milliseconds;\n  var utcSeconds = utcSecond.range;\n  var utcMinutes = utcMinute.range;\n  var utcHours = utcHour.range;\n  var utcDays = utcDay.range;\n  var utcSundays = utcSunday.range;\n  var utcMondays = utcMonday.range;\n  var utcTuesdays = utcTuesday.range;\n  var utcWednesdays = utcWednesday.range;\n  var utcThursdays = utcThursday.range;\n  var utcFridays = utcFriday.range;\n  var utcSaturdays = utcSaturday.range;\n  var utcWeeks = utcSunday.range;\n  var utcMonths = utcMonth.range;\n  var utcYears = utcYear.range;\n\n  var version = \"0.1.1\";\n\n  exports.version = version;\n  exports.milliseconds = milliseconds;\n  exports.seconds = seconds;\n  exports.minutes = minutes;\n  exports.hours = hours;\n  exports.days = days;\n  exports.sundays = sundays;\n  exports.mondays = mondays;\n  exports.tuesdays = tuesdays;\n  exports.wednesdays = wednesdays;\n  exports.thursdays = thursdays;\n  exports.fridays = fridays;\n  exports.saturdays = saturdays;\n  exports.weeks = weeks;\n  exports.months = months;\n  exports.years = years;\n  exports.utcMillisecond = utcMillisecond;\n  exports.utcMilliseconds = utcMilliseconds;\n  exports.utcSeconds = utcSeconds;\n  exports.utcMinutes = utcMinutes;\n  exports.utcHours = utcHours;\n  exports.utcDays = utcDays;\n  exports.utcSundays = utcSundays;\n  exports.utcMondays = utcMondays;\n  exports.utcTuesdays = utcTuesdays;\n  exports.utcWednesdays = utcWednesdays;\n  exports.utcThursdays = utcThursdays;\n  exports.utcFridays = utcFridays;\n  exports.utcSaturdays = utcSaturdays;\n  exports.utcWeeks = utcWeeks;\n  exports.utcMonths = utcMonths;\n  exports.utcYears = utcYears;\n  exports.millisecond = millisecond;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.sunday = sunday;\n  exports.monday = monday;\n  exports.tuesday = tuesday;\n  exports.wednesday = wednesday;\n  exports.thursday = thursday;\n  exports.friday = friday;\n  exports.saturday = saturday;\n  exports.week = sunday;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcSunday = utcSunday;\n  exports.utcMonday = utcMonday;\n  exports.utcTuesday = utcTuesday;\n  exports.utcWednesday = utcWednesday;\n  exports.utcThursday = utcThursday;\n  exports.utcFriday = utcFriday;\n  exports.utcSaturday = utcSaturday;\n  exports.utcWeek = utcSunday;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n  exports.interval = newInterval;\n\n}));",
    "var util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],\n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n\n    // increase step size if too many bins\n    while (Math.ceil(span/step) > maxb) { step *= base; }\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n",
    "var util = require('./util'),\n    gen = module.exports;\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x >= min && x <= max) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    return x < min ? 0 : x > max ? 1 : (x - min) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? min + p*d : NaN;\n  };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x === Math.floor(x) && x >= a && x < b) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    var v = Math.floor(x);\n    return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? a - 1 + Math.floor(p*d) : NaN;\n  };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    var exp = Math.exp(Math.pow(x-mean, 2) / (-2 * Math.pow(stdev, 2)));\n    return (1 / (stdev * Math.sqrt(2*Math.PI))) * exp;\n  };\n  f.cdf = function(x) {\n    // Approximation from West (2009)\n    // Better Approximations to Cumulative Normal Functions\n    var cd,\n        z = (x - mean) / stdev,\n        Z = Math.abs(z);\n    if (Z > 37) {\n      cd = 0;\n    } else {\n      var sum, exp = Math.exp(-Z*Z/2);\n      if (Z < 7.07106781186547) {\n        sum = 3.52624965998911e-02 * Z + 0.700383064443688;\n        sum = sum * Z + 6.37396220353165;\n        sum = sum * Z + 33.912866078383;\n        sum = sum * Z + 112.079291497871;\n        sum = sum * Z + 221.213596169931;\n        sum = sum * Z + 220.206867912376;\n        cd = exp * sum;\n        sum = 8.83883476483184e-02 * Z + 1.75566716318264;\n        sum = sum * Z + 16.064177579207;\n        sum = sum * Z + 86.7807322029461;\n        sum = sum * Z + 296.564248779674;\n        sum = sum * Z + 637.333633378831;\n        sum = sum * Z + 793.826512519948;\n        sum = sum * Z + 440.413735824752;\n        cd = cd / sum;\n      } else {\n        sum = Z + 0.65;\n        sum = Z + 4 / sum;\n        sum = Z + 3 / sum;\n        sum = Z + 2 / sum;\n        sum = Z + 1 / sum;\n        cd = exp / sum / 2.506628274631;\n      }\n    }\n    return z > 0 ? 1 - cd : cd;\n  };\n  f.icdf = function(p) {\n    // Approximation of Probit function using inverse error function.\n    if (p <= 0 || p >= 1) return NaN;\n    var x = 2*p - 1,\n        v = (8 * (Math.PI - 3)) / (3 * Math.PI * (4-Math.PI)),\n        a = (2 / (Math.PI*v)) + (Math.log(1 - Math.pow(x,2)) / 2),\n        b = Math.log(1 - (x*x)) / v,\n        s = (x > 0 ? 1 : -1) * Math.sqrt(Math.sqrt((a*a) - b) - a);\n    return mean + stdev * Math.SQRT2 * s;\n  };\n  return f;\n};\n\ngen.random.bootstrap = function(domain, smooth) {\n  // Generates a bootstrap sample from a set of observations.\n  // Smooth bootstrapping adds random zero-centered noise to the samples.\n  var val = domain.filter(util.isValid),\n      len = val.length,\n      err = smooth ? gen.random.normal(0, smooth) : null;\n  var f = function() {\n    return val[~~(Math.random()*len)] + (err ? err() : 0);\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  return f;\n};",
    "var util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x == null || x === '' ? null : x + ''; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction fieldNames(datum) {\n  return util.keys(datum);\n}\n\nfunction bracket(fieldName) {\n  return '[' + fieldName + ']';\n}\n\nfunction type(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  var get = fields ? util.identity : (fields = fieldNames(data[0]), bracket);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, get(f)), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  var get = fields ? util.identity : (fields = fieldNames(data[0]), bracket);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, get(f));\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n",
    "var util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\n\nvar stats = module.exports;\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the geometric mean of an array of numbers.\nstats.mean.geometric = function(values, f) {\n  f = util.$(f);\n  var mean = 1, c, n, v, i;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v <= 0) {\n        throw Error(\"Geometric mean only defined for positive values.\");\n      }\n      mean *= v;\n      ++c;\n    }\n  }\n  mean = c > 0 ? Math.pow(mean, 1/c) : 0;\n  return mean;\n};\n\n// Compute the harmonic mean of an array of numbers.\nstats.mean.harmonic = function(values, f) {\n  f = util.$(f);\n  var mean = 0, c, n, v, i;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      mean += 1/v;\n      ++c;\n    }\n  }\n  return c / mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Compute the Cohen's d effect size between two arrays of numbers.\nstats.cohensd = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      x1 = stats.mean(X),\n      x2 = stats.mean(Y),\n      n1 = stats.count.valid(X),\n      n2 = stats.count.valid(Y);\n\n  if ((n1+n2-2) <= 0) {\n    // if both arrays are size 1, or one is empty, there's no effect size\n    return 0;\n  }\n  // pool standard deviation\n  var s1 = stats.variance(X),\n      s2 = stats.variance(Y),\n      s = Math.sqrt((((n1-1)*s1) + ((n2-1)*s2)) / (n1+n2-2));\n  // if there is no variance, there's no effect size\n  return s===0 ? 0 : (x1 - x2) / s;\n};\n\n// Computes the covariance between two arrays of numbers\nstats.covariance = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n = X.length,\n      xm = stats.mean(X),\n      ym = stats.mean(Y),\n      sum = 0, c = 0, i, x, y, vx, vy;\n\n  if (n !== Y.length) {\n    throw Error('Input lengths must match.');\n  }\n\n  for (i=0; i<n; ++i) {\n    x = X[i]; vx = util.isValid(x);\n    y = Y[i]; vy = util.isValid(y);\n    if (vx && vy) {\n      sum += (x-xm) * (y-ym);\n      ++c;\n    } else if (vx || vy) {\n      throw Error('Valid values must align.');\n    }\n  }\n  return sum / (c-1);\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, a) : stats.rank(values),\n      rb = b ? stats.rank(values, b) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Simple linear regression.\n// Returns a \"fit\" object with slope (m), intercept (b),\n// r value (R), and sum-squared residual error (rss).\nstats.linearRegression = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n = X.length,\n      xy = stats.covariance(X, Y), // will throw err if valid vals don't align\n      sx = stats.stdev(X),\n      sy = stats.stdev(Y),\n      slope = xy / (sx*sx),\n      icept = stats.mean(Y) - slope * stats.mean(X),\n      fit = {slope: slope, intercept: icept, R: xy / (sx*sy), rss: 0},\n      res, i;\n\n  for (i=0; i<n; ++i) {\n    if (util.isValid(X[i]) && util.isValid(Y[i])) {\n      res = (slope*X[i] + icept) - Y[i];\n      fit.rss += res * res;\n    }\n  }\n\n  return fit;\n};\n\n// Namespace for bootstrap\nstats.bootstrap = {};\n\n// Construct a bootstrapped confidence interval at a given percentile level\n// Arguments are an array, an optional n (defaults to 1000),\n//  an optional alpha (defaults to 0.05), and an optional smoothing parameter\nstats.bootstrap.ci = function(values, a, b, c, d) {\n  var X, N, alpha, smooth, bs, means, i;\n  if (util.isFunction(a) || util.isString(a)) {\n    X = values.map(util.$(a));\n    N = b;\n    alpha = c;\n    smooth = d;\n  } else {\n    X = values;\n    N = a;\n    alpha = b;\n    smooth = c;\n  }\n  N = N ? +N : 1000;\n  alpha = alpha || 0.05;\n\n  bs = gen.random.bootstrap(X, smooth);\n  for (i=0, means = Array(N); i<N; ++i) {\n    means[i] = stats.mean(bs.samples(X.length));\n  }\n  means.sort(util.numcmp);\n  return [\n    stats.quantile(means, alpha/2),\n    stats.quantile(means, 1-(alpha/2))\n  ];\n};\n\n// Namespace for z-tests\nstats.z = {};\n\n// Construct a z-confidence interval at a given significance level\n// Arguments are an array and an optional alpha (defaults to 0.05).\nstats.z.ci = function(values, a, b) {\n  var X = values, alpha = a;\n  if (util.isFunction(a) || util.isString(a)) {\n    X = values.map(util.$(a));\n    alpha = b;\n  }\n  alpha = alpha || 0.05;\n\n  var z = alpha===0.05 ? 1.96 : gen.random.normal(0, 1).icdf(1-(alpha/2)),\n      mu = stats.mean(X),\n      SE = stats.stdev(X) / Math.sqrt(stats.count.valid(X));\n  return [mu - (z*SE), mu + (z*SE)];\n};\n\n// Perform a z-test of means. Returns the p-value.\n// If a single array is provided, performs a one-sample location test.\n// If two arrays or a table and two accessors are provided, performs\n// a two-sample location test. A paired test is performed if specified\n// by the options hash.\n// The options hash format is: {paired: boolean, nullh: number}.\n// http://en.wikipedia.org/wiki/Z-test\n// http://en.wikipedia.org/wiki/Paired_difference_test\nstats.z.test = function(values, a, b, opt) {\n  if (util.isFunction(b) || util.isString(b)) { // table and accessors\n    return (opt && opt.paired ? ztestP : ztest2)(opt, values, a, b);\n  } else if (util.isArray(a)) { // two arrays\n    return (b && b.paired ? ztestP : ztest2)(b, values, a);\n  } else if (util.isFunction(a) || util.isString(a)) {\n    return ztest1(b, values, a); // table and accessor\n  } else {\n    return ztest1(a, values); // one array\n  }\n};\n\n// Perform a z-test of means. Returns the p-value.\n// Assuming we have a list of values, and a null hypothesis. If no null\n// hypothesis, assume our null hypothesis is mu=0.\nfunction ztest1(opt, X, f) {\n  var nullH = opt && opt.nullh || 0,\n      gaussian = gen.random.normal(0, 1),\n      mu = stats.mean(X,f),\n      SE = stats.stdev(X,f) / Math.sqrt(stats.count.valid(X,f));\n\n  if (SE===0) {\n    // Test not well defined when standard error is 0.\n    return (mu - nullH) === 0 ? 1 : 0;\n  }\n  // Two-sided, so twice the one-sided cdf.\n  var z = (mu - nullH) / SE;\n  return 2 * gaussian.cdf(-Math.abs(z));\n}\n\n// Perform a two sample paired z-test of means. Returns the p-value.\nfunction ztestP(opt, values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n1 = stats.count(X),\n      n2 = stats.count(Y),\n      diffs = Array(), i;\n\n  if (n1 !== n2) {\n    throw Error('Array lengths must match.');\n  }\n  for (i=0; i<n1; ++i) {\n    // Only valid differences should contribute to the test statistic\n    if (util.isValid(X[i]) && util.isValid(Y[i])) {\n      diffs.push(X[i] - Y[i]);\n    }\n  }\n  return stats.z.test(diffs, opt && opt.nullh || 0);\n}\n\n// Perform a two sample z-test of means. Returns the p-value.\nfunction ztest2(opt, values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n1 = stats.count.valid(X),\n      n2 = stats.count.valid(Y),\n      gaussian = gen.random.normal(0, 1),\n      meanDiff = stats.mean(X) - stats.mean(Y) - (opt && opt.nullh || 0),\n      SE = Math.sqrt(stats.variance(X)/n1 + stats.variance(Y)/n2);\n\n  if (SE===0) {\n    // Not well defined when pooled standard error is 0.\n    return meanDiff===0 ? 1 : 0;\n  }\n  // Two-tailed, so twice the one-sided cdf.\n  var z = meanDiff / SE;\n  return 2 * gaussian.cdf(-Math.abs(z));\n}\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance]\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n",
    "var d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);",
    "var u = module.exports;\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (typeof Buffer === 'function' && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\n// parse a date with optional d3.time-format format\nu.date = function(s, format) {\n  var d = format ? format : Date;\n  return s == null || s === '' ? null : d.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) || u.isString(x) ?\n      // Output valid JSON and JS source strings.\n      // See http://timelessrepo.com/json-isnt-a-javascript-subset\n      JSON.stringify(x).replace('\\u2028','\\\\u2028').replace('\\u2029', '\\\\u2029')\n    : x;\n};\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  /* jshint evil: true */\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, Function('x', 'return x[' + u.field(f).map(u.str).join('][') + '];'));\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a, b) {\n    var i, n, f, c;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i];\n      c = u.cmp(f(a), f(b));\n      if (c) return c * sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  return (a < b || a == null) && b != null ? -1 :\n    (a > b || b == null) && a != null ? 1 :\n    ((b = b instanceof Date ? +b : b),\n     (a = a instanceof Date ? +a : a)) !== a && b === b ? -1 :\n    b !== b && a === a ? 1 : 0;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n// permutes an array using a Knuth shuffle\nu.permute = function(a) {\n  var m = a.length,\n      swap,\n      i;\n\n  while (m) {\n    i = Math.floor(Math.random() * m--);\n    swap = a[m];\n    a[m] = a[i];\n    a[i] = swap;\n  }\n};\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n",
    "var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');\n\nmodule.exports = function (obj, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var space = opts.space || '';\n    if (typeof space === 'number') space = Array(space+1).join(' ');\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n    var replacer = opts.replacer || function(key, value) { return value; };\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (parent, key, node, level) {\n        var indent = space ? ('\\n' + new Array(level + 1).join(space)) : '';\n        var colonSeparator = space ? ': ' : ':';\n\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        node = replacer.call(parent, key, node);\n\n        if (node === undefined) {\n            return;\n        }\n        if (typeof node !== 'object' || node === null) {\n            return json.stringify(node);\n        }\n        if (isArray(node)) {\n            var out = [];\n            for (var i = 0; i < node.length; i++) {\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\n                out.push(indent + space + item);\n            }\n            return '[' + out.join(',') + indent + ']';\n        }\n        else {\n            if (seen.indexOf(node) !== -1) {\n                if (cycles) return json.stringify('__cycle__');\n                throw new TypeError('Converting circular structure to JSON');\n            }\n            else seen.push(node);\n\n            var keys = objectKeys(node).sort(cmp && cmp(node));\n            var out = [];\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var value = stringify(node, key, node[key], level+1);\n\n                if(!value) continue;\n\n                var keyValue = json.stringify(key)\n                    + colonSeparator\n                    + value;\n                ;\n                out.push(indent + space + keyValue);\n            }\n            seen.splice(seen.indexOf(node), 1);\n            return '{' + out.join(',') + indent + '}';\n        }\n    })({ '': obj }, '', obj, 0);\n};\n\nvar isArray = Array.isArray || function (x) {\n    return {}.toString.call(x) === '[object Array]';\n};\n\nvar objectKeys = Object.keys || function (obj) {\n    var has = Object.prototype.hasOwnProperty || function () { return true };\n    var keys = [];\n    for (var key in obj) {\n        if (has.call(obj, key)) keys.push(key);\n    }\n    return keys;\n};\n",
    "exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n",
    "var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n",
    "var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AGGREGATE_OPS = [\n    'values',\n    'count',\n    'valid',\n    'missing',\n    'distinct',\n    'sum',\n    'mean',\n    'average',\n    'variance',\n    'variancep',\n    'stdev',\n    'stdevp',\n    'median',\n    'q1',\n    'q3',\n    'modeskew',\n    'min',\n    'max',\n    'argmin',\n    'argmax',\n];\n/** Additive-based aggregation operations.  These can be applied to stack. */\nexports.SUM_OPS = [\n    'count',\n    'sum',\n    'distinct',\n    'valid',\n    'missing'\n];\n/**\n * Aggregation operators that always produce values within the range [domainMin, domainMax].\n */\nexports.SHARED_DOMAIN_OPS = [\n    'mean',\n    'average',\n    'median',\n    'q1',\n    'q3',\n    'min',\n    'max',\n];\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWdncmVnYXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2FnZ3JlZ2F0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQU1hLFFBQUEsYUFBYSxHQUFrQjtJQUN4QyxRQUFRO0lBQ1IsT0FBTztJQUNQLE9BQU87SUFDUCxTQUFTO0lBQ1QsVUFBVTtJQUNWLEtBQUs7SUFDTCxNQUFNO0lBQ04sU0FBUztJQUNULFVBQVU7SUFDVixXQUFXO0lBQ1gsT0FBTztJQUNQLFFBQVE7SUFDUixRQUFRO0lBQ1IsSUFBSTtJQUNKLElBQUk7SUFDSixVQUFVO0lBQ1YsS0FBSztJQUNMLEtBQUs7SUFDTCxRQUFRO0lBQ1IsUUFBUTtDQUNYLENBQUM7QUFFRiw2RUFBNkU7QUFDaEUsUUFBQSxPQUFPLEdBQWtCO0lBQ2xDLE9BQU87SUFDUCxLQUFLO0lBQ0wsVUFBVTtJQUNWLE9BQU87SUFDUCxTQUFTO0NBQ1osQ0FBQztBQUVGOztHQUVHO0FBQ1UsUUFBQSxpQkFBaUIsR0FBa0I7SUFDNUMsTUFBTTtJQUNOLFNBQVM7SUFDVCxRQUFRO0lBQ1IsSUFBSTtJQUNKLElBQUk7SUFDSixLQUFLO0lBQ0wsS0FBSztDQUNSLENBQUMifQ==",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultAxisConfig = {\n    labelMaxLength: 25,\n};\nexports.AXIS_PROPERTIES = [\n    'domain', 'format', 'grid', 'labelPadding', 'labels', 'maxExtent', 'minExtent', 'offset', 'orient', 'position', 'tickCount', 'ticks', 'tickSize', 'title', 'titlePadding', 'values', 'zindex'\n];\nexports.VL_ONLY_AXIS_PROPERTIES = ['labelMaxLength'];\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXhpcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9heGlzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBWWEsUUFBQSxpQkFBaUIsR0FBZTtJQUMzQyxjQUFjLEVBQUUsRUFBRTtDQUNuQixDQUFDO0FBeUVXLFFBQUEsZUFBZSxHQUFrQjtJQUM1QyxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxRQUFRLEVBQUUsUUFBUTtDQUM5TCxDQUFDO0FBRVcsUUFBQSx1QkFBdUIsR0FBNEIsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDIn0=",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar channel_1 = require(\"./channel\");\nfunction autoMaxBins(channel) {\n    switch (channel) {\n        case channel_1.ROW:\n        case channel_1.COLUMN:\n        case channel_1.SIZE:\n        // Facets and Size shouldn't have too many bins\n        // We choose 6 like shape to simplify the rule\n        case channel_1.SHAPE:\n            return 6; // Vega's \"shape\" has 6 distinct values\n        default:\n            return 10;\n    }\n}\nexports.autoMaxBins = autoMaxBins;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmluLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2Jpbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHFDQUE0RDtBQTBDNUQscUJBQTRCLE9BQWdCO0lBQzFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFDaEIsS0FBSyxhQUFHLENBQUM7UUFDVCxLQUFLLGdCQUFNLENBQUM7UUFDWixLQUFLLGNBQUksQ0FBQztRQUNSLCtDQUErQztRQUMvQyw4Q0FBOEM7UUFDaEQsS0FBSyxlQUFLO1lBQ1IsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLHVDQUF1QztRQUNuRDtZQUNFLE1BQU0sQ0FBQyxFQUFFLENBQUM7SUFDZCxDQUFDO0FBQ0gsQ0FBQztBQVpELGtDQVlDIn0=",
    "/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar scale_1 = require(\"./scale\");\nvar util_1 = require(\"./util\");\nvar Channel;\n(function (Channel) {\n    // Facet\n    Channel.ROW = 'row';\n    Channel.COLUMN = 'column';\n    // Position\n    Channel.X = 'x';\n    Channel.Y = 'y';\n    Channel.X2 = 'x2';\n    Channel.Y2 = 'y2';\n    // Mark property with scale\n    Channel.COLOR = 'color';\n    Channel.SHAPE = 'shape';\n    Channel.SIZE = 'size';\n    Channel.OPACITY = 'opacity';\n    // Non-scale channel\n    Channel.TEXT = 'text';\n    Channel.ORDER = 'order';\n    Channel.DETAIL = 'detail';\n})(Channel = exports.Channel || (exports.Channel = {}));\nexports.X = Channel.X;\nexports.Y = Channel.Y;\nexports.X2 = Channel.X2;\nexports.Y2 = Channel.Y2;\nexports.ROW = Channel.ROW;\nexports.COLUMN = Channel.COLUMN;\nexports.SHAPE = Channel.SHAPE;\nexports.SIZE = Channel.SIZE;\nexports.COLOR = Channel.COLOR;\nexports.TEXT = Channel.TEXT;\nexports.DETAIL = Channel.DETAIL;\nexports.ORDER = Channel.ORDER;\nexports.OPACITY = Channel.OPACITY;\nexports.CHANNELS = [exports.X, exports.Y, exports.X2, exports.Y2, exports.ROW, exports.COLUMN, exports.SIZE, exports.SHAPE, exports.COLOR, exports.ORDER, exports.OPACITY, exports.TEXT, exports.DETAIL];\n// CHANNELS without COLUMN, ROW\nexports.UNIT_CHANNELS = [exports.X, exports.Y, exports.X2, exports.Y2, exports.SIZE, exports.SHAPE, exports.COLOR, exports.ORDER, exports.OPACITY, exports.TEXT, exports.DETAIL];\n// UNIT_CHANNELS without X2, Y2, ORDER, DETAIL, TEXT\nexports.UNIT_SCALE_CHANNELS = [exports.X, exports.Y, exports.SIZE, exports.SHAPE, exports.COLOR, exports.OPACITY];\n// UNIT_SCALE_CHANNELS with ROW, COLUMN\nexports.SCALE_CHANNELS = [exports.X, exports.Y, exports.SIZE, exports.SHAPE, exports.COLOR, exports.OPACITY, exports.ROW, exports.COLUMN];\n// UNIT_CHANNELS without X, Y, X2, Y2;\nexports.NONSPATIAL_CHANNELS = [exports.SIZE, exports.SHAPE, exports.COLOR, exports.ORDER, exports.OPACITY, exports.TEXT, exports.DETAIL];\n// UNIT_SCALE_CHANNELS without X, Y;\nexports.NONSPATIAL_SCALE_CHANNELS = [exports.SIZE, exports.SHAPE, exports.COLOR, exports.OPACITY];\n/** Channels that can serve as groupings for stacked charts. */\nexports.STACK_GROUP_CHANNELS = [exports.COLOR, exports.DETAIL, exports.ORDER, exports.OPACITY, exports.SIZE];\n;\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nfunction supportMark(channel, mark) {\n    return mark in getSupportedMark(channel);\n}\nexports.supportMark = supportMark;\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to boolean values.\n */\nfunction getSupportedMark(channel) {\n    switch (channel) {\n        case exports.X:\n        case exports.Y:\n        case exports.COLOR:\n        case exports.DETAIL:\n        case exports.ORDER: // TODO: revise (order might not support rect, which is not stackable?)\n        case exports.OPACITY:\n        case exports.ROW:\n        case exports.COLUMN:\n            return {\n                point: true, tick: true, rule: true, circle: true, square: true,\n                bar: true, rect: true, line: true, area: true, text: true\n            };\n        case exports.X2:\n        case exports.Y2:\n            return {\n                rule: true, bar: true, rect: true, area: true\n            };\n        case exports.SIZE:\n            return {\n                point: true, tick: true, rule: true, circle: true, square: true,\n                bar: true, text: true, line: true\n            };\n        case exports.SHAPE:\n            return { point: true };\n        case exports.TEXT:\n            return { text: true };\n    }\n    return {};\n}\nexports.getSupportedMark = getSupportedMark;\nfunction hasScale(channel) {\n    return !util_1.contains([exports.DETAIL, exports.TEXT, exports.ORDER], channel);\n}\nexports.hasScale = hasScale;\n// Position does not work with ordinal (lookup) scale and sequential (which is only for color)\nvar POSITION_SCALE_TYPE_INDEX = util_1.toSet(util_1.without(scale_1.SCALE_TYPES, ['ordinal', 'sequential']));\nfunction supportScaleType(channel, scaleType) {\n    switch (channel) {\n        case exports.ROW:\n        case exports.COLUMN:\n            return scaleType === 'band'; // row / column currently supports band only\n        case exports.X:\n        case exports.Y:\n        case exports.SIZE: // TODO: size and opacity can support ordinal with more modification\n        case exports.OPACITY:\n            // Although it generally doesn't make sense to use band with size and opacity,\n            // it can also work since we use band: 0.5 to get midpoint.\n            return scaleType in POSITION_SCALE_TYPE_INDEX;\n        case exports.COLOR:\n            return scaleType !== 'band'; // band does not make sense with color\n        case exports.SHAPE:\n            return scaleType === 'ordinal'; // shape = lookup only\n    }\n    /* istanbul ignore next: it should never reach here */\n    return false;\n}\nexports.supportScaleType = supportScaleType;\nfunction rangeType(channel) {\n    switch (channel) {\n        case exports.X:\n        case exports.Y:\n        case exports.SIZE:\n        case exports.OPACITY:\n            return 'continuous';\n        case exports.ROW:\n        case exports.COLUMN:\n        case exports.SHAPE:\n            return 'discrete';\n        // Color can be either continuous or discrete, depending on scale type.\n        case exports.COLOR:\n            return 'flexible';\n        // No scale, no range type.\n        case exports.X2:\n        case exports.Y2:\n        case exports.DETAIL:\n        case exports.TEXT:\n        case exports.ORDER:\n            return undefined;\n    }\n    /* istanbul ignore next: should never reach here. */\n    throw new Error('getSupportedRole not implemented for ' + channel);\n}\nexports.rangeType = rangeType;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhbm5lbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jaGFubmVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRzs7O0FBTUgsaUNBQStDO0FBQy9DLCtCQUFnRDtBQUVoRCxJQUFpQixPQUFPLENBcUJ2QjtBQXJCRCxXQUFpQixPQUFPO0lBQ3RCLFFBQVE7SUFDSyxXQUFHLEdBQVUsS0FBSyxDQUFDO0lBQ25CLGNBQU0sR0FBYSxRQUFRLENBQUM7SUFFekMsV0FBVztJQUNFLFNBQUMsR0FBUSxHQUFHLENBQUM7SUFDYixTQUFDLEdBQVEsR0FBRyxDQUFDO0lBQ2IsVUFBRSxHQUFTLElBQUksQ0FBQztJQUNoQixVQUFFLEdBQVMsSUFBSSxDQUFDO0lBRTdCLDJCQUEyQjtJQUNkLGFBQUssR0FBWSxPQUFPLENBQUM7SUFDekIsYUFBSyxHQUFZLE9BQU8sQ0FBQztJQUN6QixZQUFJLEdBQVcsTUFBTSxDQUFDO0lBQ3RCLGVBQU8sR0FBYyxTQUFTLENBQUM7SUFFNUMsb0JBQW9CO0lBQ1AsWUFBSSxHQUFXLE1BQU0sQ0FBQztJQUN0QixhQUFLLEdBQVksT0FBTyxDQUFDO0lBQ3pCLGNBQU0sR0FBYSxRQUFRLENBQUM7QUFDM0MsQ0FBQyxFQXJCZ0IsT0FBTyxHQUFQLGVBQU8sS0FBUCxlQUFPLFFBcUJ2QjtBQUlZLFFBQUEsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDZCxRQUFBLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQ2QsUUFBQSxFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQztBQUNoQixRQUFBLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDO0FBQ2hCLFFBQUEsR0FBRyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUM7QUFDbEIsUUFBQSxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQztBQUN4QixRQUFBLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFD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",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log = require(\"../../log\");\nvar channel_1 = require(\"../../channel\");\nvar timeunit_1 = require(\"../../timeunit\");\nvar util = require(\"../../util\");\n/**\n * Determine if there is a specified scale type and if it is appropriate,\n * or determine default type if type is unspecified or inappropriate.\n */\n// NOTE: CompassQL uses this method.\nfunction type(specifiedType, channel, fieldDef, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig) {\n    var defaultScaleType = defaultType(channel, fieldDef, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);\n    if (!channel_1.hasScale(channel)) {\n        // There is no scale for these channels\n        return null;\n    }\n    if (specifiedType !== undefined) {\n        // for binned fields we don't allow overriding the default scale\n        if (fieldDef.bin) {\n            // TODO: generalize this as a method in fieldDef that determines scale type support for a fieldDef (looking at functions and type)\n            log.warn(log.message.cannotOverrideBinScaleType(channel, defaultScaleType));\n            return defaultScaleType;\n        }\n        // Check if explicitly specified scale type is supported by the channel\n        if (channel_1.supportScaleType(channel, specifiedType)) {\n            return specifiedType;\n        }\n        else {\n            log.warn(log.message.scaleTypeNotWorkWithChannel(channel, specifiedType, defaultScaleType));\n            return defaultScaleType;\n        }\n    }\n    return defaultScaleType;\n}\nexports.default = type;\n/**\n * Determine appropriate default scale type.\n */\nfunction defaultType(channel, fieldDef, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig) {\n    if (util.contains(['row', 'column'], channel)) {\n        return 'band';\n    }\n    switch (fieldDef.type) {\n        case 'nominal':\n            if (channel === 'color' || channel_1.rangeType(channel) === 'discrete') {\n                return 'ordinal';\n            }\n            return discreteToContinuousType(channel, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);\n        case 'ordinal':\n            if (channel === 'color') {\n                return 'ordinal';\n            }\n            else if (channel_1.rangeType(channel) === 'discrete') {\n                log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));\n                return 'ordinal';\n            }\n            return discreteToContinuousType(channel, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);\n        case 'temporal':\n            if (channel === 'color') {\n                // Always use `sequential` as the default color scale for continuous data\n                // since it supports both array range and scheme range.\n                return 'sequential';\n            }\n            else if (channel_1.rangeType(channel) === 'discrete') {\n                log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal'));\n                // TODO: consider using quantize (equivalent to binning) once we have it\n                return 'ordinal';\n            }\n            if (timeunit_1.isDiscreteByDefault(fieldDef.timeUnit)) {\n                return discreteToContinuousType(channel, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);\n            }\n            return 'time';\n        case 'quantitative':\n            if (channel === 'color') {\n                if (fieldDef.bin) {\n                    return 'bin-ordinal';\n                }\n                // Use `sequential` as the default color scale for continuous data\n                // since it supports both array range and scheme range.\n                return 'sequential';\n            }\n            else if (channel_1.rangeType(channel) === 'discrete') {\n                log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative'));\n                // TODO: consider using quantize (equivalent to binning) once we have it\n                return 'ordinal';\n            }\n            if (fieldDef.bin) {\n                return 'bin-linear';\n            }\n            return 'linear';\n    }\n    /* istanbul ignore next: should never reach this */\n    throw new Error(log.message.invalidFieldType(fieldDef.type));\n}\n/**\n * Determines default scale type for nominal/ordinal field.\n * @returns BAND or POINT scale based on channel, mark, and rangeStep\n */\nfunction discreteToContinuousType(channel, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig) {\n    if (util.contains(['x', 'y'], channel)) {\n        if (mark === 'rect') {\n            // The rect mark should fit into a band.\n            return 'band';\n        }\n        if (mark === 'bar') {\n            // For bar, use band only if there is no rangeStep since we need to use band for fit mode.\n            // However, for non-fit mode, point scale provides better center position.\n            if (haveRangeStep(hasTopLevelSize, specifiedRangeStep, scaleConfig)) {\n                return 'point';\n            }\n            return 'band';\n        }\n    }\n    // Otherwise, use ordinal point scale so we can easily get center positions of the marks.\n    return 'point';\n}\nfunction haveRangeStep(hasTopLevelSize, specifiedRangeStep, scaleConfig) {\n    if (hasTopLevelSize) {\n        // if topLevelSize is provided, rangeStep will be dropped.\n        return false;\n    }\n    if (specifiedRangeStep !== undefined) {\n        return specifiedRangeStep !== null;\n    }\n    return !!scaleConfig.rangeStep;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21waWxlL3NjYWxlL3R5cGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwrQkFBaUM7QUFFakMseUNBQTZFO0FBRzdFLDJDQUFtRDtBQUVuRCxpQ0FBbUM7QUFLbkM7OztHQUdHO0FBQ0gsb0NBQW9DO0FBQ3BDLGNBQ0UsYUFBd0IsRUFBRSxPQUFnQixFQUFFLFFBQWtCLEVBQUUsSUFBVSxFQUMxRSxlQUF3QixFQUFFLGtCQUEwQixFQUFFLFdBQXdCO0lBRTlFLElBQU0sZ0JBQWdCLEdBQUcsV0FBVyxDQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLGVBQWUsRUFBRSxrQkFBa0IsRUFBRSxXQUFXLENBQUMsQ0FBQztJQUVoSCxFQUFFLENBQUMsQ0FBQyxDQUFDLGtCQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZCLHVDQUF1QztRQUN2QyxNQUFNLENBQUMsSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUNELEVBQUUsQ0FBQyxDQUFDLGFBQWEsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQ2hDLGdFQUFnRTtRQUNoRSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNqQixrSUFBa0k7WUFDbEksR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLDBCQUEwQixDQUFDLE9BQU8sRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7WUFDNUUsTUFBTSxDQUFDLGdCQUFnQixDQUFDO1FBQzFCLENBQUM7UUFFRCx1RUFBdUU7UUFDdkUsRUFBRSxDQUFDLENBQUMsMEJBQWdCLENBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM3QyxNQUFNLENBQUMsYUFBYSxDQUFDO1FBQ3ZCLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLEdBQUcsQ0FB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",
    "// DateTime definition object\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nvar log = require(\"./log\");\n/*\n * A designated year that starts on Sunday.\n */\nvar SUNDAY_YEAR = 2006;\nfunction isDateTime(o) {\n    return !!o && (!!o.year || !!o.quarter || !!o.month || !!o.date || !!o.day ||\n        !!o.hours || !!o.minutes || !!o.seconds || !!o.milliseconds);\n}\nexports.isDateTime = isDateTime;\nexports.MONTHS = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];\nexports.SHORT_MONTHS = exports.MONTHS.map(function (m) { return m.substr(0, 3); });\nexports.DAYS = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\nexports.SHORT_DAYS = exports.DAYS.map(function (d) { return d.substr(0, 3); });\nfunction normalizeQuarter(q) {\n    if (util_1.isNumber(q)) {\n        if (q > 4) {\n            log.warn(log.message.invalidTimeUnit('quarter', q));\n        }\n        // We accept 1-based quarter, so need to readjust to 0-based quarter\n        return (q - 1) + '';\n    }\n    else {\n        // Invalid quarter\n        throw new Error(log.message.invalidTimeUnit('quarter', q));\n    }\n}\nfunction normalizeMonth(m) {\n    if (util_1.isNumber(m)) {\n        // We accept 1-based month, so need to readjust to 0-based month\n        return (m - 1) + '';\n    }\n    else {\n        var lowerM = m.toLowerCase();\n        var monthIndex = exports.MONTHS.indexOf(lowerM);\n        if (monthIndex !== -1) {\n            return monthIndex + ''; // 0 for january, ...\n        }\n        var shortM = lowerM.substr(0, 3);\n        var shortMonthIndex = exports.SHORT_MONTHS.indexOf(shortM);\n        if (shortMonthIndex !== -1) {\n            return shortMonthIndex + '';\n        }\n        // Invalid month\n        throw new Error(log.message.invalidTimeUnit('month', m));\n    }\n}\nfunction normalizeDay(d) {\n    if (util_1.isNumber(d)) {\n        // mod so that this can be both 0-based where 0 = sunday\n        // and 1-based where 7=sunday\n        return (d % 7) + '';\n    }\n    else {\n        var lowerD = d.toLowerCase();\n        var dayIndex = exports.DAYS.indexOf(lowerD);\n        if (dayIndex !== -1) {\n            return dayIndex + ''; // 0 for january, ...\n        }\n        var shortD = lowerD.substr(0, 3);\n        var shortDayIndex = exports.SHORT_DAYS.indexOf(shortD);\n        if (shortDayIndex !== -1) {\n            return shortDayIndex + '';\n        }\n        // Invalid day\n        throw new Error(log.message.invalidTimeUnit('day', d));\n    }\n}\nfunction timestamp(d, normalize) {\n    var date = new Date(0, 0, 1, 0, 0, 0, 0); // start with uniform date\n    // FIXME support UTC\n    if (d.day !== undefined) {\n        if (util_1.keys(d).length > 1) {\n            log.warn(log.message.droppedDay(d));\n            d = util_1.duplicate(d);\n            delete d.day;\n        }\n        else {\n            // Use a year that has 1/1 as Sunday so we can setDate below\n            date.setFullYear(SUNDAY_YEAR);\n            var day = normalize ? normalizeDay(d.day) : d.day;\n            date.setDate(+day + 1); // +1 since date start at 1 in JS\n        }\n    }\n    if (d.year !== undefined) {\n        date.setFullYear(d.year);\n    }\n    if (d.quarter !== undefined) {\n        var quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;\n        date.setMonth(+quarter * 3);\n    }\n    if (d.month !== undefined) {\n        var month = normalize ? normalizeMonth(d.month) : d.month;\n        date.setMonth(+month);\n    }\n    if (d.date !== undefined) {\n        date.setDate(d.date);\n    }\n    if (d.hours !== undefined) {\n        date.setHours(d.hours);\n    }\n    if (d.minutes !== undefined) {\n        date.setMinutes(d.minutes);\n    }\n    if (d.seconds !== undefined) {\n        date.setSeconds(d.seconds);\n    }\n    if (d.milliseconds !== undefined) {\n        date.setMilliseconds(d.milliseconds);\n    }\n    return date.getTime();\n}\nexports.timestamp = timestamp;\n/**\n * Return Vega Expression for a particular date time.\n * @param d\n * @param normalize whether to normalize quarter, month, day.\n */\nfunction dateTimeExpr(d, normalize) {\n    if (normalize === void 0) { normalize = false; }\n    var units = [];\n    if (normalize && d.day !== undefined) {\n        if (util_1.keys(d).length > 1) {\n            log.warn(log.message.droppedDay(d));\n            d = util_1.duplicate(d);\n            delete d.day;\n        }\n    }\n    if (d.year !== undefined) {\n        units.push(d.year);\n    }\n    else if (d.day !== undefined) {\n        // Set year to 2006 for working with day since January 1 2006 is a Sunday\n        units.push(SUNDAY_YEAR);\n    }\n    else {\n        units.push(0);\n    }\n    if (d.month !== undefined) {\n        var month = normalize ? normalizeMonth(d.month) : d.month;\n        units.push(month);\n    }\n    else if (d.quarter !== undefined) {\n        var quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;\n        units.push(quarter + '*3');\n    }\n    else {\n        units.push(0); // months start at zero in JS\n    }\n    if (d.date !== undefined) {\n        units.push(d.date);\n    }\n    else if (d.day !== undefined) {\n        // HACK: Day only works as a standalone unit\n        // This is only correct because we always set year to 2006 for day\n        var day = normalize ? normalizeDay(d.day) : d.day;\n        units.push(day + '+1');\n    }\n    else {\n        units.push(1); // Date starts at 1 in JS\n    }\n    // Note: can't use TimeUnit enum here as importing it will create\n    // circular dependency problem!\n    for (var _i = 0, _a = ['hours', 'minutes', 'seconds', 'milliseconds']; _i < _a.length; _i++) {\n        var timeUnit = _a[_i];\n        if (d[timeUnit] !== undefined) {\n            units.push(d[timeUnit]);\n        }\n        else {\n            units.push(0);\n        }\n    }\n    return 'datetime(' + units.join(', ') + ')';\n}\nexports.dateTimeExpr = dateTimeExpr;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXRpbWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZGF0ZXRpbWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsNkJBQTZCOzs7QUFFN0IsK0JBQWlEO0FBQ2pELDJCQUE2QjtBQUU3Qjs7R0FFRztBQUNILElBQU0sV0FBVyxHQUFHLElBQUksQ0FBQztBQXdHekIsb0JBQTJCLENBQU07SUFDL0IsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUc7UUFDeEUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNqRSxDQUFDO0FBSEQsZ0NBR0M7QUFFWSxRQUFBLE1BQU0sR0FBRyxDQUFDLFNBQVMsRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUM7QUFDcEksUUFBQSxZQUFZLEdBQUcsY0FBTSxDQUFDLEdBQUcsQ0FBQyxVQUFDLENBQUMsSUFBSyxPQUFBLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFkLENBQWMsQ0FBQyxDQUFDO0FBRWpELFFBQUEsSUFBSSxHQUFHLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxRQUFR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",
    "// utility for a field definition object\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar channel_1 = require(\"./channel\");\nvar log = require(\"./log\");\nvar timeunit_1 = require(\"./timeunit\");\nvar type_1 = require(\"./type\");\n;\nfunction isFieldDef(channelDef) {\n    return channelDef && (!!channelDef['field'] || channelDef['aggregate'] === 'count');\n}\nexports.isFieldDef = isFieldDef;\nfunction isValueDef(channelDef) {\n    return channelDef && 'value' in channelDef && channelDef['value'] !== undefined;\n}\nexports.isValueDef = isValueDef;\nfunction field(fieldDef, opt) {\n    if (opt === void 0) { opt = {}; }\n    var field = fieldDef.field;\n    var prefix = opt.prefix;\n    var suffix = opt.suffix;\n    if (isCount(fieldDef)) {\n        field = 'count_*';\n    }\n    else {\n        var fn = undefined;\n        if (!opt.nofn) {\n            if (fieldDef.bin) {\n                fn = 'bin';\n                suffix = opt.binSuffix;\n            }\n            else if (fieldDef.aggregate) {\n                fn = String(opt.aggregate || fieldDef.aggregate);\n            }\n            else if (fieldDef.timeUnit) {\n                fn = String(fieldDef.timeUnit);\n            }\n        }\n        if (!!fn) {\n            field = fn + \"_\" + field;\n        }\n    }\n    if (!!suffix) {\n        field = field + \"_\" + suffix;\n    }\n    if (!!prefix) {\n        field = prefix + \"_\" + field;\n    }\n    if (opt.datum) {\n        field = \"datum[\\\"\" + field + \"\\\"]\";\n    }\n    return field;\n}\nexports.field = field;\nfunction isDiscrete(fieldDef) {\n    switch (fieldDef.type) {\n        case 'nominal':\n        case 'ordinal':\n            return true;\n        case 'quantitative':\n            return !!fieldDef.bin;\n        case 'temporal':\n            // TODO: deal with custom scale type case.\n            return timeunit_1.isDiscreteByDefault(fieldDef.timeUnit);\n    }\n    throw new Error(log.message.invalidFieldType(fieldDef.type));\n}\nexports.isDiscrete = isDiscrete;\nfunction isContinuous(fieldDef) {\n    return !isDiscrete(fieldDef);\n}\nexports.isContinuous = isContinuous;\nfunction isCount(fieldDef) {\n    return fieldDef.aggregate === 'count';\n}\nexports.isCount = isCount;\nfunction title(fieldDef, config) {\n    if (fieldDef.title != null) {\n        return fieldDef.title;\n    }\n    if (isCount(fieldDef)) {\n        return config.countTitle;\n    }\n    var fn = fieldDef.aggregate || fieldDef.timeUnit || (fieldDef.bin && 'bin');\n    if (fn) {\n        return fn.toString().toUpperCase() + '(' + fieldDef.field + ')';\n    }\n    else {\n        return fieldDef.field;\n    }\n}\nexports.title = title;\nfunction defaultType(fieldDef, channel) {\n    if (!!fieldDef.timeUnit) {\n        return 'temporal';\n    }\n    if (!!fieldDef.bin) {\n        return 'quantitative';\n    }\n    switch (channel_1.rangeType(channel)) {\n        case 'continuous':\n            return 'quantitative';\n        case 'discrete':\n            return 'nominal';\n        case 'flexible':\n            return 'nominal';\n        default:\n            return 'quantitative';\n    }\n}\nexports.defaultType = defaultType;\n/**\n * Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n */\nfunction normalize(fieldDef, channel) {\n    // If a fieldDef contains a field, we need type.\n    if (isFieldDef(fieldDef)) {\n        // convert short type to full type\n        var fullType = type_1.getFullName(fieldDef.type);\n        if (fullType) {\n            fieldDef.type = fullType;\n        }\n        else {\n            // If type is empty / invalid, then augment with default type\n            var newType = defaultType(fieldDef, channel);\n            log.warn(log.message.emptyOrInvalidFieldType(fieldDef.type, channel, newType));\n            fieldDef.type = newType;\n        }\n        var _a = channelCompatibility(fieldDef, channel), compatible = _a.compatible, warning = _a.warning;\n        if (!compatible) {\n            log.warn(warning);\n        }\n    }\n    return fieldDef;\n}\nexports.normalize = normalize;\nvar COMPATIBLE = { compatible: true };\nfunction channelCompatibility(fieldDef, channel) {\n    switch (channel) {\n        case 'row':\n        case 'column':\n            if (isContinuous(fieldDef) && !fieldDef.timeUnit) {\n                // TODO:(https://github.com/vega/vega-lite/issues/2011):\n                // with timeUnit it's not always strictly continuous\n                return {\n                    compatible: false,\n                    warning: log.message.facetChannelShouldBeDiscrete(channel)\n                };\n            }\n            return COMPATIBLE;\n        case 'x':\n        case 'y':\n        case 'color':\n        case 'text':\n        case 'detail':\n            return COMPATIBLE;\n        case 'opacity':\n        case 'size':\n        case 'x2':\n        case 'y2':\n            if (isDiscrete(fieldDef) && !fieldDef.bin) {\n                return {\n                    compatible: false,\n                    warning: \"Channel \" + channel + \" should not be used with discrete field.\"\n                };\n            }\n            return COMPATIBLE;\n        case 'shape':\n            if (fieldDef.type !== 'nominal') {\n                return {\n                    compatible: false,\n                    warning: 'Shape channel should be used with nominal data only'\n                };\n            }\n            else {\n                return COMPATIBLE;\n            }\n        case 'order':\n            if (fieldDef.type === 'nominal') {\n                return {\n                    compatible: false,\n                    warning: \"Channel order is inappropriate for nominal field, which has no inherent order.\"\n                };\n            }\n            return COMPATIBLE;\n    }\n    throw new Error('channelCompatability not implemented for channel ' + channel);\n}\nexports.channelCompatibility = channelCompatibility;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmllbGRkZWYuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZmllbGRkZWYudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsd0NBQXdDOzs7QUFLeEMscUNBQTZDO0FBRzdDLDJCQUE2QjtBQUk3Qix1Q0FBeUQ7QUFDekQsK0JBQXlDO0FBMEd4QyxDQUFDO0FBSUYsb0JBQTJCLFVBQXNCO0lBQy9DLE1BQU0sQ0FBQyxVQUFVLElBQUksQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxJQUFJLFVBQVUsQ0FBQyxXQUFXLENBQUMsS0FBSyxPQUFPLENBQUMsQ0FBQztBQUN0RixDQUFDO0FBRkQsZ0NBRUM7QUFFRCxvQkFBMkIsVUFBc0I7SUFDL0MsTUFBTSxDQUFDLFVBQVUsSUFBSSxPQUFPLElBQUksVUFBVSxJQUFJLFVBQVUsQ0FBQyxPQUFPLENBQUMsS0FBSyxTQUFTLENBQUM7QUFDbEYsQ0FBQztBQUZELGdDQUVDO0FBb0JELGVBQXNCLFFBQWtCLEVBQUUsR0FBd0I7SUFBeEIsb0JBQUEsRUFBQSxRQUF3QjtJQUNoRSxJQUFJLEtBQUssR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDO0lBQzNCLElBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUM7SUFDeEIsSUFBSSxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQztJQUV4QixFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3RCLEtBQUssR0FBRyxTQUFTLENBQUM7SUFDcEIsQ0FBQztJQUFDLElBQUksQ0FBQyxDQUFDO1FBQ04sSUFBSSxFQUFFLEdBQVcsU0FBUyxDQUFDO1FBRTNCLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDZCxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDakIsRUFBRSxHQUFHLEtBQUss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",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultLegendConfig = {\n    orient: undefined,\n};\nexports.LEGEND_PROPERTIES = ['entryPadding', 'format', 'offset', 'orient', 'tickCount', 'title', 'type', 'values', 'zindex'];\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGVnZW5kLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xlZ2VuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQTBEYSxRQUFBLG1CQUFtQixHQUFpQjtJQUMvQyxNQUFNLEVBQUUsU0FBUztDQUNsQixDQUFDO0FBRVcsUUFBQSxpQkFBaUIsR0FBb0IsQ0FBQyxjQUFjLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDIn0=",
    "///<reference path=\"../typings/vega-util.d.ts\" />\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Vega-Lite's singleton logger utility.\n */\nvar vega_util_1 = require(\"vega-util\");\n/**\n * Main (default) Vega Logger instance for Vega-Lite\n */\nvar main = vega_util_1.logger(vega_util_1.Warn);\nvar current = main;\n/**\n * Logger tool for checking if the code throws correct warning\n */\nvar LocalLogger = (function () {\n    function LocalLogger() {\n        this.warns = [];\n        this.infos = [];\n        this.debugs = [];\n    }\n    LocalLogger.prototype.level = function () {\n        return this;\n    };\n    LocalLogger.prototype.warn = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        (_a = this.warns).push.apply(_a, args);\n        return this;\n        var _a;\n    };\n    LocalLogger.prototype.info = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        (_a = this.infos).push.apply(_a, args);\n        return this;\n        var _a;\n    };\n    LocalLogger.prototype.debug = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        (_a = this.debugs).push.apply(_a, args);\n        return this;\n        var _a;\n    };\n    return LocalLogger;\n}());\nexports.LocalLogger = LocalLogger;\nfunction runLocalLogger(f) {\n    var localLogger = current = new LocalLogger();\n    f(localLogger);\n    reset();\n}\nexports.runLocalLogger = runLocalLogger;\nfunction wrap(f) {\n    return function () {\n        var logger = current = new LocalLogger();\n        f(logger);\n        reset();\n    };\n}\nexports.wrap = wrap;\n/**\n * Set the singleton logger to be a custom logger\n */\nfunction set(logger) {\n    current = logger;\n    return current;\n}\nexports.set = set;\n/**\n * Reset the main logger to use the default Vega Logger\n */\nfunction reset() {\n    current = main;\n    return current;\n}\nexports.reset = reset;\nfunction warn() {\n    var _ = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        _[_i] = arguments[_i];\n    }\n    current.warn.apply(current, arguments);\n}\nexports.warn = warn;\nfunction info() {\n    var _ = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        _[_i] = arguments[_i];\n    }\n    current.info.apply(current, arguments);\n}\nexports.info = info;\nfunction debug() {\n    var _ = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        _[_i] = arguments[_i];\n    }\n    current.debug.apply(current, arguments);\n}\nexports.debug = debug;\n/**\n * Collection of all Vega-Lite Error Messages\n */\nvar message;\n(function (message) {\n    message.INVALID_SPEC = 'Invalid spec';\n    // DATA\n    message.DEPRECATED_FILTER_NULL = 'filterNull is deprecated. Please use filterInvalid instead.';\n    // ENCODING & FACET\n    function invalidFieldType(type) {\n        return \"Invalid field type \\\"\" + type + \"\\\"\";\n    }\n    message.invalidFieldType = invalidFieldType;\n    function emptyOrInvalidFieldType(type, channel, newType) {\n        return \"Invalid field type (\" + type + \") for channel \" + channel + \", using \" + newType + \" instead.\";\n    }\n    message.emptyOrInvalidFieldType = emptyOrInvalidFieldType;\n    function emptyFieldDef(fieldDef, channel) {\n        return \"Dropping \" + JSON.stringify(fieldDef) + \" from channel \" + channel + \" since it does not contain data field or value.\";\n    }\n    message.emptyFieldDef = emptyFieldDef;\n    function incompatibleChannel(channel, markOrFacet, when) {\n        return channel + \" dropped as it is incompatible with \" + markOrFacet +\n            when ? \"when \" + when : '';\n    }\n    message.incompatibleChannel = incompatibleChannel;\n    function facetChannelShouldBeDiscrete(channel) {\n        return channel + \" encoding should be discrete (ordinal / nominal / binned).\";\n    }\n    message.facetChannelShouldBeDiscrete = facetChannelShouldBeDiscrete;\n    function discreteChannelCannotEncode(channel, type) {\n        return \"Using discrete channel \" + channel + \" to encode \" + type + \" field can be misleading as it does not encode \" + (type === 'ordinal' ? 'order' : 'magnitude') + \".\";\n    }\n    message.discreteChannelCannotEncode = discreteChannelCannotEncode;\n    // Mark\n    message.BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL = 'Bar mark should not be used with point scale when rangeStep is null. Please use band scale instead.';\n    function unclearOrientContinuous(mark) {\n        return 'Cannot clearly determine orientation for ' + mark + ' since both x and y channel encode continous fields. In this case, we use vertical by default';\n    }\n    message.unclearOrientContinuous = unclearOrientContinuous;\n    function unclearOrientDiscreteOrEmpty(mark) {\n        return 'Cannot clearly determine orientation for ' + mark + ' since both x and y channel encode discrete or empty fields.';\n    }\n    message.unclearOrientDiscreteOrEmpty = unclearOrientDiscreteOrEmpty;\n    function orientOverridden(original, actual) {\n        return \"Specified orient \" + original + \" overridden with \" + actual;\n    }\n    message.orientOverridden = orientOverridden;\n    // SCALE\n    message.CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN = 'custom domain scale cannot be unioned with default field-based domain';\n    function cannotUseScalePropertyWithNonColor(prop) {\n        return \"Cannot use \" + prop + \" with non-color channel.\";\n    }\n    message.cannotUseScalePropertyWithNonColor = cannotUseScalePropertyWithNonColor;\n    function unaggregateDomainHasNoEffectForRawField(fieldDef) {\n        return \"Using unaggregated domain with raw field has no effect (\" + JSON.stringify(fieldDef) + \").\";\n    }\n    message.unaggregateDomainHasNoEffectForRawField = unaggregateDomainHasNoEffectForRawField;\n    function unaggregateDomainWithNonSharedDomainOp(aggregate) {\n        return \"Unaggregated domain not applicable for \" + aggregate + \" since it produces values outside the origin domain of the source data.\";\n    }\n    message.unaggregateDomainWithNonSharedDomainOp = unaggregateDomainWithNonSharedDomainOp;\n    function unaggregatedDomainWithLogScale(fieldDef) {\n        return \"Unaggregated domain is currently unsupported for log scale (\" + JSON.stringify(fieldDef) + \").\";\n    }\n    message.unaggregatedDomainWithLogScale = unaggregatedDomainWithLogScale;\n    message.CANNOT_USE_RANGE_WITH_POSITION = 'Cannot use custom range with x or y channel.  Please customize width, height, padding, or rangeStep instead.';\n    message.CANNOT_USE_PADDING_WITH_FACET = 'Cannot use padding with facet\\'s scale.  Please use spacing instead.';\n    function cannotUseRangePropertyWithFacet(propName) {\n        return \"Cannot use custom \" + propName + \" with row or column channel. Please use width, height, or spacing instead.\";\n    }\n    message.cannotUseRangePropertyWithFacet = cannotUseRangePropertyWithFacet;\n    function rangeStepDropped(channel) {\n        return \"rangeStep for \" + channel + \" is dropped as top-level \" + (channel === 'x' ? 'width' : 'height') + \" is provided.\";\n    }\n    message.rangeStepDropped = rangeStepDropped;\n    function cannotOverrideBinScaleType(channel, defaultScaleType) {\n        return \"Cannot override scale type for binned channel \" + channel + \". We are using \" + defaultScaleType + \" scale instead.\";\n    }\n    message.cannotOverrideBinScaleType = cannotOverrideBinScaleType;\n    function scaleTypeNotWorkWithChannel(channel, scaleType, defaultScaleType) {\n        return \"Channel \" + channel + \" does not work with \" + scaleType + \" scale. We are using \" + defaultScaleType + \" scale instead.\";\n    }\n    message.scaleTypeNotWorkWithChannel = scaleTypeNotWorkWithChannel;\n    function scalePropertyNotWorkWithScaleType(scaleType, propName, channel) {\n        return channel + \"-scale's \\\"\" + propName + \"\\\" is dropped as it does not work with \" + scaleType + \" scale.\";\n    }\n    message.scalePropertyNotWorkWithScaleType = scalePropertyNotWorkWithScaleType;\n    function scaleTypeNotWorkWithMark(mark, scaleType) {\n        return \"Scale type \\\"\" + scaleType + \"\\\" does not work with mark \" + mark + \".\";\n    }\n    message.scaleTypeNotWorkWithMark = scaleTypeNotWorkWithMark;\n    message.INVAID_DOMAIN = 'Invalid scale domain';\n    message.UNABLE_TO_MERGE_DOMAINS = 'Unable to merge domains';\n    // AXIS\n    message.INVALID_CHANNEL_FOR_AXIS = 'Invalid channel for axis.';\n    // STACK\n    function cannotStackRangedMark(channel) {\n        return \"Cannot stack \" + channel + \" if there is already \" + channel + \"2\";\n    }\n    message.cannotStackRangedMark = cannotStackRangedMark;\n    function cannotStackNonLinearScale(scaleType) {\n        return \"Cannot stack non-linear scale (\" + scaleType + \")\";\n    }\n    message.cannotStackNonLinearScale = cannotStackNonLinearScale;\n    function cannotStackNonSummativeAggregate(aggregate) {\n        return \"Cannot stack when the aggregate function is non-summative (\" + aggregate + \")\";\n    }\n    message.cannotStackNonSummativeAggregate = cannotStackNonSummativeAggregate;\n    // TIMEUNIT\n    function invalidTimeUnit(unitName, value) {\n        return \"Invalid \" + unitName + \": \" + value;\n    }\n    message.invalidTimeUnit = invalidTimeUnit;\n    function dayReplacedWithDate(fullTimeUnit) {\n        return \"Time unit \\\"\" + fullTimeUnit + \"\\\" is not supported. We are replacing it with \" +\n            (fullTimeUnit + '').replace('day', 'date') + '.';\n    }\n    message.dayReplacedWithDate = dayReplacedWithDate;\n    function droppedDay(d) {\n        return 'Dropping day from datetime ' + JSON.stringify(d) +\n            ' as day cannot be combined with other units.';\n    }\n    message.droppedDay = droppedDay;\n})(message = exports.message || (exports.message = {}));\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9nLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xvZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpREFBaUQ7OztBQUVqRDs7R0FFRztBQUVILHVDQUF3RDtBQWF4RDs7R0FFRztBQUNILElBQU0sSUFBSSxHQUFHLGtCQUFNLENBQUMsZ0JBQUksQ0FBQyxDQUFDO0FBQzFCLElBQUksT0FBTyxHQUFvQixJQUFJLENBQUM7QUFFcEM7O0dBRUc7QUFDSDtJQUFBO1FBQ1MsVUFBSyxHQUFVLEVBQUUsQ0FBQztRQUNsQixVQUFLLEdBQVUsRUFBRSxDQUFDO1FBQ2xCLFdBQU0sR0FBVSxFQUFFLENBQUM7SUFvQjVCLENBQUM7SUFsQlEsMkJBQUssR0FBWjtRQUNFLE1BQU0sQ0FBQyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRU0sMEJBQUksR0FBWDtRQUFZLGNBQWM7YUFBZCxVQUFjLEVBQWQscUJBQWMsRUFBZCxJQUFjO1lBQWQseUJBQWM7O1FBQ3hCLENBQUEsS0FBQSxJQUFJLENBQUMsS0FBSyxDQUFBLENBQUMsSUFBSSxXQUFJLElBQUksRUFBRTtRQUN6QixNQUFNLENBQUMsSUFBSSxDQUFDOztJQUNkLENBQUM7SUFFTSwwQkFBSSxHQUFYO1FBQVksY0FBYzthQUFkLFVBQWMsRUFBZCxxQkFBYyxFQUFkLElBQWM7WUFBZCx5QkFBYzs7UUFDeEIsQ0FBQSxLQUFBLElBQUksQ0FBQyxLQUFLLENBQUEsQ0FBQyxJQUFJLFdBQUksSUFBSSxFQUFFO1FBQ3pCLE1BQU0sQ0FBQyxJQUFJLENBQUM7O0lBQ2QsQ0FBQztJQUVNLDJCQUFLLEdBQVo7UUFBYSxjQUFjO2FBQWQsVUFBYyxFQUFkLHFCQUFjLEVBQWQsSUFBYztZQUFkLHlCQUFjOztRQUN6QixDQUFBLEtBQUEsSUFBSSxDQUFDLE1BQU0sQ0FBQSxDQUFDLElBQUksV0FBSSxJQUFJLEVBQUU7UUFDMUIsTUFBTSxDQUFDLElBQUksQ0FBQzs7SUFDZCxDQUFDO0lBQ0gsa0JB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",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nvar Mark;\n(function (Mark) {\n    Mark.AREA = 'area';\n    Mark.BAR = 'bar';\n    Mark.LINE = 'line';\n    Mark.POINT = 'point';\n    Mark.RECT = 'rect';\n    Mark.RULE = 'rule';\n    Mark.TEXT = 'text';\n    Mark.TICK = 'tick';\n    Mark.CIRCLE = 'circle';\n    Mark.SQUARE = 'square';\n})(Mark = exports.Mark || (exports.Mark = {}));\nexports.AREA = Mark.AREA;\nexports.BAR = Mark.BAR;\nexports.LINE = Mark.LINE;\nexports.POINT = Mark.POINT;\nexports.TEXT = Mark.TEXT;\nexports.TICK = Mark.TICK;\nexports.RECT = Mark.RECT;\nexports.RULE = Mark.RULE;\nexports.CIRCLE = Mark.CIRCLE;\nexports.SQUARE = Mark.SQUARE;\nexports.PRIMITIVE_MARKS = [exports.AREA, exports.BAR, exports.LINE, exports.POINT, exports.TEXT, exports.TICK, exports.RECT, exports.RULE, exports.CIRCLE, exports.SQUARE];\nfunction isMarkDef(mark) {\n    return mark['type'];\n}\nexports.isMarkDef = isMarkDef;\nvar PRIMITIVE_MARK_INDEX = util_1.toSet(exports.PRIMITIVE_MARKS);\nfunction isPrimitiveMark(mark) {\n    var markType = isMarkDef(mark) ? mark.type : mark;\n    return markType in PRIMITIVE_MARK_INDEX;\n}\nexports.isPrimitiveMark = isPrimitiveMark;\nexports.STROKE_CONFIG = ['stroke', 'strokeWidth',\n    'strokeDash', 'strokeDashOffset', 'strokeOpacity'];\nexports.FILL_CONFIG = ['fill', 'fillOpacity'];\nexports.FILL_STROKE_CONFIG = [].concat(exports.STROKE_CONFIG, exports.FILL_CONFIG);\nexports.defaultMarkConfig = {\n    color: '#4c78a8',\n};\nexports.defaultBarConfig = {\n    binSpacing: 1,\n    continuousBandSize: 2\n};\nexports.defaultTextConfig = {\n    baseline: 'middle',\n};\nexports.defaultTickConfig = {\n    thickness: 1\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFyay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tYXJrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsK0JBQTZCO0FBSTdCLElBQWlCLElBQUksQ0FXcEI7QUFYRCxXQUFpQixJQUFJO0lBQ04sU0FBSSxHQUFXLE1BQU0sQ0FBQztJQUN0QixRQUFHLEdBQVUsS0FBSyxDQUFDO0lBQ25CLFNBQUksR0FBVyxNQUFNLENBQUM7SUFDdEIsVUFBSyxHQUFZLE9BQU8sQ0FBQztJQUN6QixTQUFJLEdBQVcsTUFBTSxDQUFDO0lBQ3RCLFNBQUksR0FBVyxNQUFNLENBQUM7SUFDdEIsU0FBSSxHQUFXLE1BQU0sQ0FBQztJQUN0QixTQUFJLEdBQVcsTUFBTSxDQUFDO0lBQ3RCLFdBQU0sR0FBYSxRQUFRLENBQUM7SUFDNUIsV0FBTSxHQUFhLFFBQVEsQ0FBQztBQUMzQyxDQUFDLEVBWGdCLElBQUksR0FBSixZQUFJLEtBQUosWUFBSSxRQVdwQjtBQVFZLFFBQUEsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDakIsUUFBQSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztBQUNmLFFBQUEsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDakIsUUFBQSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztBQUNuQixRQUFBLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO0FBQ2pCLFFBQUEsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDakIsUUFBQSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztBQUNqQixRQUFBLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO0FBRWpCLFFBQUEsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7QUFDckIsUUFBQSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztBQUVyQixRQUFBLGVBQWUsR0FBRyxDQUFDLFlBQUksRUFBRSxXQUFHLEVBQUUsWUFBSSxFQUFFLGFBQUssRUFBRSxZQUFJLEVBQUUsWUFBSSxFQUFFLFlBQUksRUFBRSxZQUFJLEVBQUUsY0FBTSxFQUFFLGNBQU0sQ0FBQyxDQUFDO0FBaURoRyxtQkFBMEIsSUFBc0I7SUFDOUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN0QixDQUFDO0FBRkQsOEJBRUM7QUFFRCxJQUFNLG9CQUFvQixHQUFHLFlBQUssQ0FBQyx1QkFBZSxDQUFDLENBQUM7QUFFcEQseUJBQWdDLElBQXNCO0lBQ3BELElBQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztJQUNwRCxNQUFNLENBQUMsUUFBUSxJQUFJLG9CQUFvQixDQUFDO0FBQzFDLENBQUM7QUFIRCwwQ0FHQztBQUVZLFFBQUEsYUFBYSxHQUFHLENBQUMsUUFBUSxFQUFFLGFBQWE7SUFDbkQsWUFBWSxFQUFFLGtCQUFrQixFQUFFLGVBQWUsQ0FBQyxDQUFDO0FBRXhDLFFBQUEsV0FBVyxHQUFHLENBQUMsTUFBTSxFQUFFLGFBQWEsQ0FBQyxDQUFDO0FBRXRDLFFBQUEsa0JBQWtCLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxxQkFBYSxFQUFFLG1CQUFXLENBQUMsQ0FBQztBQW1CM0QsUUFBQSxpQkFBaUIsR0FBZTtJQUMzQyxLQUFLLEVBQUUsU0FBUztDQUNqQixDQUFDO0FBc0JXLFFBQUEsZ0JBQWdCLEdBQWM7SUFDekMsVUFBVSxFQUFFLENBQUM7SUFDYixrQkFBa0IsRUFBRSxDQUFDO0NBQ3RCLENBQUM7QUFTVyxRQUFBLGlCQUFpQixHQUFlO0lBQzNDLFFBQVEsRUFBRSxRQUFRO0NBQ25CLENBQUM7QUFpQlcsUUFBQSxpQkFBaUIsR0FBZTtJQUMzQyxTQUFTLEVBQUUsQ0FBQztDQUNiLENBQUMifQ==",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log = require(\"./log\");\nvar util_1 = require(\"./util\");\nvar ScaleType;\n(function (ScaleType) {\n    // Continuous - Quantitative\n    ScaleType.LINEAR = 'linear';\n    ScaleType.BIN_LINEAR = 'bin-linear';\n    ScaleType.LOG = 'log';\n    ScaleType.POW = 'pow';\n    ScaleType.SQRT = 'sqrt';\n    // Continuous - Time\n    ScaleType.TIME = 'time';\n    ScaleType.UTC = 'utc';\n    // sequential\n    ScaleType.SEQUENTIAL = 'sequential';\n    // Quantile, Quantize, threshold\n    ScaleType.QUANTILE = 'quantile';\n    ScaleType.QUANTIZE = 'quantize';\n    ScaleType.THRESHOLD = 'threshold';\n    ScaleType.ORDINAL = 'ordinal';\n    ScaleType.BIN_ORDINAL = 'bin-ordinal';\n    ScaleType.POINT = 'point';\n    ScaleType.BAND = 'band';\n})(ScaleType = exports.ScaleType || (exports.ScaleType = {}));\nexports.SCALE_TYPES = [\n    // Continuous - Quantitative\n    'linear', 'bin-linear', 'log', 'pow', 'sqrt',\n    // Continuous - Time\n    'time', 'utc',\n    // Sequential\n    'sequential',\n    // Discrete\n    'ordinal', 'bin-ordinal', 'point', 'band',\n];\nexports.CONTINUOUS_TO_CONTINUOUS_SCALES = ['linear', 'bin-linear', 'log', 'pow', 'sqrt', 'time', 'utc'];\nvar CONTINUOUS_TO_CONTINUOUS_INDEX = util_1.toSet(exports.CONTINUOUS_TO_CONTINUOUS_SCALES);\nexports.CONTINUOUS_DOMAIN_SCALES = exports.CONTINUOUS_TO_CONTINUOUS_SCALES.concat(['sequential' /* TODO add 'quantile', 'quantize', 'threshold'*/]);\nvar CONTINUOUS_DOMAIN_INDEX = util_1.toSet(exports.CONTINUOUS_DOMAIN_SCALES);\nexports.DISCRETE_DOMAIN_SCALES = ['ordinal', 'bin-ordinal', 'point', 'band'];\nvar DISCRETE_DOMAIN_INDEX = util_1.toSet(exports.DISCRETE_DOMAIN_SCALES);\nvar BIN_SCALES_INDEX = util_1.toSet(['bin-linear', 'bin-ordinal']);\nexports.TIME_SCALE_TYPES = ['time', 'utc'];\nfunction hasDiscreteDomain(type) {\n    return type in DISCRETE_DOMAIN_INDEX;\n}\nexports.hasDiscreteDomain = hasDiscreteDomain;\nfunction isBinScale(type) {\n    return type in BIN_SCALES_INDEX;\n}\nexports.isBinScale = isBinScale;\nfunction hasContinuousDomain(type) {\n    return type in CONTINUOUS_DOMAIN_INDEX;\n}\nexports.hasContinuousDomain = hasContinuousDomain;\nfunction isContinuousToContinuous(type) {\n    return type in CONTINUOUS_TO_CONTINUOUS_INDEX;\n}\nexports.isContinuousToContinuous = isContinuousToContinuous;\nexports.defaultScaleConfig = {\n    round: true,\n    textXRangeStep: 90,\n    rangeStep: 21,\n    pointPadding: 0.5,\n    bandPaddingInner: 0.1,\n    facetSpacing: 16,\n    minFontSize: 8,\n    maxFontSize: 40,\n    minOpacity: 0.3,\n    maxOpacity: 0.8,\n    // FIXME: revise if these *can* become ratios of rangeStep\n    minSize: 9,\n    minStrokeWidth: 1,\n    maxStrokeWidth: 4,\n    shapes: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down']\n};\nfunction isExtendedScheme(scheme) {\n    return scheme && !!scheme['name'];\n}\nexports.isExtendedScheme = isExtendedScheme;\nexports.SCALE_PROPERTIES = [\n    'type', 'domain', 'range', 'round', 'rangeStep', 'scheme', 'padding', 'paddingInner', 'paddingOuter', 'clamp', 'nice',\n    'exponent', 'zero', 'interpolate'\n];\nfunction scaleTypeSupportProperty(scaleType, propName) {\n    switch (propName) {\n        case 'type':\n        case 'domain':\n        case 'range':\n        case 'scheme':\n            return true;\n        case 'interpolate':\n            return scaleType === 'linear' || scaleType === 'bin-linear';\n        case 'round':\n            return isContinuousToContinuous(scaleType) || scaleType === 'band' || scaleType === 'point';\n        case 'rangeStep':\n        case 'padding':\n        case 'paddingOuter':\n            return util_1.contains(['point', 'band'], scaleType);\n        case 'paddingInner':\n            return scaleType === 'band';\n        case 'clamp':\n            return isContinuousToContinuous(scaleType) || scaleType === 'sequential';\n        case 'nice':\n            return isContinuousToContinuous(scaleType) || scaleType === 'sequential' || scaleType === 'quantize';\n        case 'exponent':\n            return scaleType === 'pow' || scaleType === 'log';\n        case 'zero':\n            // TODO: what about quantize, threshold?\n            return scaleType === 'bin-ordinal' || (!hasDiscreteDomain(scaleType) && !util_1.contains(['log', 'time', 'utc'], scaleType));\n    }\n    /* istanbul ignore next: should never reach here*/\n    throw new Error(\"Invalid scale property \" + propName + \".\");\n}\nexports.scaleTypeSupportProperty = scaleTypeSupportProperty;\n/**\n * Returns undefined if the input channel supports the input scale property name\n */\nfunction channelScalePropertyIncompatability(channel, propName) {\n    switch (propName) {\n        case 'range':\n            // User should not customize range for position and facet channel directly.\n            if (channel === 'x' || channel === 'y') {\n                return log.message.CANNOT_USE_RANGE_WITH_POSITION;\n            }\n            if (channel === 'row' || channel === 'column') {\n                return log.message.cannotUseRangePropertyWithFacet('range');\n            }\n            return undefined; // GOOD!\n        // band / point\n        case 'rangeStep':\n            if (channel === 'row' || channel === 'column') {\n                return log.message.cannotUseRangePropertyWithFacet('rangeStep');\n            }\n            return undefined; // GOOD!\n        case 'padding':\n        case 'paddingInner':\n        case 'paddingOuter':\n            if (channel === 'row' || channel === 'column') {\n                /*\n                 * We do not use d3 scale's padding for row/column because padding there\n                 * is a ratio ([0, 1]) and it causes the padding to be decimals.\n                 * Therefore, we manually calculate \"spacing\" in the layout by ourselves.\n                 */\n                return log.message.CANNOT_USE_PADDING_WITH_FACET;\n            }\n            return undefined; // GOOD!\n        case 'interpolate':\n        case 'scheme':\n            if (channel !== 'color') {\n                return log.message.cannotUseScalePropertyWithNonColor(channel);\n            }\n            return undefined;\n        case 'type':\n        case 'domain':\n        case 'round':\n        case 'clamp':\n        case 'exponent':\n        case 'nice':\n        case 'zero':\n            // These channel do not have strict requirement\n            return undefined; // GOOD!\n    }\n    /* istanbul ignore next: it should never reach here */\n    throw new Error('Invalid scale property \"${propName}\".');\n}\nexports.channelScalePropertyIncompatability = channelScalePropertyIncompatability;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NhbGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc2NhbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwyQkFBNkI7QUFHN0IsK0JBQXVDO0FBRXZDLElBQWlCLFNBQVMsQ0FzQnpCO0FBdEJELFdBQWlCLFNBQVM7SUFDeEIsNEJBQTRCO0lBQ2YsZ0JBQU0sR0FBYSxRQUFRLENBQUM7SUFDNUIsb0JBQVUsR0FBaUIsWUFBWSxDQUFDO0lBQ3hDLGFBQUcsR0FBVSxLQUFLLENBQUM7SUFDbkIsYUFBRyxHQUFVLEtBQUssQ0FBQztJQUNuQixjQUFJLEdBQVcsTUFBTSxDQUFDO0lBQ25DLG9CQUFvQjtJQUNQLGNBQUksR0FBVyxNQUFNLENBQUM7SUFDdEIsYUFBRyxHQUFXLEtBQUssQ0FBQztJQUNqQyxhQUFhO0lBQ0Esb0JBQVUsR0FBaUIsWUFBWSxDQUFDO0lBRXJELGdDQUFnQztJQUNuQixrQkFBUSxHQUFlLFVBQVUsQ0FBQztJQUNsQyxrQkFBUSxHQUFlLFVBQVUsQ0FBQztJQUNsQyxtQkFBUyxHQUFnQixXQUFXLENBQUM7SUFFckMsaUJBQU8sR0FBYyxTQUFTLENBQUM7SUFDL0IscUJBQVcsR0FBa0IsYUFBYSxDQUFDO0lBQzNDLGVBQUssR0FBWSxPQUFPLENBQUM7SUFDekIsY0FBSSxHQUFXLE1BQU0sQ0FBQztBQUNyQyxDQUFDLEVBdEJnQixTQUFTLEdBQVQsaUJBQVMsS0FBVCxpQkFBUyxRQXNCekI7QUFTWSxRQUFBLFdBQVcsR0FBZ0I7SUFDdEMsNEJBQTRCO0lBQzVCLFFBQVEsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNO0lBQzVDLG9CQUFvQjtJQUNwQixNQUFNLEVBQUUsS0FBSztJQUNiLGFBQWE7SUFDYixZQUFZO0lBQ1osV0FBVztJQUNYLFNBQVMsRUFBRSxhQUFhLEVBQUUsT0FBTyxFQUFFLE1BQU07Q0FDMUMsQ0FBQztBQUVXLFFBQUEsK0JBQStCLEdBQWdCLENBQUMsUUFBUSxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDMUgsSUFBTSw4QkFBOEIsR0FBRyxZQUFLLENBQUMsdUNBQStCLENBQUMsQ0FBQztBQUVqRSxRQUFBLHdCQUF3QixHQUFnQix1Q0FBK0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxZQUFZLENBQUMsaURBQWlELENBQUMsQ0FBQyxDQUFDO0FBQzlKLElBQU0sdUJBQXVCLEdBQUcsWUFBSyxDQUFDLGdDQUF3QixDQUFDLENBQUM7QUFFbkQsUUFBQSxzQkFBc0IsR0FBZ0IsQ0FBQyxTQUFTLEVBQUUsYUFBYSxFQUFFLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQztBQUMvRixJQUFNLHFCQUFxQixHQUFHLFlBQUssQ0FBQyw4QkFBc0IsQ0FBQyxDQUFDO0FBRTVELElBQU0sZ0JBQWdCLEdBQUcsWUFBSyxDQUFDLENBQUMsWUFBWSxFQUFFLGFBQWEsQ0FBQyxDQUFDLENBQUM7QUFFakQsUUFBQSxnQkFBZ0IsR0FBZ0IsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFFN0QsMkJBQWtDLElBQWU7SUFDL0MsTUFBTSxDQUFDLElBQUksSUFBSSxxQkFBcUIsQ0FBQztBQUN2QyxDQUFDO0FBRkQsOENBRUM7QUFFRCxvQkFBMkIsSUFBZTtJQUN4QyxNQUFNLENBQUMsSUFBSSxJQUFJLGdCQUFnQixDQUFDO0FBQ2xDLENBQUM7QUFGRCxnQ0FFQztBQUVELDZCQUFvQyxJQUFlO0lBR2pELE1BQU0sQ0FBQyxJQUFJLElBQUksdUJBQXVCLENBQUM7QUFDekMsQ0FBQztBQUpELGtEQUlDO0FBRUQsa0NBQXlDLElBQWU7SUFDdEQsTUFBTSxDQUFDLElBQUksSUFBSSw4QkFBOEIsQ0FBQztBQUNoRCxDQUFDO0FBRkQsNERBRUM7QUFnSlksUUFBQSxrQkFBa0IsR0FBRztJQUNoQyxLQUFLLEVBQUUsSUFBSTtJQUNYLGNBQWMsRUFBRSxFQUFFO0lBQ2xCLFNBQVMsRUFBRSxFQUFFO0lBQ2IsWUFBWSxFQUFFLEdBQUc7SUFDakIsZ0JBQWdCLEVBQUUsR0FBRztJQUNyQixZQUFZLEVBQUUsRUFBRTtJQUVoQixXQUFXLEVBQUUsQ0FBQztJQUNkLFdBQVcsRUFBRSxFQUFFO0lBRWYsVUFBVSxFQUFFLEdBQUc7SUFDZixVQUFVLEVBQUUsR0FBRztJQUVmLDBEQUEwRDtJQUMxRCxPQUFPLEVBQUUsQ0FBQztJQUVWLGNBQWMsRUFBRSxDQUFDO0lBQ2pCLGNBQWMsRUFBRSxDQUFDO0lBRWpCLE1BQU0sRUFBRSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxhQUFhLEVBQUUsZUFBZSxDQUFDO0NBQ2pGLENBQUM7QUFvQkYsMEJBQWlDLE1BQStCO0lBQzlELE1BQU0sQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNwQyxDQUFDO0FBRkQsNENBRUM7QUE4RlksUUFBQSxnQkFBZ0IsR0FBa0I7SUFDN0MsTUFBTSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsT0FBTyxFQUFFLE1BQU07SUFDckgsVUFBVSxFQUFFLE1BQU0sRUFBRSxhQUFhO0NBQ2xDLENBQUM7QUFFRixrQ0FBeUMsU0FBb0IsRUFBRSxRQUFxQjtJQUNsRixNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ2pCLEtBQUssTUFBTSxDQUFDO1FBQ1osS0FBSyxRQUFRLENBQUM7UUFDZCxLQUFLLE9BQU8sQ0FBQztRQUNiLEtBQUssUUFBUTtZQUNYLE1BQU0sQ0FBQyxJQUFJLENBQUM7UUFDZCxLQUFLLGFBQWE7WUFDaEIsTUFBTSxDQUFDLFNBQVMsS0FBSyxRQUFRLElBQUksU0FBUyxLQUFLLFlBQVksQ0FBQztRQUM5RCxLQUFLLE9BQU87WUFDVixNQUFNLENBQUMsd0JBQXdCLENBQUMsU0FBUyxDQUFDLElBQUksU0FBUyxLQUFLLE1BQU0sSUFBSSxTQUFTLEtBQUssT0FBTyxDQUFDO1FBQzlGLEtBQUssV0FBVyxDQUFDO1FBQ2pCLEtBQUssU0FBUyxDQUFDO1FBQ2YsS0FBSyxjQUFjO1lBQ2pCLE1BQU0sQ0FBQyxlQUFRLENBQUMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDaEQsS0FBSyxjQUFjO1lBQ2pCLE1BQU0sQ0FBQyxTQUFTLEtBQUssTUFBTSxDQUFDO1FBQzlCLEtBQUssT0FBTztZQUNWLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQyxTQUFTLENBQUMsSUFBSSxTQUFTLEtBQUssWUFBWSxDQUFDO1FBQzNFLEtBQUssTUFBTTtZQUNULE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQyxTQUFTLENBQUMsSUFBSSxTQUFTLEtBQUssWUFBWSxJQUFJLFNBQWdCLEtBQUssVUFBVSxDQUFDO1FBQzlHLEtBQUssVUFBVTtZQUNiLE1BQU0sQ0FBQyxTQUFTLEtBQUssS0FBSyxJQUFJLFNBQVMsS0FBSyxLQUFLLENBQUM7UUFDcEQsS0FBSyxNQUFNO1lBQ1Qsd0NBQXdDO1lBQ3hDLE1BQU0sQ0FBQyxTQUFTLEtBQUssYUFBYSxJQUFJLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGVBQVEsQ0FBQyxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQztJQUMxSCxDQUFDO0lBQ0Qsa0RBQWtEO0lBQ2xELE1BQU0sSUFBSSxLQUFLLENBQUMsNEJBQTBCLFFBQVEsTUFBRyxDQUFDLENBQUM7QUFDekQsQ0FBQztBQTdCRCw0REE2QkM7QUFFRDs7R0FFRztBQUNILDZDQUFvRCxPQUFnQixFQUFFLFFBQXFCO0lBQ3pGLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDakIsS0FBSyxPQUFPO1lBQ1YsMkVBQTJFO1lBQzNFLEVBQUUsQ0FBQyxDQUFDLE9BQU8sS0FBSyxHQUFHLElBQUksT0FBTyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQ3ZDLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLDhCQUE4QixDQUFDO1lBQ3BELENBQUM7WUFDRCxFQUFFLENBQUMsQ0FBQyxPQUFPLEtBQUssS0FBSyxJQUFJLE9BQU8sS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUM5QyxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQywrQkFBK0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM5RCxDQUFDO1lBQ0QsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVE7UUFDNUIsZUFBZTtRQUNmLEtBQUssV0FBVztZQUNkLEVBQUUsQ0FBQyxDQUFDLE9BQU8sS0FBSyxLQUFLLElBQUksT0FBTyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUM7Z0JBQzlDLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLCtCQUErQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ2xFLENBQUM7WUFDRCxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUTtRQUM1QixLQUFLLFNBQVMsQ0FBQztRQUNmLEtBQUssY0FBYyxDQUFDO1FBQ3BCLEtBQUssY0FBYztZQUNqQixFQUFFLENBQUMsQ0FBQyxPQUFPLEtBQUssS0FBSyxJQUFJLE9BQU8sS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUM5Qzs7OzttQkFJRztnQkFDSCxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyw2QkFBNkIsQ0FBQztZQUNuRCxDQUFDO1lBQ0QsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVE7UUFDNUIsS0FBSyxhQUFhLENBQUM7UUFDbkIsS0FBSyxRQUFRO1lBQ1gsRUFBRSxDQUFDLENBQUMsT0FBTyxLQUFLLE9BQU8sQ0FBQyxDQUFDLENBQUM7Z0JBQ3hCLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLGtDQUFrQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ2pFLENBQUM7WUFDRCxNQUFNLENBQUMsU0FBUyxDQUFDO1FBQ25CLEtBQUssTUFBTSxDQUFDO1FBQ1osS0FBSyxRQUFRLENBQUM7UUFDZCxLQUFLLE9BQU8sQ0FBQztRQUNiLEtBQUssT0FBTyxDQUFDO1FBQ2IsS0FBSyxVQUFVLENBQUM7UUFDaEIsS0FBSyxNQUFNLENBQUM7UUFDWixLQUFLLE1BQU07WUFDVCwrQ0FBK0M7WUFDL0MsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVE7SUFDOUIsQ0FBQztJQUNELHNEQUFzRDtJQUN0RCxNQUFNLElBQUksS0FBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7QUFDM0QsQ0FBQztBQS9DRCxrRkErQ0MifQ==",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar datetime_1 = require(\"./datetime\");\nvar util_1 = require(\"./util\");\nvar log = require(\"./log\");\nvar TimeUnit;\n(function (TimeUnit) {\n    TimeUnit.YEAR = 'year';\n    TimeUnit.MONTH = 'month';\n    TimeUnit.DAY = 'day';\n    TimeUnit.DATE = 'date';\n    TimeUnit.HOURS = 'hours';\n    TimeUnit.MINUTES = 'minutes';\n    TimeUnit.SECONDS = 'seconds';\n    TimeUnit.MILLISECONDS = 'milliseconds';\n    TimeUnit.YEARMONTH = 'yearmonth';\n    TimeUnit.YEARMONTHDATE = 'yearmonthdate';\n    TimeUnit.YEARMONTHDATEHOURS = 'yearmonthdatehours';\n    TimeUnit.YEARMONTHDATEHOURSMINUTES = 'yearmonthdatehoursminutes';\n    TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS = 'yearmonthdatehoursminutesseconds';\n    // MONTHDATE always include 29 February since we use year 0th (which is a leap year);\n    TimeUnit.MONTHDATE = 'monthdate';\n    TimeUnit.HOURSMINUTES = 'hoursminutes';\n    TimeUnit.HOURSMINUTESSECONDS = 'hoursminutesseconds';\n    TimeUnit.MINUTESSECONDS = 'minutesseconds';\n    TimeUnit.SECONDSMILLISECONDS = 'secondsmilliseconds';\n    TimeUnit.QUARTER = 'quarter';\n    TimeUnit.YEARQUARTER = 'yearquarter';\n    TimeUnit.QUARTERMONTH = 'quartermonth';\n    TimeUnit.YEARQUARTERMONTH = 'yearquartermonth';\n})(TimeUnit = exports.TimeUnit || (exports.TimeUnit = {}));\n/** Time Unit that only corresponds to only one part of Date objects. */\nexports.SINGLE_TIMEUNITS = [\n    TimeUnit.YEAR,\n    TimeUnit.QUARTER,\n    TimeUnit.MONTH,\n    TimeUnit.DAY,\n    TimeUnit.DATE,\n    TimeUnit.HOURS,\n    TimeUnit.MINUTES,\n    TimeUnit.SECONDS,\n    TimeUnit.MILLISECONDS,\n];\nvar SINGLE_TIMEUNIT_INDEX = exports.SINGLE_TIMEUNITS.reduce(function (d, timeUnit) {\n    d[timeUnit] = true;\n    return d;\n}, {});\nfunction isSingleTimeUnit(timeUnit) {\n    return !!SINGLE_TIMEUNIT_INDEX[timeUnit];\n}\nexports.isSingleTimeUnit = isSingleTimeUnit;\n/**\n * Converts a date to only have the measurements relevant to the specified unit\n * i.e. ('yearmonth', '2000-12-04 07:58:14') -> '2000-12-01 00:00:00'\n * Note: the base date is Jan 01 1900 00:00:00\n */\nfunction convert(unit, date) {\n    var result = new Date(0, 0, 1, 0, 0, 0, 0); // start with uniform date\n    exports.SINGLE_TIMEUNITS.forEach(function (singleUnit) {\n        if (containsTimeUnit(unit, singleUnit)) {\n            switch (singleUnit) {\n                case TimeUnit.DAY:\n                    throw new Error('Cannot convert to TimeUnits containing \\'day\\'');\n                case TimeUnit.YEAR:\n                    result.setFullYear(date.getFullYear());\n                    break;\n                case TimeUnit.QUARTER:\n                    // indicate quarter by setting month to be the first of the quarter i.e. may (4) -> april (3)\n                    result.setMonth((Math.floor(date.getMonth() / 3)) * 3);\n                    break;\n                case TimeUnit.MONTH:\n                    result.setMonth(date.getMonth());\n                    break;\n                case TimeUnit.DATE:\n                    result.setDate(date.getDate());\n                    break;\n                case TimeUnit.HOURS:\n                    result.setHours(date.getHours());\n                    break;\n                case TimeUnit.MINUTES:\n                    result.setMinutes(date.getMinutes());\n                    break;\n                case TimeUnit.SECONDS:\n                    result.setSeconds(date.getSeconds());\n                    break;\n                case TimeUnit.MILLISECONDS:\n                    result.setMilliseconds(date.getMilliseconds());\n                    break;\n            }\n        }\n    });\n    return result;\n}\nexports.convert = convert;\nexports.MULTI_TIMEUNITS = [\n    TimeUnit.YEARQUARTER,\n    TimeUnit.YEARQUARTERMONTH,\n    TimeUnit.YEARMONTH,\n    TimeUnit.YEARMONTHDATE,\n    TimeUnit.YEARMONTHDATEHOURS,\n    TimeUnit.YEARMONTHDATEHOURSMINUTES,\n    TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS,\n    TimeUnit.QUARTERMONTH,\n    TimeUnit.HOURSMINUTES,\n    TimeUnit.HOURSMINUTESSECONDS,\n    TimeUnit.MINUTESSECONDS,\n    TimeUnit.SECONDSMILLISECONDS,\n];\nvar MULTI_TIMEUNIT_INDEX = exports.MULTI_TIMEUNITS.reduce(function (d, timeUnit) {\n    d[timeUnit] = true;\n    return d;\n}, {});\nfunction isMultiTimeUnit(timeUnit) {\n    return !!MULTI_TIMEUNIT_INDEX[timeUnit];\n}\nexports.isMultiTimeUnit = isMultiTimeUnit;\nexports.TIMEUNITS = [\n    TimeUnit.YEAR,\n    TimeUnit.QUARTER,\n    TimeUnit.MONTH,\n    TimeUnit.DAY,\n    TimeUnit.DATE,\n    TimeUnit.HOURS,\n    TimeUnit.MINUTES,\n    TimeUnit.SECONDS,\n    TimeUnit.MILLISECONDS,\n    TimeUnit.YEARQUARTER,\n    TimeUnit.YEARQUARTERMONTH,\n    TimeUnit.YEARMONTH,\n    TimeUnit.YEARMONTHDATE,\n    TimeUnit.YEARMONTHDATEHOURS,\n    TimeUnit.YEARMONTHDATEHOURSMINUTES,\n    TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS,\n    TimeUnit.QUARTERMONTH,\n    TimeUnit.HOURSMINUTES,\n    TimeUnit.HOURSMINUTESSECONDS,\n    TimeUnit.MINUTESSECONDS,\n    TimeUnit.SECONDSMILLISECONDS\n];\n/** Returns true if fullTimeUnit contains the timeUnit, false otherwise. */\nfunction containsTimeUnit(fullTimeUnit, timeUnit) {\n    var fullTimeUnitStr = fullTimeUnit.toString();\n    var timeUnitStr = timeUnit.toString();\n    var index = fullTimeUnitStr.indexOf(timeUnitStr);\n    return index > -1 &&\n        (timeUnit !== TimeUnit.SECONDS ||\n            index === 0 ||\n            fullTimeUnitStr.charAt(index - 1) !== 'i' // exclude milliseconds\n        );\n}\nexports.containsTimeUnit = containsTimeUnit;\n/**\n * Returns Vega expresssion for a given timeUnit and fieldRef\n */\nfunction fieldExpr(fullTimeUnit, field) {\n    var fieldRef = \"datum[\\\"\" + field + \"\\\"]\";\n    function func(timeUnit) {\n        if (timeUnit === TimeUnit.QUARTER) {\n            // quarter starting at 0 (0,3,6,9).\n            return \"(quarter(\" + fieldRef + \")-1)\";\n        }\n        else {\n            return timeUnit + \"(\" + fieldRef + \")\";\n        }\n    }\n    var d = exports.SINGLE_TIMEUNITS.reduce(function (_d, tu) {\n        if (containsTimeUnit(fullTimeUnit, tu)) {\n            _d[tu] = func(tu);\n        }\n        return _d;\n    }, {});\n    if (d.day && util_1.keys(d).length > 1) {\n        log.warn(log.message.dayReplacedWithDate(fullTimeUnit));\n        delete d.day;\n        d.date = func(TimeUnit.DATE);\n    }\n    return datetime_1.dateTimeExpr(d);\n}\nexports.fieldExpr = fieldExpr;\n/** returns the smallest nice unit for scale.nice */\nfunction smallestUnit(timeUnit) {\n    if (!timeUnit) {\n        return undefined;\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n        return 'second';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n        return 'minute';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n        return 'hour';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.DAY) ||\n        containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n        return 'day';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n        return 'month';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.YEAR)) {\n        return 'year';\n    }\n    return undefined;\n}\nexports.smallestUnit = smallestUnit;\n/** returns the signal expression used for axis labels for a time unit */\nfunction formatExpression(timeUnit, field, shortTimeLabels) {\n    if (!timeUnit) {\n        return undefined;\n    }\n    var dateComponents = [];\n    var expression = '';\n    var hasYear = containsTimeUnit(timeUnit, TimeUnit.YEAR);\n    if (containsTimeUnit(timeUnit, TimeUnit.QUARTER)) {\n        // special expression for quarter as prefix\n        expression = \"'Q' + quarter(\" + field + \")\";\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n        // By default use short month name\n        dateComponents.push(shortTimeLabels !== false ? '%b' : '%B');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.DAY)) {\n        dateComponents.push(shortTimeLabels ? '%a' : '%A');\n    }\n    else if (containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n        dateComponents.push('%d' + (hasYear ? ',' : '')); // add comma if there is year\n    }\n    if (hasYear) {\n        dateComponents.push(shortTimeLabels ? '%y' : '%Y');\n    }\n    var timeComponents = [];\n    if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n        timeComponents.push('%H');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n        timeComponents.push('%M');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n        timeComponents.push('%S');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MILLISECONDS)) {\n        timeComponents.push('%L');\n    }\n    var dateTimeComponents = [];\n    if (dateComponents.length > 0) {\n        dateTimeComponents.push(dateComponents.join(' '));\n    }\n    if (timeComponents.length > 0) {\n        dateTimeComponents.push(timeComponents.join(':'));\n    }\n    if (dateTimeComponents.length > 0) {\n        if (expression) {\n            // Add space between quarter and main time format\n            expression += \" + ' ' + \";\n        }\n        expression += \"timeFormat(\" + field + \", '\" + dateTimeComponents.join(' ') + \"')\";\n    }\n    // If expression is still an empty string, return undefined instead.\n    return expression || undefined;\n}\nexports.formatExpression = formatExpression;\nfunction isDiscreteByDefault(timeUnit) {\n    switch (timeUnit) {\n        // These time unit use discrete scale by default\n        case 'hours':\n        case 'day':\n        case 'month':\n        case 'quarter':\n            return true;\n    }\n    return false;\n}\nexports.isDiscreteByDefault = isDiscreteByDefault;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZXVuaXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdGltZXVuaXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx1Q0FBc0Q7QUFDdEQsK0JBQWtDO0FBQ2xDLDJCQUE2QjtBQUU3QixJQUFpQixRQUFRLENBeUJ4QjtBQXpCRCxXQUFpQixRQUFRO0lBQ1YsYUFBSSxHQUFXLE1BQU0sQ0FBQztJQUN0QixjQUFLLEdBQVksT0FBTyxDQUFDO0lBQ3pCLFlBQUcsR0FBVSxLQUFLLENBQUM7SUFDbkIsYUFBSSxHQUFXLE1BQU0sQ0FBQztJQUN0QixjQUFLLEdBQVksT0FBTyxDQUFDO0lBQ3pCLGdCQUFPLEdBQWMsU0FBUyxDQUFDO0lBQy9CLGdCQUFPLEdBQWMsU0FBUyxDQUFDO0lBQy9CLHFCQUFZLEdBQW1CLGNBQWMsQ0FBQztJQUM5QyxrQkFBUyxHQUFnQixXQUFXLENBQUM7SUFDckMsc0JBQWEsR0FBb0IsZUFBZSxDQUFDO0lBQ2pELDJCQUFrQixHQUF5QixvQkFBb0IsQ0FBQztJQUNoRSxrQ0FBeUIsR0FBZ0MsMkJBQTJCLENBQUM7SUFDckYseUNBQWdDLEdBQXVDLGtDQUFrQyxDQUFDO0lBRXZILHFGQUFxRjtJQUN4RSxrQkFBUyxHQUFnQixXQUFXLENBQUM7SUFDckMscUJBQVksR0FBbUIsY0FBYyxDQUFDO0lBQzlDLDRCQUFtQixHQUEwQixxQkFBcUIsQ0FBQztJQUNuRSx1QkFBYyxHQUFxQixnQkFBZ0IsQ0FBQztJQUNwRCw0QkFBbUIsR0FBMEIscUJBQXFCLENBQUM7SUFDbkUsZ0JBQU8sR0FBYyxTQUFTLENBQUM7SUFDL0Isb0JBQVcsR0FBa0IsYUFBYSxDQUFDO0lBQzNDLHFCQUFZLEdBQW1CLGNBQWMsQ0FBQztJQUM5Qyx5QkFBZ0IsR0FBdUIsa0JBQWtCLENBQUM7QUFDekUsQ0FBQyxFQXpCZ0IsUUFBUSxHQUFSLGdCQUFRLEtBQVIsZ0JBQVEsUUF5QnhCO0FBU0Qsd0VBQXdFO0FBQzNELFFBQUEs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",
    "/** Constants and utilities for data type */\n/** Data type based on level of measurement */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Type;\n(function (Type) {\n    Type.QUANTITATIVE = 'quantitative';\n    Type.ORDINAL = 'ordinal';\n    Type.TEMPORAL = 'temporal';\n    Type.NOMINAL = 'nominal';\n})(Type = exports.Type || (exports.Type = {}));\nexports.QUANTITATIVE = Type.QUANTITATIVE;\nexports.ORDINAL = Type.ORDINAL;\nexports.TEMPORAL = Type.TEMPORAL;\nexports.NOMINAL = Type.NOMINAL;\n/**\n * Get full, lowercase type name for a given type.\n * @param  type\n * @return Full type name.\n */\nfunction getFullName(type) {\n    if (type) {\n        type = type.toLowerCase();\n        switch (type) {\n            case 'q':\n            case exports.QUANTITATIVE:\n                return 'quantitative';\n            case 't':\n            case exports.TEMPORAL:\n                return 'temporal';\n            case 'o':\n            case exports.ORDINAL:\n                return 'ordinal';\n            case 'n':\n            case exports.NOMINAL:\n                return 'nominal';\n        }\n    }\n    // If we get invalid input, return undefined type.\n    return undefined;\n}\nexports.getFullName = getFullName;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90eXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDRDQUE0QztBQUM1Qyw4Q0FBOEM7OztBQUU5QyxJQUFpQixJQUFJLENBS3BCO0FBTEQsV0FBaUIsSUFBSTtJQUNOLGlCQUFZLEdBQW1CLGNBQWMsQ0FBQztJQUM5QyxZQUFPLEdBQWMsU0FBUyxDQUFDO0lBQy9CLGFBQVEsR0FBZSxVQUFVLENBQUM7SUFDbEMsWUFBTyxHQUFjLFNBQVMsQ0FBQztBQUM5QyxDQUFDLEVBTGdCLElBQUksR0FBSixZQUFJLEtBQUosWUFBSSxRQUtwQjtBQUdZLFFBQUEsWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7QUFDakMsUUFBQSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztBQUN2QixRQUFBLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO0FBQ3pCLFFBQUEsT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7QUFFcEM7Ozs7R0FJRztBQUNILHFCQUE0QixJQUFpQjtJQUMzQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ1QsSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUMxQixNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2IsS0FBSyxHQUFHLENBQUM7WUFDVCxLQUFLLG9CQUFZO2dCQUNmLE1BQU0sQ0FBQyxjQUFjLENBQUM7WUFDeEIsS0FBSyxHQUFHLENBQUM7WUFDVCxLQUFLLGdCQUFRO2dCQUNYLE1BQU0sQ0FBQyxVQUFVLENBQUM7WUFDcEIsS0FBSyxHQUFHLENBQUM7WUFDVCxLQUFLLGVBQU87Z0JBQ1YsTUFBTSxDQUFDLFNBQVMsQ0FBQztZQUNuQixLQUFLLEdBQUcsQ0FBQztZQUNULEtBQUssZUFBTztnQkFDVixNQUFNLENBQUMsU0FBUyxDQUFDO1FBQ3JCLENBQUM7SUFDSCxDQUFDO0lBQ0Qsa0RBQWtEO0lBQ2xELE1BQU0sQ0FBQyxTQUFTLENBQUM7QUFDbkIsQ0FBQztBQXBCRCxrQ0FvQkMifQ==",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar stringify = require(\"json-stable-stringify\");\nvar vega_util_1 = require(\"vega-util\");\nexports.extend = vega_util_1.extend;\nexports.isArray = vega_util_1.isArray;\nexports.isObject = vega_util_1.isObject;\nexports.isNumber = vega_util_1.isNumber;\nexports.isString = vega_util_1.isString;\nexports.truncate = vega_util_1.truncate;\nexports.toSet = vega_util_1.toSet;\nexports.stringValue = vega_util_1.stringValue;\nvar vega_util_2 = require(\"vega-util\");\n/**\n * Creates an object composed of the picked object properties.\n *\n * Example:  (from lodash)\n *\n * var object = {'a': 1, 'b': '2', 'c': 3};\n * pick(object, ['a', 'c']);\n * //  {'a': 1, 'c': 3}\n *\n */\nfunction pick(obj, props) {\n    var copy = {};\n    props.forEach(function (prop) {\n        if (obj.hasOwnProperty(prop)) {\n            copy[prop] = obj[prop];\n        }\n    });\n    return copy;\n}\nexports.pick = pick;\n/**\n * The opposite of _.pick; this method creates an object composed of the own\n * and inherited enumerable string keyed properties of object that are not omitted.\n */\nfunction omit(obj, props) {\n    var copy = duplicate(obj);\n    props.forEach(function (prop) {\n        delete copy[prop];\n    });\n    return copy;\n}\nexports.omit = omit;\nfunction hash(a) {\n    if (vega_util_2.isString(a) || vega_util_2.isNumber(a) || isBoolean(a)) {\n        return String(a);\n    }\n    return stringify(a);\n}\nexports.hash = hash;\nfunction contains(array, item) {\n    return array.indexOf(item) > -1;\n}\nexports.contains = contains;\n/** Returns the array without the elements in item */\nfunction without(array, excludedItems) {\n    return array.filter(function (item) { return !contains(excludedItems, item); });\n}\nexports.without = without;\nfunction union(array, other) {\n    return array.concat(without(other, array));\n}\nexports.union = union;\nfunction reduce(obj, f, init, thisArg) {\n    if (obj.reduce) {\n        return obj.reduce.call(thisArg, f, init);\n    }\n    else {\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                init = f.call(thisArg, init, obj[k], k, obj);\n            }\n        }\n        return init;\n    }\n}\nexports.reduce = reduce;\n/**\n * Returns true if any item returns true.\n */\nfunction some(arr, f) {\n    var i = 0;\n    for (var k = 0; k < arr.length; k++) {\n        if (f(arr[k], k, i++)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.some = some;\n/**\n * Returns true if all items return true.\n */\nfunction every(arr, f) {\n    var i = 0;\n    for (var k = 0; k < arr.length; k++) {\n        if (!f(arr[k], k, i++)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.every = every;\nfunction flatten(arrays) {\n    return [].concat.apply([], arrays);\n}\nexports.flatten = flatten;\n/**\n * recursively merges src into dest\n */\nfunction mergeDeep(dest) {\n    var src = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        src[_i - 1] = arguments[_i];\n    }\n    for (var _a = 0, src_1 = src; _a < src_1.length; _a++) {\n        var s = src_1[_a];\n        dest = deepMerge_(dest, s);\n    }\n    return dest;\n}\nexports.mergeDeep = mergeDeep;\n;\n// recursively merges src into dest\nfunction deepMerge_(dest, src) {\n    if (typeof src !== 'object' || src === null) {\n        return dest;\n    }\n    for (var p in src) {\n        if (!src.hasOwnProperty(p)) {\n            continue;\n        }\n        if (src[p] === undefined) {\n            continue;\n        }\n        if (typeof src[p] !== 'object' || vega_util_2.isArray(src[p]) || src[p] === null) {\n            dest[p] = src[p];\n        }\n        else if (typeof dest[p] !== 'object' || dest[p] === null) {\n            dest[p] = mergeDeep(src[p].constructor === Array ? [] : {}, src[p]);\n        }\n        else {\n            mergeDeep(dest[p], src[p]);\n        }\n    }\n    return dest;\n}\nfunction unique(values, f) {\n    var results = [];\n    var u = {};\n    var v;\n    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n        var val = values_1[_i];\n        v = f(val);\n        if (v in u) {\n            continue;\n        }\n        u[v] = 1;\n        results.push(val);\n    }\n    return results;\n}\nexports.unique = unique;\n;\n/**\n * Returns true if the two dictionaries disagree. Applies only to defined values.\n */\nfunction differ(dict, other) {\n    for (var key in dict) {\n        if (dict.hasOwnProperty(key)) {\n            if (other[key] && dict[key] && other[key] !== dict[key]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexports.differ = differ;\nexports.keys = Object.keys;\nfunction vals(x) {\n    var _vals = [];\n    for (var k in x) {\n        if (x.hasOwnProperty(k)) {\n            _vals.push(x[k]);\n        }\n    }\n    return _vals;\n}\nexports.vals = vals;\n;\nfunction duplicate(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nexports.duplicate = duplicate;\n;\nfunction isBoolean(b) {\n    return b === true || b === false;\n}\nexports.isBoolean = isBoolean;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsaURBQW1EO0FBQ25ELHVDQUFzRztBQUE5Riw2QkFBQSxNQUFNLENBQUE7QUFBRSw4QkFBQSxPQUFPLENBQUE7QUFBRSwrQkFBQSxRQUFRLENBQUE7QUFBRSwrQkFBQSxRQUFRLENBQUE7QUFBRSwrQkFBQSxRQUFRLENBQUE7QUFBRSwrQkFBQSxRQUFRLENBQUE7QUFBRSw0QkFBQSxLQUFLLENBQUE7QUFBRSxrQ0FBQSxXQUFXLENBQUE7QUFDbkYsdUNBQXNEO0FBRXREOzs7Ozs7Ozs7R0FTRztBQUNILGNBQXFCLEdBQVEsRUFBRSxLQUFlO0lBQzVDLElBQU0sSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUNoQixLQUFLLENBQUMsT0FBTyxDQUFDLFVBQUMsSUFBSTtRQUNqQixFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pCLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUNILE1BQU0sQ0FBQyxJQUFJLENBQUM7QUFDZCxDQUFDO0FBUkQsb0JBUUM7QUFFRDs7O0dBR0c7QUFDSCxjQUFxQixHQUFRLEVBQUUsS0FBZTtJQUM1QyxJQUFNLElBQUksR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDNUIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFDLElBQUk7UUFDakIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDcEIsQ0FBQyxDQUFDLENBQUM7SUFDSCxNQUFNLENBQUMsSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQU5ELG9CQU1DO0FBRUQsY0FBcUIsQ0FBTTtJQUN6QixFQUFFLENBQUMsQ0FBQyxvQkFBUSxDQUFDLENBQUMsQ0FB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",
    "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.vega = global.vega || {})));\n}(this, (function (exports) { 'use strict';\n\nvar accessor = function(fn, fields, name) {\n  return (\n    fn.fields = fields || [],\n    fn.fname = name,\n    fn\n  );\n}\n\nfunction accessorName(fn) {\n  return fn == null ? null : fn.fname;\n}\n\nfunction accessorFields(fn) {\n  return fn == null ? null : fn.fields;\n}\n\nvar error = function(message) {\n  throw Error(message);\n}\n\nvar splitAccessPath = function(p) {\n  var path = [],\n      q = null,\n      b = 0,\n      n = p.length,\n      s = '',\n      i, j, c;\n\n  p = p + '';\n\n  function push() {\n    path.push(s + p.substring(i, j));\n    s = '';\n    i = j + 1;\n  }\n\n  for (i=j=0; j<n; ++j) {\n    c = p[j];\n    if (c === '\\\\') s += p.substring(i, j), i = ++j;\n    else if (c === q) push(), q = null, b = -1;\n    else if (q) continue;\n    else if (i === b && c === '\"') i = j + 1, q = c;\n    else if (i === b && c === \"'\") i = j + 1, q = c;\n    else if (c === '.' && !b) (j > i) ? push() : (i = j + 1);\n    else if (c === '[') {\n      if (j > i) push();\n      b = i = j + 1;\n    }\n    else if (c === ']') {\n      if (!b) error('Access path missing open bracket: ' + p);\n      if (b > 0) push();\n      b = 0;\n      i = j + 1;\n    }\n  }\n\n  if (b) error('Access path missing closing bracket: ' + p);\n  if (q) error('Access path missing closing quote: ' + p);\n  if (j > i) ++j, push();\n  return path;\n}\n\nvar isArray = Array.isArray;\n\nvar isObject = function(_) {\n  return _ === Object(_);\n}\n\nvar isString = function(_) {\n  return typeof _ === 'string';\n}\n\nfunction $(x) {\n  return isArray(x) ? '[' + x.map($) + ']'\n    : isObject(x) || isString(x) ?\n      // Output valid JSON and JS source strings.\n      // See http://timelessrepo.com/json-isnt-a-javascript-subset\n      JSON.stringify(x).replace('\\u2028','\\\\u2028').replace('\\u2029', '\\\\u2029')\n    : x;\n}\n\nvar field = function(field, name) {\n  var path = splitAccessPath(field),\n      code = 'return _[' + path.map($).join('][') + '];';\n\n  return accessor(\n    Function('_', code),\n    [(field = path.length===1 ? path[0] : field)],\n    name || field\n  );\n}\n\nvar empty = [];\n\nvar id = field('id');\n\nvar identity = accessor(function(_) { return _; }, empty, 'identity');\n\nvar zero = accessor(function() { return 0; }, empty, 'zero');\n\nvar one = accessor(function() { return 1; }, empty, 'one');\n\nvar truthy = accessor(function() { return true; }, empty, 'true');\n\nvar falsy = accessor(function() { return false; }, empty, 'false');\n\nfunction log(method, level, input) {\n  var args = [level].concat([].slice.call(input));\n  console[method].apply(console, args); // eslint-disable-line no-console\n}\n\nvar None  = 0;\nvar Warn  = 1;\nvar Info  = 2;\nvar Debug = 3;\n\nvar logger = function(_) {\n  var level = _ || None;\n  return {\n    level: function(_) {\n      return arguments.length ? (level = +_, this) : level;\n    },\n    warn: function() {\n      if (level >= Warn) log('warn', 'WARN', arguments);\n      return this;\n    },\n    info: function() {\n      if (level >= Info) log('log', 'INFO', arguments);\n      return this;\n    },\n    debug: function() {\n      if (level >= Debug) log('log', 'DEBUG', arguments);\n      return this;\n    }\n  }\n}\n\nvar array = function(_) {\n  return _ != null ? (isArray(_) ? _ : [_]) : [];\n}\n\nvar compare = function(fields, orders) {\n  var idx = [],\n      cmp = (fields = array(fields)).map(function(f, i) {\n        return f == null ? null\n          : (idx.push(i), splitAccessPath(f).map($).join(']['));\n      }),\n      n = idx.length - 1,\n      ord = array(orders),\n      code = 'var u,v;return ',\n      i, j, f, u, v, d, lt, gt;\n\n  if (n < 0) return null;\n\n  for (j=0; j<=n; ++j) {\n    i = idx[j];\n    f = cmp[i];\n    u = '(u=a['+f+'])';\n    v = '(v=b['+f+'])';\n    d = '((v=v instanceof Date?+v:v),(u=u instanceof Date?+u:u))';\n    lt = ord[i] !== 'descending' ? (gt=1, -1) : (gt=-1, 1);\n    code += '(' + u+'<'+v+'||u==null)&&v!=null?' + lt\n      + ':(u>v||v==null)&&u!=null?' + gt\n      + ':'+d+'!==u&&v===v?' + lt\n      + ':v!==v&&u===u?' + gt\n      + (i < n ? ':' : ':0');\n  }\n\n  return accessor(\n    Function('a', 'b', code + ';'),\n    fields.filter(function(_) { return _ != null; })\n  );\n}\n\nvar isFunction = function(_) {\n  return typeof _ === 'function';\n}\n\nvar constant = function(_) {\n  return isFunction(_) ? _ : function() { return _; };\n}\n\nvar extend = function(_) {\n  for (var x, k, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (k in x) { _[k] = x[k]; }\n  }\n  return _;\n}\n\nvar extentIndex = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a, b, c, u, v;\n\n  if (f == null) {\n    while (++i < n) if ((b = array[i]) != null && b >= b) { a = c = b; break; }\n    u = v = i;\n    while (++i < n) if ((b = array[i]) != null) {\n      if (a > b) a = b, u = i;\n      if (c < b) c = b, v = i;\n    }\n  } else {\n    while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = c = b; break; }\n    u = v = i;\n    while (++i < n) if ((b = f(array[i], i, array)) != null) {\n      if (a > b) a = b, u = i;\n      if (c < b) c = b, v = i;\n    }\n  }\n\n  return [u, v];\n}\n\nvar NULL = {};\n\nvar fastmap = function(input) {\n  var obj = {},\n      map,\n      test;\n\n  function has(key) {\n    return obj.hasOwnProperty(key) && obj[key] !== NULL;\n  }\n\n  map = {\n    size: 0,\n    empty: 0,\n    object: obj,\n    has: has,\n    get: function(key) {\n      return has(key) ? obj[key] : undefined;\n    },\n    set: function(key, value) {\n      if (!has(key)) {\n        ++map.size;\n        if (obj[key] === NULL) --map.empty;\n      }\n      obj[key] = value;\n      return this;\n    },\n    delete: function(key) {\n      if (has(key)) {\n        --map.size;\n        ++map.empty;\n        obj[key] = NULL;\n      }\n      return this;\n    },\n    clear: function() {\n      map.size = map.empty = 0;\n      map.object = obj = {};\n    },\n    test: function(_) {\n      return arguments.length ? (test = _, map) : test;\n    },\n    clean: function() {\n      var next = {},\n          size = 0,\n          key, value;\n      for (key in obj) {\n        value = obj[key];\n        if (value !== NULL && (!test || !test(value))) {\n          next[key] = value;\n          ++size;\n        }\n      }\n      map.size = size;\n      map.empty = 0;\n      map.object = (obj = next);\n    }\n  };\n\n  if (input) Object.keys(input).forEach(function(key) {\n    map.set(key, input[key]);\n  });\n\n  return map;\n}\n\nvar inherits = function(child, parent) {\n  var proto = (child.prototype = Object.create(parent.prototype));\n  proto.constructor = child;\n  return proto;\n}\n\nvar isNumber = function(_) {\n  return typeof _ === 'number';\n}\n\nvar key = function(fields) {\n  fields = fields ? array(fields) : fields;\n  var fn = !(fields && fields.length)\n    ? function() { return ''; }\n    : Function('_', 'return \\'\\'+' +\n        fields.map(function(f) {\n          return '_[' + splitAccessPath(f).map($).join('][') + ']';\n        }).join('+\\'|\\'+') + ';');\n  return accessor(fn, fields, 'key');\n}\n\nvar merge = function(compare, array0, array1, output) {\n  var n0 = array0.length,\n      n1 = array1.length;\n\n  if (!n1) return array0;\n  if (!n0) return array1;\n\n  var merged = output || new array0.constructor(n0 + n1),\n      i0 = 0, i1 = 0, i = 0;\n\n  for (; i0<n0 && i1<n1; ++i) {\n    merged[i] = compare(array0[i0], array1[i1]) > 0\n       ? array1[i1++]\n       : array0[i0++];\n  }\n\n  for (; i0<n0; ++i0, ++i) {\n    merged[i] = array0[i0];\n  }\n\n  for (; i1<n1; ++i1, ++i) {\n    merged[i] = array1[i1];\n  }\n\n  return merged;\n}\n\nvar repeat = function(str, reps) {\n  var s = '';\n  while (--reps >= 0) s += str;\n  return s;\n}\n\nvar pad = function(str, length, padchar, align) {\n  var c = padchar || ' ',\n      s = str + '',\n      n = length - s.length;\n\n  return n <= 0 ? s\n    : align === 'left' ? repeat(c, n) + s\n    : align === 'center' ? repeat(c, ~~(n/2)) + s + repeat(c, Math.ceil(n/2))\n    : s + repeat(c, n);\n}\n\nvar peek = function(array) {\n  return array[array.length - 1];\n}\n\nvar toSet = function(_) {\n  for (var s={}, i=0, n=_.length; i<n; ++i) s[_[i]] = 1;\n  return s;\n}\n\nvar truncate = function(str, length, align, ellipsis) {\n  var e = ellipsis != null ? ellipsis : '\\u2026',\n      s = str + '',\n      n = s.length,\n      l = Math.max(0, length - e.length);\n\n  return n <= length ? s\n    : align === 'left' ? e + s.slice(n - l)\n    : align === 'center' ? s.slice(0, Math.ceil(l/2)) + e + s.slice(n - ~~(l/2))\n    : s.slice(0, l) + e;\n}\n\nvar visitArray = function(array, filter, visitor) {\n  if (array) {\n    var i = 0, n = array.length, t;\n    if (filter) {\n      for (; i<n; ++i) {\n        if (t = filter(array[i])) visitor(t, i, array);\n      }\n    } else {\n      array.forEach(visitor);\n    }\n  }\n}\n\nexports.accessor = accessor;\nexports.accessorName = accessorName;\nexports.accessorFields = accessorFields;\nexports.id = id;\nexports.identity = identity;\nexports.zero = zero;\nexports.one = one;\nexports.truthy = truthy;\nexports.falsy = falsy;\nexports.logger = logger;\nexports.None = None;\nexports.Warn = Warn;\nexports.Info = Info;\nexports.Debug = Debug;\nexports.array = array;\nexports.compare = compare;\nexports.constant = constant;\nexports.error = error;\nexports.extend = extend;\nexports.extentIndex = extentIndex;\nexports.fastmap = fastmap;\nexports.field = field;\nexports.inherits = inherits;\nexports.isArray = isArray;\nexports.isFunction = isFunction;\nexports.isNumber = isNumber;\nexports.isObject = isObject;\nexports.isString = isString;\nexports.key = key;\nexports.merge = merge;\nexports.pad = pad;\nexports.peek = peek;\nexports.repeat = repeat;\nexports.splitAccessPath = splitAccessPath;\nexports.stringValue = $;\nexports.toSet = toSet;\nexports.truncate = truncate;\nexports.visitArray = visitArray;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"
  ]
}