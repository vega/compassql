{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "node_modules/browser-resolve/empty.js",
    "node_modules/datalib/src/generate.js",
    "node_modules/datalib/src/import/type.js",
    "node_modules/datalib/src/stats.js",
    "node_modules/datalib/src/util.js",
    "src/config.js",
    "src/constraint/base.js",
    "src/constraint/constraint.js",
    "src/constraint/encoding.js",
    "src/constraint/spec.js",
    "src/cql.js",
    "src/enumerator.js",
    "src/generate.js",
    "src/model.js",
    "src/modelgroup.js",
    "src/nest.js",
    "src/property.js",
    "src/query.js",
    "src/ranking/effectiveness/channel.js",
    "src/ranking/effectiveness/effectiveness.js",
    "src/ranking/effectiveness/mark.js",
    "src/ranking/effectiveness/type.js",
    "src/ranking/ranking.js",
    "src/schema.js",
    "src/util.js",
    "../vega-lite/node_modules/d3-time/build/d3-time.js",
    "../vega-lite/node_modules/datalib/src/bins/bins.js",
    "../vega-lite/node_modules/datalib/src/time.js",
    "../vega-lite/node_modules/datalib/src/util.js",
    "../vega-lite/node_modules/json-stable-stringify/index.js",
    "../vega-lite/node_modules/jsonify/index.js",
    "../vega-lite/node_modules/jsonify/lib/parse.js",
    "../vega-lite/node_modules/jsonify/lib/stringify.js",
    "../vega-lite/src/aggregate.js",
    "../vega-lite/src/channel.js",
    "../vega-lite/src/encoding.js",
    "../vega-lite/src/mark.js",
    "../vega-lite/src/scale.js",
    "../vega-lite/src/stack.js",
    "../vega-lite/src/timeunit.js",
    "../vega-lite/src/type.js",
    "../vega-lite/src/util.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "",
    "var util = require('./util'),\n    gen = module.exports;\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x >= min && x <= max) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    return x < min ? 0 : x > max ? 1 : (x - min) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? min + p*d : NaN;\n  };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x === Math.floor(x) && x >= a && x < b) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    var v = Math.floor(x);\n    return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? a - 1 + Math.floor(p*d) : NaN;\n  };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    var exp = Math.exp(Math.pow(x-mean, 2) / (-2 * Math.pow(stdev, 2)));\n    return (1 / (stdev * Math.sqrt(2*Math.PI))) * exp;\n  };\n  f.cdf = function(x) {\n    // Approximation from West (2009)\n    // Better Approximations to Cumulative Normal Functions\n    var cd,\n        z = (x - mean) / stdev,\n        Z = Math.abs(z);\n    if (Z > 37) {\n      cd = 0;\n    } else {\n      var sum, exp = Math.exp(-Z*Z/2);\n      if (Z < 7.07106781186547) {\n        sum = 3.52624965998911e-02 * Z + 0.700383064443688;\n        sum = sum * Z + 6.37396220353165;\n        sum = sum * Z + 33.912866078383;\n        sum = sum * Z + 112.079291497871;\n        sum = sum * Z + 221.213596169931;\n        sum = sum * Z + 220.206867912376;\n        cd = exp * sum;\n        sum = 8.83883476483184e-02 * Z + 1.75566716318264;\n        sum = sum * Z + 16.064177579207;\n        sum = sum * Z + 86.7807322029461;\n        sum = sum * Z + 296.564248779674;\n        sum = sum * Z + 637.333633378831;\n        sum = sum * Z + 793.826512519948;\n        sum = sum * Z + 440.413735824752;\n        cd = cd / sum;\n      } else {\n        sum = Z + 0.65;\n        sum = Z + 4 / sum;\n        sum = Z + 3 / sum;\n        sum = Z + 2 / sum;\n        sum = Z + 1 / sum;\n        cd = exp / sum / 2.506628274631;\n      }\n    }\n    return z > 0 ? 1 - cd : cd;\n  };\n  f.icdf = function(p) {\n    // Approximation of Probit function using inverse error function.\n    if (p <= 0 || p >= 1) return NaN;\n    var x = 2*p - 1,\n        v = (8 * (Math.PI - 3)) / (3 * Math.PI * (4-Math.PI)),\n        a = (2 / (Math.PI*v)) + (Math.log(1 - Math.pow(x,2)) / 2),\n        b = Math.log(1 - (x*x)) / v,\n        s = (x > 0 ? 1 : -1) * Math.sqrt(Math.sqrt((a*a) - b) - a);\n    return mean + stdev * Math.SQRT2 * s;\n  };\n  return f;\n};\n\ngen.random.bootstrap = function(domain, smooth) {\n  // Generates a bootstrap sample from a set of observations.\n  // Smooth bootstrapping adds random zero-centered noise to the samples.\n  var val = domain.filter(util.isValid),\n      len = val.length,\n      err = smooth ? gen.random.normal(0, smooth) : null;\n  var f = function() {\n    return val[~~(Math.random()*len)] + (err ? err() : 0);\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  return f;\n};",
    "var util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, f);\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n",
    "var util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\n\nvar stats = module.exports;\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the geometric mean of an array of numbers.\nstats.mean.geometric = function(values, f) {\n  f = util.$(f);\n  var mean = 1, c, n, v, i;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v <= 0) {\n        throw Error(\"Geometric mean only defined for positive values.\");\n      }\n      mean *= v;\n      ++c;\n    }\n  }\n  mean = c > 0 ? Math.pow(mean, 1/c) : 0;\n  return mean;\n};\n\n// Compute the harmonic mean of an array of numbers.\nstats.mean.harmonic = function(values, f) {\n  f = util.$(f);\n  var mean = 0, c, n, v, i;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      mean += 1/v;\n      ++c;\n    }\n  }\n  return c / mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Compute the Cohen's d effect size between two arrays of numbers.\nstats.cohensd = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      x1 = stats.mean(X),\n      x2 = stats.mean(Y),\n      n1 = stats.count.valid(X),\n      n2 = stats.count.valid(Y);\n\n  if ((n1+n2-2) <= 0) {\n    // if both arrays are size 1, or one is empty, there's no effect size\n    return 0;\n  }\n  // pool standard deviation\n  var s1 = stats.variance(X),\n      s2 = stats.variance(Y),\n      s = Math.sqrt((((n1-1)*s1) + ((n2-1)*s2)) / (n1+n2-2));\n  // if there is no variance, there's no effect size\n  return s===0 ? 0 : (x1 - x2) / s;\n};\n\n// Computes the covariance between two arrays of numbers\nstats.covariance = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n = X.length,\n      xm = stats.mean(X),\n      ym = stats.mean(Y),\n      sum = 0, c = 0, i, x, y, vx, vy;\n\n  if (n !== Y.length) {\n    throw Error('Input lengths must match.');\n  }\n\n  for (i=0; i<n; ++i) {\n    x = X[i]; vx = util.isValid(x);\n    y = Y[i]; vy = util.isValid(y);\n    if (vx && vy) {\n      sum += (x-xm) * (y-ym);\n      ++c;\n    } else if (vx || vy) {\n      throw Error('Valid values must align.');\n    }\n  }\n  return sum / (c-1);\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, a) : stats.rank(values),\n      rb = b ? stats.rank(values, b) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Simple linear regression.\n// Returns a \"fit\" object with slope (m), intercept (b),\n// r value (R), and sum-squared residual error (rss).\nstats.linearRegression = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n = X.length,\n      xy = stats.covariance(X, Y), // will throw err if valid vals don't align\n      sx = stats.stdev(X),\n      sy = stats.stdev(Y),\n      slope = xy / (sx*sx),\n      icept = stats.mean(Y) - slope * stats.mean(X),\n      fit = {slope: slope, intercept: icept, R: xy / (sx*sy), rss: 0},\n      res, i;\n\n  for (i=0; i<n; ++i) {\n    if (util.isValid(X[i]) && util.isValid(Y[i])) {\n      res = (slope*X[i] + icept) - Y[i];\n      fit.rss += res * res;\n    }\n  }\n\n  return fit;\n};\n\n// Namespace for bootstrap\nstats.bootstrap = {};\n\n// Construct a bootstrapped confidence interval at a given percentile level\n// Arguments are an array, an optional n (defaults to 1000),\n//  an optional alpha (defaults to 0.05), and an optional smoothing parameter\nstats.bootstrap.ci = function(values, a, b, c, d) {\n  var X, N, alpha, smooth, bs, means, i;\n  if (util.isFunction(a) || util.isString(a)) {\n    X = values.map(util.$(a));\n    N = b;\n    alpha = c;\n    smooth = d;\n  } else {\n    X = values;\n    N = a;\n    alpha = b;\n    smooth = c;\n  }\n  N = N ? +N : 1000;\n  alpha = alpha || 0.05;\n\n  bs = gen.random.bootstrap(X, smooth);\n  for (i=0, means = Array(N); i<N; ++i) {\n    means[i] = stats.mean(bs.samples(X.length));\n  }\n  means.sort(util.numcmp);\n  return [\n    stats.quantile(means, alpha/2),\n    stats.quantile(means, 1-(alpha/2))\n  ];\n};\n\n// Namespace for z-tests\nstats.z = {};\n\n// Construct a z-confidence interval at a given significance level\n// Arguments are an array and an optional alpha (defaults to 0.05).\nstats.z.ci = function(values, a, b) {\n  var X = values, alpha = a;\n  if (util.isFunction(a) || util.isString(a)) {\n    X = values.map(util.$(a));\n    alpha = b;\n  }\n  alpha = alpha || 0.05;\n\n  var z = alpha===0.05 ? 1.96 : gen.random.normal(0, 1).icdf(1-(alpha/2)),\n      mu = stats.mean(X),\n      SE = stats.stdev(X) / Math.sqrt(stats.count.valid(X));\n  return [mu - (z*SE), mu + (z*SE)];\n};\n\n// Perform a z-test of means. Returns the p-value.\n// If a single array is provided, performs a one-sample location test.\n// If two arrays or a table and two accessors are provided, performs\n// a two-sample location test. A paired test is performed if specified\n// by the options hash.\n// The options hash format is: {paired: boolean, nullh: number}.\n// http://en.wikipedia.org/wiki/Z-test\n// http://en.wikipedia.org/wiki/Paired_difference_test\nstats.z.test = function(values, a, b, opt) {\n  if (util.isFunction(b) || util.isString(b)) { // table and accessors\n    return (opt && opt.paired ? ztestP : ztest2)(opt, values, a, b);\n  } else if (util.isArray(a)) { // two arrays\n    return (b && b.paired ? ztestP : ztest2)(b, values, a);\n  } else if (util.isFunction(a) || util.isString(a)) {\n    return ztest1(b, values, a); // table and accessor\n  } else {\n    return ztest1(a, values); // one array\n  }\n};\n\n// Perform a z-test of means. Returns the p-value.\n// Assuming we have a list of values, and a null hypothesis. If no null\n// hypothesis, assume our null hypothesis is mu=0.\nfunction ztest1(opt, X, f) {\n  var nullH = opt && opt.nullh || 0,\n      gaussian = gen.random.normal(0, 1),\n      mu = stats.mean(X,f),\n      SE = stats.stdev(X,f) / Math.sqrt(stats.count.valid(X,f));\n\n  if (SE===0) {\n    // Test not well defined when standard error is 0.\n    return (mu - nullH) === 0 ? 1 : 0;\n  }\n  // Two-sided, so twice the one-sided cdf.\n  var z = (mu - nullH) / SE;\n  return 2 * gaussian.cdf(-Math.abs(z));\n}\n\n// Perform a two sample paired z-test of means. Returns the p-value.\nfunction ztestP(opt, values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n1 = stats.count(X),\n      n2 = stats.count(Y),\n      diffs = Array(), i;\n\n  if (n1 !== n2) {\n    throw Error('Array lengths must match.');\n  }\n  for (i=0; i<n1; ++i) {\n    // Only valid differences should contribute to the test statistic\n    if (util.isValid(X[i]) && util.isValid(Y[i])) {\n      diffs.push(X[i] - Y[i]);\n    }\n  }\n  return stats.z.test(diffs, opt && opt.nullh || 0);\n}\n\n// Perform a two sample z-test of means. Returns the p-value.\nfunction ztest2(opt, values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n1 = stats.count.valid(X),\n      n2 = stats.count.valid(Y),\n      gaussian = gen.random.normal(0, 1),\n      meanDiff = stats.mean(X) - stats.mean(Y) - (opt && opt.nullh || 0),\n      SE = Math.sqrt(stats.variance(X)/n1 + stats.variance(Y)/n2);\n\n  if (SE===0) {\n    // Not well defined when pooled standard error is 0.\n    return meanDiff===0 ? 1 : 0;\n  }\n  // Two-tailed, so twice the one-sided cdf.\n  var z = meanDiff / SE;\n  return 2 * gaussian.cdf(-Math.abs(z));\n}\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance]\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n",
    "var u = module.exports;\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (typeof Buffer === 'function' && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\n// parse a date with optional d3.time-format format\nu.date = function(s, format) {\n  var d = format ? format : Date;\n  return s == null || s === '' ? null : d.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) || u.isString(x) ?\n      // Output valid JSON and JS source strings.\n      // See http://timelessrepo.com/json-isnt-a-javascript-subset\n      JSON.stringify(x).replace('\\u2028','\\\\u2028').replace('\\u2029', '\\\\u2029')\n    : x;\n};\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  /* jshint evil: true */\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, Function('x', 'return x[' + u.field(f).map(u.str).join('][') + '];'));\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n// permutes an array using a Knuth shuffle\nu.permute = function(a) {\n  var m = a.length,\n      swap,\n      i;\n\n  while (m) {\n    i = Math.floor(Math.random() * m--);\n    swap = a[m];\n    a[m] = a[i];\n    a[i] = swap;\n  }\n};\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n",
    "\"use strict\";\nvar channel_1 = require('vega-lite/src/channel');\nvar aggregate_1 = require('vega-lite/src/aggregate');\nvar mark_1 = require('vega-lite/src/mark');\nvar scale_1 = require('vega-lite/src/scale');\nvar timeunit_1 = require('vega-lite/src/timeunit');\nvar type_1 = require('vega-lite/src/type');\nvar property_1 = require('./property');\nexports.DEFAULT_QUERY_CONFIG = {\n    verbose: false,\n    defaultSpecConfig: {\n        overlay: { line: true },\n        scale: { useRawDomain: true }\n    },\n    propertyPrecedence: property_1.DEFAULT_PROPERTY_PRECENCE,\n    marks: [mark_1.Mark.POINT, mark_1.Mark.BAR, mark_1.Mark.LINE, mark_1.Mark.AREA, mark_1.Mark.TICK],\n    channels: [channel_1.X, channel_1.Y, channel_1.ROW, channel_1.COLUMN, channel_1.SIZE, channel_1.COLOR],\n    aggregates: [undefined, aggregate_1.AggregateOp.MEAN],\n    timeUnits: [undefined, timeunit_1.TimeUnit.YEAR, timeunit_1.TimeUnit.MONTH, timeunit_1.TimeUnit.DAY, timeunit_1.TimeUnit.DATE],\n    types: [type_1.Type.NOMINAL, type_1.Type.ORDINAL, type_1.Type.QUANTITATIVE, type_1.Type.TEMPORAL],\n    numberOrdinalProportion: .05,\n    maxBinsList: [5, 10, 20],\n    scaleTypes: [scale_1.ScaleType.LINEAR, scale_1.ScaleType.LOG],\n    // CONSTRAINTS\n    // Spec Constraints -- See description inside src/constraints/spec.ts\n    autoAddCount: false,\n    hasAppropriateGraphicTypeForMark: true,\n    omitAggregatePlotWithDimensionOnlyOnFacet: true,\n    omitBarLineAreaWithOcclusion: true,\n    omitBarTickWithSize: true,\n    omitFacetOverPositionalChannels: true,\n    omitMultipleNonPositionalChannels: true,\n    omitNonSumStack: true,\n    omitRawContinuousFieldForAggregatePlot: true,\n    omitRepeatedField: true,\n    omitNonPositionalOverPositionalChannels: true,\n    omitTableWithOcclusion: true,\n    omitVerticalDotPlot: false,\n    preferredBinAxis: channel_1.Channel.X,\n    preferredTemporalAxis: channel_1.Channel.X,\n    preferredOrdinalAxis: channel_1.Channel.Y,\n    preferredNominalAxis: channel_1.Channel.Y,\n    preferredFacet: channel_1.Channel.ROW,\n    // Encoding Constraints -- See description inside src/constraints/encoding.ts\n    maxCardinalityForCategoricalColor: 20,\n    maxCardinalityForFacet: 10,\n    maxCardinalityForShape: 6,\n    typeMatchesSchemaType: true,\n    // Ranking Preference\n    maxGoodCardinalityForFacet: 5,\n    maxGoodCardinalityForColor: 7,\n};\n//# sourceMappingURL=config.js.map",
    "\"use strict\";\n/**\n * Abstract model for a constraint.\n */\nvar AbstractConstraintModel = (function () {\n    function AbstractConstraintModel(constraint) {\n        this.constraint = constraint;\n    }\n    AbstractConstraintModel.prototype.name = function () {\n        return this.constraint.name;\n    };\n    AbstractConstraintModel.prototype.description = function () {\n        return this.constraint.description;\n    };\n    AbstractConstraintModel.prototype.properties = function () {\n        return this.constraint.properties;\n    };\n    AbstractConstraintModel.prototype.strict = function () {\n        return this.constraint.strict;\n    };\n    return AbstractConstraintModel;\n}());\nexports.AbstractConstraintModel = AbstractConstraintModel;\n//# sourceMappingURL=base.js.map",
    "\"use strict\";\nvar _encoding = require('./encoding');\nvar _spec = require('./spec');\nexports.encoding = _encoding;\nexports.spec = _spec;\n//# sourceMappingURL=constraint.js.map",
    "\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar channel_1 = require('vega-lite/src/channel');\nvar type_1 = require('vega-lite/src/type');\nvar property_1 = require('../property');\nvar query_1 = require('../query');\nvar schema_1 = require('../schema');\nvar util_1 = require('../util');\nvar scale_1 = require('vega-lite/src/scale');\nvar base_1 = require('./base');\nvar EncodingConstraintModel = (function (_super) {\n    __extends(EncodingConstraintModel, _super);\n    function EncodingConstraintModel(constraint) {\n        _super.call(this, constraint);\n    }\n    EncodingConstraintModel.prototype.satisfy = function (encQ, schema, opt) {\n        // TODO: Re-order logic to optimize the \"requireAllProperties\" check\n        if (this.constraint.requireAllProperties) {\n            // TODO: extract as a method and do unit test\n            var hasRequiredPropertyAsEnumSpec = util_1.some(this.constraint.properties, function (prop) { return query_1.isEnumSpec(encQ[prop]); });\n            // If one of the required property is still an enum spec, do not check the constraint yet.\n            if (hasRequiredPropertyAsEnumSpec) {\n                return true; // Return true since the query still satisfy the constraint.\n            }\n        }\n        return this.constraint.satisfy(encQ, schema, opt);\n    };\n    return EncodingConstraintModel;\n}(base_1.AbstractConstraintModel));\nexports.EncodingConstraintModel = EncodingConstraintModel;\nexports.ENCODING_CONSTRAINTS = [\n    {\n        name: 'aggregateOpSupportedByType',\n        description: 'Aggregate function should be supported by data type.',\n        properties: [property_1.Property.TYPE, property_1.Property.AGGREGATE],\n        requireAllProperties: true,\n        strict: true,\n        satisfy: function (encQ, schema, opt) {\n            if (encQ.aggregate) {\n                return encQ.type !== type_1.Type.ORDINAL && encQ.type !== type_1.Type.NOMINAL;\n            }\n            // TODO: some aggregate function are actually supported by ordinal\n            return true; // no aggregate is okay with any type.\n        }\n    }, {\n        name: 'binAppliedForQuantitative',\n        description: 'bin should be applied to quantitative field only.',\n        properties: [property_1.Property.TYPE, property_1.Property.BIN],\n        requireAllProperties: true,\n        strict: true,\n        satisfy: function (encQ, schema, opt) {\n            if (encQ.bin) {\n                // If binned, the type must be quantitative\n                return encQ.type === type_1.Type.QUANTITATIVE;\n            }\n            return true;\n        }\n    }, {\n        name: 'channelSupportsRole',\n        description: 'encoding channel should support the role of the field',\n        properties: [property_1.Property.CHANNEL, property_1.Property.TYPE, property_1.Property.BIN, property_1.Property.TIMEUNIT],\n        requireAllProperties: false,\n        strict: true,\n        satisfy: function (encQ, schema, opt) {\n            if (query_1.isEnumSpec(encQ.channel))\n                return true; // not ready for checking yet!\n            var supportedRole = channel_1.getSupportedRole(encQ.channel);\n            if (query_1.isDimension(encQ)) {\n                return supportedRole.dimension;\n            }\n            else if (query_1.isMeasure(encQ)) {\n                return supportedRole.measure;\n            }\n            return true;\n        }\n    }, {\n        name: 'onlyOneTypeOfFunction',\n        description: 'Only of of aggregate, autoCount, timeUnit, or bin should be applied at the same time.',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.TIMEUNIT, property_1.Property.BIN],\n        requireAllProperties: false,\n        strict: true,\n        satisfy: function (encQ, schema, opt) {\n            var numFn = (!query_1.isEnumSpec(encQ.aggregate) && !!encQ.aggregate ? 1 : 0) +\n                (!query_1.isEnumSpec(encQ.autoCount) && !!encQ.autoCount ? 1 : 0) +\n                (!query_1.isEnumSpec(encQ.bin) && !!encQ.bin ? 1 : 0) +\n                (!query_1.isEnumSpec(encQ.timeUnit) && !!encQ.timeUnit ? 1 : 0);\n            return numFn <= 1;\n        }\n    }, {\n        name: 'timeUnitAppliedForTemporal',\n        description: 'Time unit should be applied to temporal field only.',\n        properties: [property_1.Property.TYPE, property_1.Property.TIMEUNIT],\n        requireAllProperties: true,\n        strict: true,\n        satisfy: function (encQ, schema, opt) {\n            if (encQ.timeUnit && encQ.type !== type_1.Type.TEMPORAL) {\n                return false;\n            }\n            return true;\n        }\n    },\n    {\n        name: 'typeMatchesPrimitiveType',\n        description: 'Data type should be supported by field\\'s primitive type.',\n        properties: [property_1.Property.FIELD, property_1.Property.TYPE],\n        requireAllProperties: true,\n        strict: true,\n        satisfy: function (encQ, schema, opt) {\n            var primitiveType = schema.primitiveType(encQ.field);\n            var type = encQ.type;\n            switch (primitiveType) {\n                case schema_1.PrimitiveType.BOOLEAN:\n                case schema_1.PrimitiveType.STRING:\n                    return type !== type_1.Type.QUANTITATIVE && type !== type_1.Type.TEMPORAL;\n                case schema_1.PrimitiveType.NUMBER:\n                case schema_1.PrimitiveType.INTEGER:\n                    return type !== type_1.Type.TEMPORAL;\n                case schema_1.PrimitiveType.DATE:\n                    // TODO: add NOMINAL, ORDINAL support after we support this in Vega-Lite\n                    return type === type_1.Type.TEMPORAL;\n                case null:\n                    // field does not exist in the schema\n                    return false;\n            }\n            throw new Error('Not implemented');\n        }\n    },\n    {\n        name: 'typeMatchesSchemaType',\n        description: 'Enumerated data type of a field should match the field\\'s type in the schema.',\n        properties: [property_1.Property.FIELD, property_1.Property.TYPE],\n        requireAllProperties: true,\n        strict: false,\n        satisfy: function (encQ, schema, opt) {\n            return schema.type(encQ.field) === encQ.type;\n        }\n    }, {\n        name: 'maxCardinalityForCategoricalColor',\n        description: 'Categorical channel should not have too high cardinality',\n        properties: [property_1.Property.CHANNEL, property_1.Property.FIELD],\n        requireAllProperties: true,\n        strict: false,\n        satisfy: function (encQ, schema, opt) {\n            // TODO: missing case where ordinal / temporal use categorical color\n            // (once we do so, need to add Property.BIN, Property.TIMEUNIT)\n            if (encQ.channel === channel_1.Channel.COLOR && encQ.type === type_1.Type.NOMINAL) {\n                return schema.cardinality(encQ) <= opt.maxCardinalityForCategoricalColor;\n            }\n            return true; // other channel is irrelevant to this constraint\n        }\n    }, {\n        name: 'maxCardinalityForFacet',\n        description: 'Row/column channel should not have too high cardinality',\n        properties: [property_1.Property.CHANNEL, property_1.Property.FIELD, property_1.Property.BIN, property_1.Property.TIMEUNIT],\n        requireAllProperties: true,\n        strict: false,\n        satisfy: function (encQ, schema, opt) {\n            if (encQ.channel === channel_1.Channel.ROW || encQ.channel === channel_1.Channel.COLUMN) {\n                return schema.cardinality(encQ) <= opt.maxCardinalityForFacet;\n            }\n            return true; // other channel is irrelevant to this constraint\n        }\n    }, {\n        name: 'maxCardinalityForShape',\n        description: 'Shape channel should not have too high cardinality',\n        properties: [property_1.Property.CHANNEL, property_1.Property.FIELD, property_1.Property.BIN, property_1.Property.TIMEUNIT],\n        requireAllProperties: true,\n        strict: false,\n        satisfy: function (encQ, schema, opt) {\n            if (encQ.channel === channel_1.Channel.SHAPE) {\n                return schema.cardinality(encQ) <= opt.maxCardinalityForShape;\n            }\n            return true; // other channel is irrelevant to this constraint\n        }\n    }, {\n        name: 'dataTypeAndFunctionMatchScaleType',\n        description: 'Scale type must match data type',\n        properties: [property_1.Property.TYPE, property_1.Property.SCALE_TYPE, property_1.Property.TIMEUNIT, property_1.Property.BIN],\n        requireAllProperties: true,\n        strict: true,\n        satisfy: function (encQ, schema, opt) {\n            if (encQ.scale) {\n                var scaleType = encQ.scale.type;\n                var type = encQ.type;\n                if (util_1.contains([type_1.Type.ORDINAL, type_1.Type.NOMINAL], type)) {\n                    return util_1.contains([scale_1.ScaleType.ORDINAL, undefined], scaleType);\n                }\n                else if (type === type_1.Type.TEMPORAL) {\n                    if (!encQ.timeUnit) {\n                        return util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, undefined], scaleType);\n                    }\n                    else {\n                        return util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, scale_1.ScaleType.ORDINAL, undefined], scaleType);\n                    }\n                }\n                else if (type === type_1.Type.QUANTITATIVE) {\n                    if (encQ.bin) {\n                        return util_1.contains([scale_1.ScaleType.LINEAR, undefined], scaleType);\n                    }\n                    else {\n                        return util_1.contains([scale_1.ScaleType.LOG, scale_1.ScaleType.POW, scale_1.ScaleType.SQRT, scale_1.ScaleType.QUANTILE, scale_1.ScaleType.QUANTIZE, scale_1.ScaleType.LINEAR, undefined], scaleType);\n                    }\n                }\n            }\n            return true;\n        }\n    }\n].map(function (ec) { return new EncodingConstraintModel(ec); });\nexports.ENCODING_CONSTRAINT_INDEX = exports.ENCODING_CONSTRAINTS.reduce(function (m, ec) {\n    m[ec.name()] = ec;\n    return m;\n}, {});\nexports.ENCODING_CONSTRAINTS_BY_PROPERTY = exports.ENCODING_CONSTRAINTS.reduce(function (m, c) {\n    c.properties().forEach(function (prop) {\n        m[prop] = m[prop] || [];\n        m[prop].push(c);\n    });\n    return m;\n}, {});\n/**\n * Check all encoding constraints for a particular property and index tuple\n */\nfunction checkEncoding(prop, indexTuple, specM, schema, opt) {\n    // Check encoding constraint\n    var encodingConstraints = exports.ENCODING_CONSTRAINTS_BY_PROPERTY[prop] || [];\n    var encQ = specM.getEncodingQueryByIndex(indexTuple.index);\n    for (var i = 0; i < encodingConstraints.length; i++) {\n        var c = encodingConstraints[i];\n        // Check if the constraint is enabled\n        if (c.strict() || !!opt[c.name()]) {\n            // For strict constraint, or enabled non-strict, check the constraints\n            var satisfy = c.satisfy(encQ, schema, opt);\n            if (!satisfy) {\n                var violatedConstraint = '(enc) ' + c.name();\n                /* istanbul ignore if */\n                if (opt.verbose) {\n                    console.log(violatedConstraint + ' failed with ' + specM.toShorthand() + ' for ' + indexTuple.enumSpec.name);\n                }\n                return violatedConstraint;\n            }\n        }\n    }\n    return null;\n}\nexports.checkEncoding = checkEncoding;\n//# sourceMappingURL=encoding.js.map",
    "\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar aggregate_1 = require('vega-lite/src/aggregate');\nvar channel_1 = require('vega-lite/src/channel');\nvar mark_1 = require('vega-lite/src/mark');\nvar scale_1 = require('vega-lite/src/scale');\nvar type_1 = require('vega-lite/src/type');\nvar base_1 = require('./base');\nvar property_1 = require('../property');\nvar query_1 = require('../query');\nvar util_1 = require('../util');\nvar SpecConstraintModel = (function (_super) {\n    __extends(SpecConstraintModel, _super);\n    function SpecConstraintModel(specConstraint) {\n        _super.call(this, specConstraint);\n    }\n    SpecConstraintModel.prototype.satisfy = function (specM, schema, opt) {\n        // TODO: Re-order logic to optimize the \"requireAllProperties\" check\n        if (this.constraint.requireAllProperties) {\n            // TODO: extract as a method and do unit test\n            var hasRequiredPropertyAsEnumSpec = util_1.some(this.constraint.properties, function (prop) {\n                switch (prop) {\n                    // Mark\n                    case property_1.Property.MARK:\n                        return query_1.isEnumSpec(specM.getMark());\n                    // TODO: transform\n                    // Encoding properties\n                    case property_1.Property.CHANNEL:\n                    case property_1.Property.AGGREGATE:\n                    case property_1.Property.AUTOCOUNT:\n                    case property_1.Property.BIN:\n                    case property_1.Property.SCALE:\n                    case property_1.Property.TIMEUNIT:\n                    case property_1.Property.FIELD:\n                    case property_1.Property.TYPE:\n                        // If there is property that is enumSpec, we return true as\n                        // we cannot check the constraint yet!\n                        return util_1.some(specM.getEncodings(), function (encQ) {\n                            return query_1.isEnumSpec(encQ[prop]);\n                        });\n                    default:\n                        /* istanbul ignore next */\n                        throw new Error('Unimplemented');\n                }\n            });\n            // If one of the required property is still an enum spec, do not check the constraint yet.\n            if (hasRequiredPropertyAsEnumSpec) {\n                return true; // Return true since the query still satisfy the constraint.\n            }\n        }\n        return this.constraint.satisfy(specM, schema, opt);\n    };\n    return SpecConstraintModel;\n}(base_1.AbstractConstraintModel));\nexports.SpecConstraintModel = SpecConstraintModel;\nexports.SPEC_CONSTRAINTS = [\n    {\n        name: 'noRepeatedChannel',\n        description: 'Each encoding channel should only be used once.',\n        properties: [property_1.Property.CHANNEL],\n        requireAllProperties: false,\n        strict: true,\n        satisfy: function (specM, schema, opt) {\n            var usedChannel = {};\n            // channel for all encodings should be valid\n            return util_1.every(specM.getEncodings(), function (encQ) {\n                if (!query_1.isEnumSpec(encQ.channel)) {\n                    // If channel is specified, it should no be used already\n                    if (usedChannel[encQ.channel]) {\n                        return false;\n                    }\n                    usedChannel[encQ.channel] = true;\n                    return true;\n                }\n                return true; // unspecified channel is valid\n            });\n        }\n    },\n    {\n        name: 'autoAddCount',\n        description: 'Automatically adding count only for plots with only ordinal, binned quantitative, or temporal with timeunit fields.',\n        properties: [property_1.Property.BIN, property_1.Property.TIMEUNIT, property_1.Property.TYPE, property_1.Property.AUTOCOUNT],\n        requireAllProperties: false,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            var hasAutoCount = util_1.some(specM.getEncodings(), function (encQ) { return encQ.autoCount === true; });\n            if (hasAutoCount) {\n                // Auto count should only be applied if all fields are nominal, ordinal, temporal with timeUnit, binned quantitative, or autoCount\n                return util_1.every(specM.getEncodings(), function (encQ) {\n                    if (encQ.autoCount !== undefined) {\n                        return true;\n                    }\n                    switch (encQ.type) {\n                        case type_1.Type.QUANTITATIVE:\n                            return !!encQ.bin;\n                        case type_1.Type.TEMPORAL:\n                            return !!encQ.timeUnit;\n                        case type_1.Type.ORDINAL:\n                        case type_1.Type.NOMINAL:\n                            return true;\n                    }\n                    /* istanbul ignore next */\n                    throw new Error('Unsupported Type');\n                });\n            }\n            else {\n                var neverHaveAutoCount = util_1.every(specM.enumSpecIndex.autoCount, function (indexTuple) {\n                    return !query_1.isEnumSpec(specM.getEncodingQueryByIndex(indexTuple.index).autoCount);\n                });\n                if (neverHaveAutoCount) {\n                    // If the query surely does not have autoCount\n                    // then one of the field should be\n                    // (1) unbinned quantitative\n                    // (2) temporal without time unit\n                    // (3) nominal or ordinal field\n                    // or at least have potential to be (still ambiguous).\n                    return util_1.some(specM.getEncodings(), function (encQ) {\n                        if (encQ.type === type_1.Type.QUANTITATIVE) {\n                            if (encQ.autoCount === false) {\n                                return false;\n                            }\n                            else {\n                                return !encQ.bin || query_1.isEnumSpec(encQ.bin);\n                            }\n                        }\n                        else if (encQ.type === type_1.Type.TEMPORAL) {\n                            return !encQ.timeUnit || query_1.isEnumSpec(encQ.timeUnit);\n                        }\n                        return false; // nominal or ordinal\n                    });\n                }\n            }\n            return true; // no auto count, no constraint\n        }\n    },\n    {\n        name: 'channelPermittedByMarkType',\n        description: 'Each encoding channel should be supported by the mark type',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK],\n        requireAllProperties: false,\n        strict: true,\n        satisfy: function (specM, schema, opt) {\n            var mark = specM.getMark();\n            // if mark is unspecified, no need to check\n            if (query_1.isEnumSpec(mark))\n                return true;\n            // TODO: can optimize this to detect only what's the changed property if needed.\n            return util_1.every(specM.getEncodings(), function (encQ) {\n                // channel unspecified, no need to check\n                if (query_1.isEnumSpec(encQ.channel))\n                    return true;\n                return channel_1.supportMark(encQ.channel, mark);\n            });\n        }\n    },\n    {\n        name: 'hasAllRequiredChannelsForMark',\n        description: 'All required channels for the specified mark should be specified',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK],\n        requireAllProperties: true,\n        strict: true,\n        satisfy: function (specM, schema, opt) {\n            var mark = specM.getMark();\n            switch (mark) {\n                case mark_1.Mark.AREA:\n                case mark_1.Mark.LINE:\n                    return specM.channelUsed(channel_1.Channel.X) && specM.channelUsed(channel_1.Channel.Y);\n                case mark_1.Mark.TEXT:\n                    return specM.channelUsed(channel_1.Channel.TEXT);\n                case mark_1.Mark.BAR:\n                case mark_1.Mark.CIRCLE:\n                case mark_1.Mark.POINT:\n                case mark_1.Mark.SQUARE:\n                case mark_1.Mark.TICK:\n                case mark_1.Mark.RULE:\n                    return specM.channelUsed(channel_1.Channel.X) || specM.channelUsed(channel_1.Channel.Y);\n            }\n            /* istanbul ignore next */\n            throw new Error('hasAllRequiredChannelsForMark not implemented for mark' + mark);\n        }\n    },\n    {\n        name: 'omitAggregatePlotWithDimensionOnlyOnFacet',\n        description: 'All required channels for the specified mark should be specified',\n        properties: [property_1.Property.CHANNEL, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        requireAllProperties: true,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            if (specM.isAggregate()) {\n                var hasNonFacetDim_1 = false, hasDim_1 = false;\n                specM.getEncodings().forEach(function (encQ) {\n                    if (!encQ.aggregate && !encQ.autoCount) {\n                        hasDim_1 = true;\n                        if (!util_1.contains([channel_1.Channel.ROW, channel_1.Channel.COLUMN], encQ.channel)) {\n                            hasNonFacetDim_1 = true;\n                        }\n                    }\n                });\n                return !hasDim_1 || hasNonFacetDim_1;\n            }\n            return true;\n        }\n    },\n    {\n        // TODO: we can be smarter and check if bar has occlusion based on profiling statistics\n        name: 'omitBarLineAreaWithOcclusion',\n        description: 'Don\\'t use bar, line or area to visualize raw plot as they often lead to occlusion.',\n        properties: [property_1.Property.MARK, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        requireAllProperties: true,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            if (util_1.contains([mark_1.Mark.BAR, mark_1.Mark.LINE, mark_1.Mark.AREA], specM.getMark())) {\n                return specM.isAggregate();\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitBarTickWithSize',\n        description: 'Do not map field to size channel with bar and tick mark',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK],\n        requireAllProperties: false,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            var mark = specM.getMark();\n            if (util_1.contains([mark_1.Mark.TICK, mark_1.Mark.BAR], mark)) {\n                return !specM.channelUsed(channel_1.Channel.SIZE);\n            }\n            return true; // skip\n        }\n    },\n    {\n        name: 'omitFacetOverPositionalChannels',\n        description: 'Do not use non-positional channels unless all positional channels are used',\n        properties: [property_1.Property.CHANNEL],\n        requireAllProperties: true,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            return specM.channelUsed(channel_1.Channel.ROW) || specM.channelUsed(channel_1.Channel.COLUMN) ?\n                // if non-positional channels are used, then both x and y must be used.\n                specM.channelUsed(channel_1.Channel.X) && specM.channelUsed(channel_1.Channel.Y) :\n                true;\n        }\n    },\n    {\n        name: 'omitBarAreaForLogScale',\n        description: 'Do not use bar and area mark for x and y\\'s log scale',\n        properties: [property_1.Property.MARK, property_1.Property.CHANNEL, property_1.Property.SCALE],\n        requireAllProperties: true,\n        strict: true,\n        satisfy: function (specM, schema, opt) {\n            var mark = specM.getMark();\n            var encodings = specM.getEncodings();\n            if (mark === mark_1.Mark.AREA || mark === mark_1.Mark.BAR) {\n                for (var _i = 0, encodings_1 = encodings; _i < encodings_1.length; _i++) {\n                    var encQ = encodings_1[_i];\n                    if ((encQ.channel === channel_1.Channel.X || encQ.channel === channel_1.Channel.Y) && encQ.scale) {\n                        if (encQ.scale.type === scale_1.ScaleType.LOG) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitMultipleNonPositionalChannels',\n        description: 'Do not use multiple non-positional encoding channel to avoid over-encoding.',\n        properties: [property_1.Property.CHANNEL],\n        requireAllProperties: false,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            var encodings = specM.getEncodings();\n            var nonPositionChannelCount = 0;\n            for (var i = 0; i < encodings.length; i++) {\n                var channel = encodings[i].channel;\n                if (!query_1.isEnumSpec(channel)) {\n                    if (channel === channel_1.Channel.COLOR || channel === channel_1.Channel.SHAPE || channel === channel_1.Channel.SIZE) {\n                        nonPositionChannelCount += 1;\n                        if (nonPositionChannelCount > 1) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitNonPositionalOverPositionalChannels',\n        description: 'Do not use non-positional channels unless all positional channels are used',\n        properties: [property_1.Property.CHANNEL],\n        requireAllProperties: true,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            return util_1.some(channel_1.NONSPATIAL_CHANNELS, function (channel) { return specM.channelUsed(channel); }) ?\n                // if non-positional channels are used, then both x and y must be used.\n                specM.channelUsed(channel_1.Channel.X) && specM.channelUsed(channel_1.Channel.Y) :\n                true;\n        }\n    },\n    {\n        name: 'omitRawContinuousFieldForAggregatePlot',\n        description: 'Aggregate plot should not use raw continuous field as group by values. ' +\n            '(Quantitative should be binned. Temporal should have time unit.)',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.TIMEUNIT, property_1.Property.BIN, property_1.Property.TYPE],\n        requireAllProperties: false,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            if (specM.isAggregate()) {\n                return util_1.every(specM.getEncodings(), function (encQ) {\n                    if (encQ.type === type_1.Type.TEMPORAL) {\n                        // Temporal fields should have timeUnit or is still an enumSpec\n                        return !!encQ.timeUnit;\n                    }\n                    if (encQ.type === type_1.Type.QUANTITATIVE) {\n                        return !!encQ.bin || !!encQ.aggregate || !!encQ.autoCount;\n                    }\n                    return true;\n                });\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitRawDetail',\n        description: 'Do not use detail channel with raw plot.',\n        properties: [property_1.Property.CHANNEL, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        requireAllProperties: true,\n        strict: true,\n        satisfy: function (specM, schema, opt) {\n            if (specM.isAggregate()) {\n                return true;\n            }\n            return util_1.every(specM.getEncodings(), function (encQ) {\n                return encQ.channel !== channel_1.Channel.DETAIL;\n            });\n        }\n    },\n    {\n        name: 'omitRepeatedField',\n        description: 'Each field should be mapped to only one channel',\n        properties: [property_1.Property.FIELD],\n        requireAllProperties: false,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            var usedField = {};\n            // the same field should not be encoded twice\n            return util_1.every(specM.getEncodings(), function (encQ) {\n                if (encQ.field && !query_1.isEnumSpec(encQ.field)) {\n                    // If field is specified, it should not be used already\n                    if (usedField[encQ.field]) {\n                        return false;\n                    }\n                    usedField[encQ.field] = true;\n                    return true;\n                }\n                return true; // unspecified field is valid\n            });\n        }\n    },\n    // TODO: omitShapeWithBin\n    {\n        name: 'omitVerticalDotPlot',\n        description: 'Do not output vertical dot plot.',\n        properties: [property_1.Property.CHANNEL],\n        requireAllProperties: false,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            var encodings = specM.getEncodings();\n            if (encodings.length === 1 && encodings[0].channel === channel_1.Channel.Y) {\n                return false;\n            }\n            return true;\n        }\n    },\n    // EXPENSIVE CONSTRAINTS -- check them later!\n    {\n        name: 'hasAppropriateGraphicTypeForMark',\n        description: 'Has appropriate graphic type for mark',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK, property_1.Property.TYPE, property_1.Property.TIMEUNIT, property_1.Property.BIN, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        requireAllProperties: true,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            var mark = specM.getMark();\n            switch (mark) {\n                case mark_1.Mark.AREA:\n                case mark_1.Mark.LINE:\n                    if (specM.isAggregate()) {\n                        var xEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.X);\n                        var yEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.Y);\n                        var xIsMeasure = xEncQ && query_1.isMeasure(xEncQ);\n                        var yIsMeasure = yEncQ && query_1.isMeasure(yEncQ);\n                        // for aggregate line / area, we need at least one group-by axis and one measure axis.\n                        return xEncQ && yEncQ && (xIsMeasure !== yIsMeasure) &&\n                            // and the dimension axis should not be nominal\n                            // TODO: make this clause optional\n                            !(!xIsMeasure && xEncQ.type === type_1.Type.NOMINAL) &&\n                            !(!yIsMeasure && yEncQ.type === type_1.Type.NOMINAL);\n                    }\n                    return true;\n                case mark_1.Mark.TEXT:\n                    // FIXME correctly when we add text\n                    return true;\n                case mark_1.Mark.BAR:\n                case mark_1.Mark.TICK:\n                    // Bar and tick should not use size.\n                    if (specM.channelUsed(channel_1.Channel.SIZE)) {\n                        return false;\n                    }\n                    // Tick and Bar should have one and only one measure\n                    if (specM.isMeasure(channel_1.Channel.X) !== specM.isMeasure(channel_1.Channel.Y)) {\n                        // TODO: Bar and tick's dimension should not be continuous (quant/time) scale\n                        return true;\n                    }\n                    return false;\n                case mark_1.Mark.CIRCLE:\n                case mark_1.Mark.POINT:\n                case mark_1.Mark.SQUARE:\n                case mark_1.Mark.RULE:\n                    return true;\n            }\n            /* istanbul ignore next */\n            throw new Error('hasAllRequiredChannelsForMark not implemented for mark' + mark);\n        }\n    },\n    {\n        name: 'omitNonSumStack',\n        description: 'Stacked plot should use summative aggregation such as sum, count, or distinct',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        requireAllProperties: true,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            var stack = specM.stack();\n            if (stack) {\n                var measureEncQ = specM.getEncodingQueryByChannel(stack.fieldChannel);\n                return util_1.contains(aggregate_1.SUM_OPS, measureEncQ.aggregate) || !!measureEncQ.autoCount;\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitTableWithOcclusion',\n        description: 'Raw Plots with x and y are both dimensions should be omitted as they often lead to occlusion.',\n        properties: [property_1.Property.CHANNEL, property_1.Property.TYPE, property_1.Property.TIMEUNIT, property_1.Property.BIN, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        requireAllProperties: true,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            if (specM.isDimension(channel_1.Channel.X) &&\n                specM.isDimension(channel_1.Channel.Y) &&\n                !specM.isAggregate() // TODO: refactor based on statistics\n            ) {\n                return false;\n            }\n            return true;\n        }\n    }\n].map(function (sc) { return new SpecConstraintModel(sc); });\n// For testing\nexports.SPEC_CONSTRAINT_INDEX = exports.SPEC_CONSTRAINTS.reduce(function (m, c) {\n    m[c.name()] = c;\n    return m;\n}, {});\n//\nexports.SPEC_CONSTRAINTS_BY_PROPERTY = exports.SPEC_CONSTRAINTS.reduce(function (m, c) {\n    c.properties().forEach(function (prop) {\n        m[prop] = m[prop] || [];\n        m[prop].push(c);\n    });\n    return m;\n}, {});\n/**\n * Check all encoding constraints for a particular property and index tuple\n */\nfunction checkSpec(prop, indexTuple, specM, schema, opt) {\n    // Check encoding constraint\n    var specConstraints = exports.SPEC_CONSTRAINTS_BY_PROPERTY[prop] || [];\n    for (var i = 0; i < specConstraints.length; i++) {\n        var c = specConstraints[i];\n        // Check if the constraint is enabled\n        if (c.strict() || !!opt[c.name()]) {\n            // For strict constraint, or enabled non-strict, check the constraints\n            var satisfy = c.satisfy(specM, schema, opt);\n            if (!satisfy) {\n                var violatedConstraint = '(spec) ' + c.name();\n                /* istanbul ignore if */\n                if (opt.verbose) {\n                    console.log(violatedConstraint + ' failed with ' + specM.toShorthand() + ' for ' + indexTuple.enumSpec.name);\n                }\n                return violatedConstraint;\n            }\n        }\n    }\n    return null;\n}\nexports.checkSpec = checkSpec;\n//# sourceMappingURL=spec.js.map",
    "\"use strict\";\nexports.version = '0.2.1';\nvar util_1 = require('./util');\nexports.constraint = require('./constraint/constraint');\nexports.enumerate = require('./enumerator');\nvar generate_1 = require('./generate');\nexports.generate = generate_1.generate;\nexports.model = require('./model');\nexports.modelgroup = require('./modelgroup');\nexports.nest = require('./nest');\nexports.property = require('./property');\n// Make it so that we can call cql.query() as method, or access other methods inside cql.query\nvar cqlQuery = require('./query');\nvar query_1 = require('./query');\nexports.query = util_1.extend(query_1.query, cqlQuery);\n// TODO(https://github.com/uwdata/compassql/issues/112): properly extract enumSpec from query\nexports.enumSpec = {\n    isEnumSpec: cqlQuery.isEnumSpec\n};\nexports.ranking = require('./ranking/ranking');\nexports.schema = require('./schema');\nexports.util = require('./util');\n//# sourceMappingURL=cql.js.map",
    "\"use strict\";\nvar encoding_1 = require('./constraint/encoding');\nvar spec_1 = require('./constraint/spec');\nvar property_1 = require('./property');\nexports.ENUMERATOR_INDEX = {};\nexports.ENUMERATOR_INDEX[property_1.Property.MARK] = function (enumSpecIndex, schema, opt) {\n    return function (answerSet, specM) {\n        var markEnumSpec = specM.getMark();\n        // enumerate the value\n        markEnumSpec.values.forEach(function (mark) {\n            specM.setMark(mark);\n            // Check spec constraint\n            var violatedSpecConstraint = spec_1.checkSpec(property_1.Property.MARK, enumSpecIndex.mark, specM, schema, opt);\n            if (!violatedSpecConstraint) {\n                // emit\n                answerSet.push(specM.duplicate());\n            }\n        });\n        // Reset to avoid side effect\n        specM.resetMark();\n        return answerSet;\n    };\n};\nproperty_1.ENCODING_PROPERTIES.forEach(function (prop) {\n    exports.ENUMERATOR_INDEX[prop] = EncodingPropertyGeneratorFactory(prop);\n});\nproperty_1.NESTED_ENCODING_PROPERTIES.forEach(function (nestedProp) {\n    exports.ENUMERATOR_INDEX[nestedProp.property] = EncodingPropertyGeneratorFactory(nestedProp.property);\n});\n/**\n * @param prop property type.\n * @return an answer set reducer factory for the given prop.\n */\nfunction EncodingPropertyGeneratorFactory(prop) {\n    /**\n     * @return as reducer that takes a specQueryModel as input and output an answer set array.\n     */\n    return function (enumSpecIndex, schema, opt) {\n        return function (answerSet, specM) {\n            // index of encoding mappings that require enumeration\n            var indexTuples = enumSpecIndex[prop];\n            function enumerate(jobIndex) {\n                if (jobIndex === indexTuples.length) {\n                    // emit and terminate\n                    answerSet.push(specM.duplicate());\n                    return;\n                }\n                var indexTuple = indexTuples[jobIndex];\n                var encQ = specM.getEncodingQueryByIndex(indexTuple.index);\n                var propEnumSpec = specM.getEncodingProperty(indexTuple.index, prop);\n                if (\n                // TODO: encQ.exclude\n                // If this encoding query is an excluded autoCount, there is no point enumerating other properties\n                // for this encoding query because they will be excluded anyway.\n                // Thus, we can just move on to the next encoding to enumerate.\n                encQ.autoCount === false ||\n                    // nested encoding property might have its parent set to false\n                    // therefore, we no longer have to enumerate them\n                    !propEnumSpec) {\n                    enumerate(jobIndex + 1);\n                }\n                else {\n                    propEnumSpec.values.forEach(function (propVal) {\n                        if (propVal === null) {\n                            // our duplicate() method use JSON.stringify, parse and thus can accidentally\n                            // convert undefined in an array into null\n                            propVal = undefined;\n                        }\n                        specM.setEncodingProperty(indexTuple.index, prop, propVal, indexTuple.enumSpec);\n                        // Check encoding constraint\n                        var violatedEncodingConstraint = encoding_1.checkEncoding(prop, indexTuple, specM, schema, opt);\n                        if (violatedEncodingConstraint) {\n                            return; // do not keep searching\n                        }\n                        // Check spec constraint\n                        var violatedSpecConstraint = spec_1.checkSpec(prop, indexTuple, specM, schema, opt);\n                        if (violatedSpecConstraint) {\n                            return; // do not keep searching\n                        }\n                        // If qualify all of the constraints, keep enumerating\n                        enumerate(jobIndex + 1);\n                    });\n                    // Reset to avoid side effect\n                    specM.resetEncodingProperty(indexTuple.index, prop, indexTuple.enumSpec);\n                }\n            }\n            // start enumerating from 0\n            enumerate(0);\n            return answerSet;\n        };\n    };\n}\nexports.EncodingPropertyGeneratorFactory = EncodingPropertyGeneratorFactory;\n//# sourceMappingURL=enumerator.js.map",
    "\"use strict\";\nvar enumerator_1 = require('../src/enumerator');\nvar config_1 = require('./config');\nvar model_1 = require('./model');\nfunction generate(specQ, schema, opt) {\n    if (opt === void 0) { opt = config_1.DEFAULT_QUERY_CONFIG; }\n    // 1. Build a SpecQueryModel, which also contains enumSpecIndex\n    var specM = model_1.SpecQueryModel.build(specQ, schema, opt);\n    var enumSpecIndex = specM.enumSpecIndex;\n    // 2. Enumerate each of the properties based on propPrecedence.\n    var answerSet = [specM]; // Initialize Answer Set with only the input spec query.\n    opt.propertyPrecedence.forEach(function (prop) {\n        // If the original specQuery contains enumSpec for this prop type\n        if (enumSpecIndex[prop]) {\n            // update answerset\n            var reducer = enumerator_1.ENUMERATOR_INDEX[prop](enumSpecIndex, schema, opt);\n            answerSet = answerSet.reduce(reducer, []);\n        }\n    });\n    return answerSet;\n}\nexports.generate = generate;\n//# sourceMappingURL=generate.js.map",
    "\"use strict\";\nvar aggregate_1 = require('vega-lite/src/aggregate');\nvar type_1 = require('vega-lite/src/type');\nvar property_1 = require('./property');\nvar query_1 = require('./query');\nvar query_2 = require('./query');\nvar util_1 = require('./util');\nfunction getDefaultName(prop) {\n    switch (prop) {\n        case property_1.Property.MARK:\n            return 'm';\n        case property_1.Property.CHANNEL:\n            return 'c';\n        case property_1.Property.AGGREGATE:\n            return 'a';\n        case property_1.Property.AUTOCOUNT:\n            return '#';\n        case property_1.Property.BIN:\n            return 'b';\n        case property_1.Property.BIN_MAXBINS:\n            return 'b-mb';\n        case property_1.Property.SCALE:\n            return 's';\n        case property_1.Property.SCALE_TYPE:\n            return 's-t';\n        case property_1.Property.TIMEUNIT:\n            return 'tu';\n        case property_1.Property.FIELD:\n            return 'f';\n        case property_1.Property.TYPE:\n            return 't';\n    }\n    /* istanbul ignore next */\n    throw new Error('Default name undefined');\n}\nfunction getDefaultEnumValues(prop, schema, opt) {\n    switch (prop) {\n        case property_1.Property.FIELD:\n            return schema.fields();\n        case property_1.Property.BIN: // True, False for boolean values\n        case property_1.Property.SCALE:\n        case property_1.Property.AUTOCOUNT:\n            return [false, true];\n        case property_1.Property.BIN_MAXBINS:\n            return opt.maxBinsList;\n        case property_1.Property.SCALE_TYPE:\n            return opt.scaleTypes;\n        case property_1.Property.MARK:\n        case property_1.Property.CHANNEL:\n        case property_1.Property.AGGREGATE:\n        case property_1.Property.TIMEUNIT:\n        case property_1.Property.TYPE:\n            // For other properties, take default enumValues from config.\n            // The config name for each prop is a plural form of the prop.\n            return opt[prop + 's'] || [];\n    }\n    /* istanbul ignore next */\n    throw new Error('No default enumValues for ' + prop);\n}\nexports.getDefaultEnumValues = getDefaultEnumValues;\n/**\n * Internal class for specQuery that provides helper for the enumeration process.\n */\nvar SpecQueryModel = (function () {\n    function SpecQueryModel(spec, enumSpecIndex, schema, opt, enumSpecAssignment) {\n        this._rankingScore = {};\n        this._spec = spec;\n        this._channelCount = spec.encodings.reduce(function (m, encQ) {\n            if (!query_2.isEnumSpec(encQ.channel) && encQ.autoCount !== false) {\n                m[encQ.channel] = 1;\n            }\n            return m;\n        }, {});\n        this._enumSpecIndex = enumSpecIndex;\n        this._enumSpecAssignment = enumSpecAssignment;\n        this._opt = opt;\n        this._schema = schema;\n    }\n    /**\n     * Build an enumSpecIndex by detecting enumeration specifiers\n     * in the input specQuery and replace short enum specs with\n     * full ones that includes both names and enumValues.\n     *\n     * @return a SpecQueryModel that wraps the specQuery and the enumSpecIndex.\n     */\n    SpecQueryModel.build = function (specQ, schema, opt) {\n        var enumSpecIndex = {};\n        // mark\n        if (query_2.isEnumSpec(specQ.mark)) {\n            var name_1 = getDefaultName(property_1.Property.MARK);\n            specQ.mark = query_2.initEnumSpec(specQ.mark, name_1, opt.marks);\n            enumSpecIndex.mark = { enumSpec: specQ.mark };\n        }\n        // TODO: transform\n        // encodings\n        specQ.encodings.forEach(function (encQ, index) {\n            if (encQ.autoCount !== undefined) {\n                // This is only for testing purpose\n                console.warn('A field with autoCount should not be included as autoCount meant to be an internal object.');\n                encQ.type = type_1.Type.QUANTITATIVE; // autoCount is always quantitative\n            }\n            if (encQ.type === undefined) {\n                // type is optional -- we automatically augment enum spec if not specified\n                encQ.type = query_1.SHORT_ENUM_SPEC;\n            }\n            // For each property of the encodingQuery, enumerate\n            property_1.ENCODING_PROPERTIES.forEach(function (prop) {\n                if (query_2.isEnumSpec(encQ[prop])) {\n                    // Assign default enum spec name and enum values.\n                    var defaultEnumSpecName = getDefaultName(prop) + index;\n                    var defaultEnumValues = getDefaultEnumValues(prop, schema, opt);\n                    encQ[prop] = query_2.initEnumSpec(encQ[prop], defaultEnumSpecName, defaultEnumValues);\n                    // Add index of the encoding mapping to the property's enum job.\n                    (enumSpecIndex[prop] = enumSpecIndex[prop] || []).push({\n                        enumSpec: encQ[prop],\n                        index: index\n                    });\n                }\n            });\n            // For each nested property of the encoding query  (e.g., encQ.bin.maxbins)\n            property_1.NESTED_ENCODING_PROPERTIES.forEach(function (nestedProp) {\n                var propObj = encQ[nestedProp.parent]; // the property object e.g., encQ.bin\n                if (propObj) {\n                    var prop = nestedProp.property;\n                    var child = nestedProp.child;\n                    if (query_2.isEnumSpec(propObj[child])) {\n                        // Assign default enum spec name and enum values.\n                        var defaultEnumSpecName = getDefaultName(prop) + index;\n                        var defaultEnumValues = getDefaultEnumValues(prop, schema, opt);\n                        propObj[child] = query_2.initEnumSpec(propObj[child], defaultEnumSpecName, defaultEnumValues);\n                        // Add index of the encoding mapping to the property's enum job.\n                        (enumSpecIndex[prop] = enumSpecIndex[prop] || []).push({\n                            enumSpec: propObj[child],\n                            index: index\n                        });\n                    }\n                }\n            });\n        });\n        // AUTO COUNT\n        // Add Auto Count Field\n        if (opt.autoAddCount) {\n            var countEncQ_1 = {\n                channel: {\n                    name: getDefaultName(property_1.Property.CHANNEL) + specQ.encodings.length,\n                    values: getDefaultEnumValues(property_1.Property.CHANNEL, schema, opt)\n                },\n                autoCount: {\n                    name: getDefaultName(property_1.Property.AUTOCOUNT) + specQ.encodings.length,\n                    values: [false, true]\n                },\n                type: type_1.Type.QUANTITATIVE\n            };\n            specQ.encodings.push(countEncQ_1);\n            var index_1 = specQ.encodings.length - 1;\n            [property_1.Property.CHANNEL, property_1.Property.AUTOCOUNT].forEach(function (prop) {\n                (enumSpecIndex[prop] = enumSpecIndex[prop] || []).push({\n                    enumSpec: countEncQ_1[prop],\n                    index: index_1\n                });\n            });\n        }\n        return new SpecQueryModel(specQ, enumSpecIndex, schema, opt, {});\n    };\n    Object.defineProperty(SpecQueryModel.prototype, \"enumSpecIndex\", {\n        get: function () {\n            return this._enumSpecIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecQueryModel.prototype, \"schema\", {\n        get: function () {\n            return this._schema;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecQueryModel.prototype, \"specQuery\", {\n        get: function () {\n            return this._spec;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SpecQueryModel.prototype.duplicate = function () {\n        return new SpecQueryModel(util_1.duplicate(this._spec), this._enumSpecIndex, this._schema, this._opt, util_1.duplicate(this._enumSpecAssignment));\n    };\n    SpecQueryModel.prototype.setMark = function (mark) {\n        var name = this._spec.mark.name;\n        this._enumSpecAssignment[name] = this._spec.mark = mark;\n    };\n    SpecQueryModel.prototype.resetMark = function () {\n        var enumSpec = this._spec.mark = this._enumSpecIndex.mark.enumSpec;\n        delete this._enumSpecAssignment[enumSpec.name];\n    };\n    SpecQueryModel.prototype.getMark = function () {\n        return this._spec.mark;\n    };\n    SpecQueryModel.prototype.getEncodingProperty = function (index, prop) {\n        var encQ = this._spec.encodings[index];\n        var nestedProp = property_1.getNestedEncodingProperty(prop);\n        if (nestedProp) {\n            return encQ[nestedProp.parent][nestedProp.child];\n        }\n        return encQ[prop]; // encoding property (non-nested)\n    };\n    SpecQueryModel.prototype.setEncodingProperty = function (index, prop, value, enumSpec) {\n        var encQ = this._spec.encodings[index];\n        var nestedProp = property_1.getNestedEncodingProperty(prop);\n        if (prop === property_1.Property.CHANNEL && encQ.channel && !query_2.isEnumSpec(encQ.channel)) {\n            // If there is an old channel\n            this._channelCount[encQ.channel]--;\n        }\n        if (nestedProp) {\n            encQ[nestedProp.parent][nestedProp.child] = value;\n        }\n        else if (property_1.hasNestedProperty(prop) && value === true) {\n            encQ[prop] = util_1.extend({}, encQ[prop], // copy all existing properties\n            { values: undefined, name: undefined } // except name and values to it no longer an enumSpec\n            );\n        }\n        else {\n            encQ[prop] = value;\n        }\n        this._enumSpecAssignment[enumSpec.name] = value;\n        if (prop === property_1.Property.CHANNEL) {\n            // If there is a new channel, make sure it exists and add it to the count.\n            this._channelCount[value] = (this._channelCount[value] || 0) + 1;\n        }\n    };\n    SpecQueryModel.prototype.resetEncodingProperty = function (index, prop, enumSpec) {\n        var encQ = this._spec.encodings[index];\n        var nestedProp = property_1.getNestedEncodingProperty(prop);\n        if (prop === property_1.Property.CHANNEL) {\n            this._channelCount[encQ.channel]--;\n        }\n        // reset it to enumSpec\n        if (nestedProp) {\n            encQ[nestedProp.parent][nestedProp.child] = enumSpec;\n        }\n        else {\n            encQ[prop] = enumSpec;\n        }\n        // add remove value that is reset from the assignment map\n        delete this._enumSpecAssignment[enumSpec.name];\n    };\n    SpecQueryModel.prototype.channelUsed = function (channel) {\n        // do not include encoding that has autoCount = false because it is not a part of the output spec.\n        return this._channelCount[channel] > 0;\n    };\n    SpecQueryModel.prototype.stack = function () {\n        return query_2.stack(this._spec);\n    };\n    SpecQueryModel.prototype.getEncodings = function () {\n        // do not include encoding that has autoCount = false because it is not a part of the output spec.\n        return this._spec.encodings.filter(function (encQ) { return encQ.autoCount !== false; });\n    };\n    SpecQueryModel.prototype.getEncodingQueryByChannel = function (channel) {\n        for (var i = 0; i < this._spec.encodings.length; i++) {\n            if (this._spec.encodings[i].channel === channel) {\n                return this._spec.encodings[i];\n            }\n        }\n        return undefined;\n    };\n    SpecQueryModel.prototype.getEncodingQueryByIndex = function (i) {\n        return this._spec.encodings[i];\n    };\n    SpecQueryModel.prototype.isDimension = function (channel) {\n        var encQ = this.getEncodingQueryByChannel(channel);\n        return encQ && query_2.isDimension(encQ);\n    };\n    SpecQueryModel.prototype.isMeasure = function (channel) {\n        var encQ = this.getEncodingQueryByChannel(channel);\n        return encQ && query_2.isMeasure(encQ);\n    };\n    SpecQueryModel.prototype.isAggregate = function () {\n        return query_2.isAggregate(this._spec);\n    };\n    SpecQueryModel.prototype.toShorthand = function () {\n        return query_2.stringifySpecQuery(this._spec);\n    };\n    SpecQueryModel.prototype._encoding = function () {\n        var encoding = {};\n        for (var i = 0; i < this._spec.encodings.length; i++) {\n            var encQ = this._spec.encodings[i];\n            var fieldDef = {};\n            // For count field that is automatically added, convert to correct vega-lite fieldDef\n            if (encQ.autoCount === true) {\n                fieldDef.aggregate = aggregate_1.AggregateOp.COUNT;\n                fieldDef.field = '*';\n                fieldDef.type = type_1.Type.QUANTITATIVE;\n            }\n            else if (encQ.autoCount === false) {\n                continue; // Do not include this in the output.\n            }\n            // if channel is an enum spec, return null\n            if (query_2.isEnumSpec(encQ.channel))\n                return null;\n            // assemble other property into a field def.\n            var PROPERTIES = [property_1.Property.AGGREGATE, property_1.Property.BIN, property_1.Property.SCALE, property_1.Property.TIMEUNIT, property_1.Property.FIELD, property_1.Property.TYPE];\n            for (var j = 0; j < PROPERTIES.length; j++) {\n                var prop = PROPERTIES[j];\n                // if the property is an enum spec, return null\n                if (query_2.isEnumSpec(encQ[prop]))\n                    return null;\n                // otherwise, assign the proper to the field def\n                if (encQ[prop] !== undefined) {\n                    fieldDef[prop] = encQ[prop];\n                }\n            }\n            encoding[encQ.channel] = fieldDef;\n        }\n        return encoding;\n    };\n    /**\n     * Convert a query to a Vega-Lite spec if it is completed.\n     * @return a Vega-Lite spec if completed, null otherwise.\n     */\n    SpecQueryModel.prototype.toSpec = function (data) {\n        if (query_2.isEnumSpec(this._spec.mark))\n            return null;\n        var spec = {};\n        data = data || this._spec.data;\n        if (data) {\n            spec.data = data;\n        }\n        // TODO: transform\n        spec.mark = this._spec.mark;\n        spec.encoding = this._encoding();\n        if (spec.encoding === null) {\n            return null;\n        }\n        if (this._spec.config || this._opt.defaultSpecConfig)\n            spec.config = util_1.extend({}, this._opt.defaultSpecConfig, this._spec.config);\n        return spec;\n    };\n    SpecQueryModel.prototype.getRankingScore = function (rankingName) {\n        return this._rankingScore[rankingName];\n    };\n    SpecQueryModel.prototype.setRankingScore = function (rankingName, score) {\n        this._rankingScore[rankingName] = score;\n    };\n    return SpecQueryModel;\n}());\nexports.SpecQueryModel = SpecQueryModel;\n//# sourceMappingURL=model.js.map",
    "\"use strict\";\nfunction isSpecQueryModelGroup(item) {\n    return item.hasOwnProperty('items');\n}\nexports.isSpecQueryModelGroup = isSpecQueryModelGroup;\nfunction getTopItem(g) {\n    var topItem = g.items[0];\n    if (isSpecQueryModelGroup(topItem)) {\n        return getTopItem(topItem);\n    }\n    else {\n        return topItem;\n    }\n}\nexports.getTopItem = getTopItem;\n//# sourceMappingURL=modelgroup.js.map",
    "\"use strict\";\nvar channel_1 = require('vega-lite/src/channel');\nvar query_1 = require('./query');\n/**\n * Registry for all possible grouping key functions.\n */\nvar groupRegistry = {};\n/**\n * Add a grouping function to the registry.\n */\nfunction registerKeyFn(name, keyFn) {\n    groupRegistry[name] = keyFn;\n}\nexports.registerKeyFn = registerKeyFn;\nexports.FIELD = 'field';\nexports.FIELD_TRANSFORM = 'fieldTransform';\nexports.ENCODING = 'encoding';\nexports.TRANSPOSE = 'transpose';\nexports.SPEC = 'spec';\n/**\n * Group the input spec query model by a key function registered in the group registry\n * @return\n */\nfunction nest(specModels, query) {\n    var rootGroup = { name: '', path: '', items: [] };\n    var groupIndex = {};\n    if (query.nest) {\n        specModels.forEach(function (specM) {\n            var path = '';\n            var group = rootGroup;\n            for (var l = 0; l < query.nest.length; l++) {\n                group.groupBy = query.nest[l].groupBy;\n                group.orderGroupBy = query.nest[l].orderGroupBy;\n                var keyFn = groupRegistry[query.nest[l].groupBy];\n                var key = keyFn(specM);\n                path += '/' + key;\n                if (!groupIndex[path]) {\n                    groupIndex[path] = {\n                        name: key,\n                        path: path,\n                        items: []\n                    };\n                    group.items.push(groupIndex[path]);\n                }\n                group = groupIndex[path];\n            }\n            group.items.push(specM);\n        });\n    }\n    else {\n        rootGroup.items = specModels;\n    }\n    return rootGroup;\n}\nexports.nest = nest;\nregisterKeyFn(exports.FIELD, function (specM) {\n    return specM.getEncodings().map(function (encQ) { return encQ.field; })\n        .filter(function (field) { return field && field !== '*'; })\n        .sort()\n        .join('|');\n});\nregisterKeyFn(exports.FIELD_TRANSFORM, function (specM) {\n    return specM.getEncodings().map(query_1.stringifyEncodingQueryFieldDef)\n        .sort()\n        .join('|');\n});\nfunction channelType(channel) {\n    if (query_1.isEnumSpec(channel)) {\n        return query_1.SHORT_ENUM_SPEC + '';\n    }\n    var c = channel;\n    switch (c) {\n        case channel_1.Channel.X:\n        case channel_1.Channel.Y:\n            return 'xy';\n        case channel_1.Channel.ROW:\n        case channel_1.Channel.COLUMN:\n            return 'facet';\n        case channel_1.Channel.COLOR:\n        case channel_1.Channel.SIZE:\n        case channel_1.Channel.SHAPE:\n        case channel_1.Channel.OPACITY:\n            return 'non-xy';\n        case channel_1.Channel.TEXT:\n        case channel_1.Channel.DETAIL:\n        case channel_1.Channel.PATH:\n        case channel_1.Channel.ORDER:\n            return c + '';\n        /* istanbul ignore next */\n        default:\n            console.warn('channel type not implemented for ' + c);\n            return c + '';\n    }\n}\nfunction stringifyStack(specM) {\n    var _stack = query_1.stack(specM.specQuery);\n    return (!!_stack ? 'stack=' + _stack.offset + '|' : '');\n}\nregisterKeyFn(exports.ENCODING, function (specM) {\n    // mark does not matter\n    return stringifyStack(specM) +\n        specM.getEncodings().map(function (encQ) {\n            var fieldDef = query_1.stringifyEncodingQueryFieldDef(encQ);\n            return channelType(encQ.channel) + ':' + fieldDef;\n        })\n            .sort()\n            .join('|');\n});\nregisterKeyFn(exports.TRANSPOSE, function (specM) {\n    return specM.getMark() + '|' +\n        stringifyStack(specM) +\n        specM.getEncodings().map(function (encQ) {\n            var fieldDef = query_1.stringifyEncodingQueryFieldDef(encQ);\n            var channel = (encQ.channel === channel_1.Channel.X || encQ.channel === channel_1.Channel.Y) ? 'xy' :\n                (encQ.channel === channel_1.Channel.ROW || encQ.channel === channel_1.Channel.COLUMN) ? 'facet' :\n                    encQ.channel;\n            return channel + ':' + fieldDef;\n        })\n            .sort()\n            .join('|');\n});\nregisterKeyFn(exports.SPEC, function (specM) { return JSON.stringify(specM.specQuery); });\n//# sourceMappingURL=nest.js.map",
    "\"use strict\";\n(function (Property) {\n    // TODO: Filter (Field, Value?)\n    Property[Property[\"MARK\"] = 'mark'] = \"MARK\";\n    // Encoding Properties\n    Property[Property[\"CHANNEL\"] = 'channel'] = \"CHANNEL\";\n    Property[Property[\"AGGREGATE\"] = 'aggregate'] = \"AGGREGATE\";\n    Property[Property[\"AUTOCOUNT\"] = 'autoCount'] = \"AUTOCOUNT\";\n    Property[Property[\"BIN\"] = 'bin'] = \"BIN\";\n    Property[Property[\"BIN_MAXBINS\"] = 'binMaxBins'] = \"BIN_MAXBINS\";\n    Property[Property[\"TIMEUNIT\"] = 'timeUnit'] = \"TIMEUNIT\";\n    Property[Property[\"FIELD\"] = 'field'] = \"FIELD\";\n    Property[Property[\"TYPE\"] = 'type'] = \"TYPE\";\n    // TODO: Sort\n    // - Scale\n    Property[Property[\"SCALE\"] = 'scale'] = \"SCALE\";\n    Property[Property[\"SCALE_TYPE\"] = 'scaleType'] = \"SCALE_TYPE\";\n    // - Axis\n    Property[Property[\"AXIS\"] = 'axis'] = \"AXIS\";\n    // TODO: AXIS_*\n    // - Legend\n    Property[Property[\"LEGEND\"] = 'legend'] = \"LEGEND\";\n})(exports.Property || (exports.Property = {}));\nvar Property = exports.Property;\nfunction hasNestedProperty(prop) {\n    switch (prop) {\n        case Property.BIN:\n        case Property.SCALE:\n            // TODO: AXIS, LEGEND\n            return true;\n        case Property.MARK:\n        case Property.CHANNEL:\n        case Property.AGGREGATE:\n        case Property.AUTOCOUNT:\n        case Property.TIMEUNIT:\n        case Property.FIELD:\n        case Property.TYPE:\n        case Property.BIN_MAXBINS:\n        case Property.SCALE_TYPE:\n            return false;\n    }\n    /* istanbul ignore next */\n    throw new Error('hasNestedProperty undefined for property ' + prop);\n}\nexports.hasNestedProperty = hasNestedProperty;\nexports.ENCODING_PROPERTIES = [\n    Property.CHANNEL,\n    Property.BIN,\n    Property.BIN_MAXBINS,\n    Property.TIMEUNIT,\n    Property.AGGREGATE,\n    Property.AUTOCOUNT,\n    Property.FIELD,\n    Property.TYPE,\n    Property.SCALE,\n    Property.SCALE_TYPE\n];\nexports.DEFAULT_PROPERTY_PRECENCE = [\n    // Projection\n    Property.TYPE,\n    Property.FIELD,\n    // TODO: transform\n    // Field Transform\n    Property.BIN,\n    Property.TIMEUNIT,\n    Property.AGGREGATE,\n    Property.AUTOCOUNT,\n    // Nested Transform Property\n    Property.BIN_MAXBINS,\n    // Encoding\n    Property.CHANNEL,\n    Property.MARK,\n    Property.SCALE,\n    // Nested Encoding Property\n    Property.SCALE_TYPE\n];\nexports.NESTED_ENCODING_PROPERTIES = [\n    {\n        property: Property.BIN_MAXBINS,\n        parent: 'bin',\n        child: 'maxbins'\n    },\n    {\n        property: Property.SCALE_TYPE,\n        parent: 'scale',\n        child: 'type'\n    }\n];\nvar NESTED_ENCODING_INDEX = exports.NESTED_ENCODING_PROPERTIES.reduce(function (m, nestedProp) {\n    m[nestedProp.property] = nestedProp;\n    return m;\n}, {});\nfunction getNestedEncodingProperty(prop) {\n    return NESTED_ENCODING_INDEX[prop];\n}\nexports.getNestedEncodingProperty = getNestedEncodingProperty;\nfunction isNestedEncodingProperty(prop) {\n    return prop in NESTED_ENCODING_INDEX;\n}\nexports.isNestedEncodingProperty = isNestedEncodingProperty;\n//# sourceMappingURL=property.js.map",
    "\"use strict\";\nvar channel_1 = require('vega-lite/src/channel');\nvar mark_1 = require('vega-lite/src/mark');\nvar stack_1 = require('vega-lite/src/stack');\nvar type_1 = require('vega-lite/src/type');\nvar config_1 = require('./config');\nvar generate_1 = require('./generate');\nvar nest_1 = require('./nest');\nvar property_1 = require('./property');\nvar ranking_1 = require('./ranking/ranking');\nvar util_1 = require('./util');\nfunction query(q, schema, config) {\n    // 1. Normalize non-nested `groupBy` to always have `groupBy` inside `nest`\n    //    and merge config with the following precedence\n    //    query.config > config > DEFAULT_QUERY_CONFIG\n    q = util_1.extend({}, normalize(q), {\n        config: util_1.extend({}, config_1.DEFAULT_QUERY_CONFIG, config, q.config)\n    });\n    // 2. Generate\n    var answerSet = generate_1.generate(q.spec, schema, q.config);\n    var nestedAnswerSet = nest_1.nest(answerSet, q);\n    var result = ranking_1.rank(nestedAnswerSet, q, schema, 0);\n    return {\n        query: q,\n        result: result\n    };\n}\nexports.query = query;\n/**\n * Normalize the non-nested version of the query to a standardize nested\n */\nfunction normalize(q) {\n    if (q.groupBy) {\n        var nest_2 = {\n            groupBy: q.groupBy\n        };\n        if (q.orderBy) {\n            nest_2.orderGroupBy = q.orderBy;\n        }\n        var normalizedQ = {\n            spec: util_1.duplicate(q.spec),\n            nest: [nest_2],\n        };\n        if (q.chooseBy) {\n            normalizedQ.chooseBy = q.chooseBy;\n        }\n        if (q.config) {\n            normalizedQ.config = q.config;\n        }\n        return normalizedQ;\n    }\n    return util_1.duplicate(q); // We will cause side effect to q.spec in SpecQueryModel.build\n}\nexports.normalize = normalize;\n/** Enum for a short form of the enumeration spec. */\n(function (ShortEnumSpec) {\n    ShortEnumSpec[ShortEnumSpec[\"ENUMSPEC\"] = '?'] = \"ENUMSPEC\";\n})(exports.ShortEnumSpec || (exports.ShortEnumSpec = {}));\nvar ShortEnumSpec = exports.ShortEnumSpec;\nexports.SHORT_ENUM_SPEC = ShortEnumSpec.ENUMSPEC;\nfunction isEnumSpec(prop) {\n    return prop === exports.SHORT_ENUM_SPEC || (prop !== undefined && !!prop.values);\n}\nexports.isEnumSpec = isEnumSpec;\nfunction initEnumSpec(prop, defaultName, defaultEnumValues) {\n    return util_1.extend({}, {\n        name: defaultName,\n        values: defaultEnumValues\n    }, prop);\n}\nexports.initEnumSpec = initEnumSpec;\nfunction enumSpecShort(value) {\n    return (isEnumSpec(value) ? exports.SHORT_ENUM_SPEC : value) + '';\n}\n/**\n * Convert a Vega-Lite's ExtendedUnitSpec into a CompassQL's SpecQuery\n * @param {ExtendedUnitSpec} spec\n * @returns\n */\nfunction fromSpec(spec) {\n    return util_1.extend(spec.data ? { data: spec.data } : {}, spec.transform ? { transform: spec.transform } : {}, {\n        mark: spec.mark,\n        encodings: util_1.keys(spec.encoding).map(function (channel) {\n            var encQ = { channel: channel };\n            var channelDef = spec.encoding[channel];\n            for (var _i = 0, ENCODING_PROPERTIES_1 = property_1.ENCODING_PROPERTIES; _i < ENCODING_PROPERTIES_1.length; _i++) {\n                var prop = ENCODING_PROPERTIES_1[_i];\n                if (!property_1.isNestedEncodingProperty(prop) && channelDef[prop] !== undefined) {\n                    encQ[prop] = channelDef[prop];\n                }\n                // Currently scale, axis, legend only support boolean, but not null.\n                // Therefore convert null to false.\n                if (util_1.contains([property_1.Property.SCALE, property_1.Property.AXIS, property_1.Property.LEGEND], prop) && encQ[prop] === null) {\n                    encQ[prop] = false;\n                }\n            }\n            return encQ;\n        })\n    }, spec.config ? { config: spec.config } : {});\n}\nexports.fromSpec = fromSpec;\nfunction isAggregate(specQ) {\n    return util_1.some(specQ.encodings, function (encQ) {\n        return (!isEnumSpec(encQ.aggregate) && !!encQ.aggregate) || encQ.autoCount === true;\n    });\n}\nexports.isAggregate = isAggregate;\nfunction stringifySpecQuery(specQ) {\n    var mark = enumSpecShort(specQ.mark);\n    var encodings = specQ.encodings.map(stringifyEncodingQuery)\n        .sort()\n        .join('|'); // sort at the end to ignore order\n    var _stack = stack(specQ);\n    return mark + '|' +\n        // TODO: transform\n        (_stack ? 'stack=' + _stack.offset + '|' : '') +\n        encodings;\n}\nexports.stringifySpecQuery = stringifySpecQuery;\n/**\n * @return the stack offset type for the specQuery\n */\nfunction stack(specQ) {\n    var config = specQ.config;\n    var stacked = (config && config.mark) ? config.mark.stacked : undefined;\n    // Should not have stack explicitly disabled\n    if (util_1.contains([stack_1.StackOffset.NONE, null, false], stacked)) {\n        return null;\n    }\n    // Should have stackable mark\n    if (!util_1.contains([mark_1.BAR, mark_1.AREA], specQ.mark)) {\n        return null;\n    }\n    // Should be aggregate plot\n    if (!isAggregate(specQ)) {\n        return null;\n    }\n    var stackByChannels = specQ.encodings.reduce(function (sc, encQ) {\n        if (util_1.contains(channel_1.STACK_GROUP_CHANNELS, encQ.channel) && !encQ.aggregate) {\n            sc.push(encQ.channel);\n        }\n        return sc;\n    }, []);\n    if (stackByChannels.length === 0) {\n        return null;\n    }\n    // Has only one aggregate axis\n    var xEncQ = specQ.encodings.reduce(function (f, encQ) {\n        return f || (encQ.channel === channel_1.Channel.X ? encQ : null);\n    }, null);\n    var yEncQ = specQ.encodings.reduce(function (f, encQ) {\n        return f || (encQ.channel === channel_1.Channel.Y ? encQ : null);\n    }, null);\n    var xIsAggregate = !!xEncQ && (!!xEncQ.aggregate || !!xEncQ.autoCount);\n    var yIsAggregate = !!yEncQ && (!!yEncQ.aggregate || !!yEncQ.autoCount);\n    if (xIsAggregate !== yIsAggregate) {\n        return {\n            groupbyChannel: xIsAggregate ? (!!yEncQ ? channel_1.Y : null) : (!!xEncQ ? channel_1.X : null),\n            fieldChannel: xIsAggregate ? channel_1.X : channel_1.Y,\n            stackByChannels: stackByChannels,\n            offset: stacked || stack_1.StackOffset.ZERO\n        };\n    }\n    return null;\n}\nexports.stack = stack;\nfunction isDimension(encQ) {\n    return util_1.contains([type_1.Type.NOMINAL, type_1.Type.ORDINAL], encQ.type) ||\n        (!isEnumSpec(encQ.bin) && !!encQ.bin) ||\n        (!isEnumSpec(encQ.timeUnit) && !!encQ.timeUnit); // surely T type\n}\nexports.isDimension = isDimension;\nfunction isMeasure(encQ) {\n    return (encQ.type === type_1.Type.QUANTITATIVE && !encQ.bin) ||\n        (encQ.type === type_1.Type.TEMPORAL && !encQ.timeUnit);\n}\nexports.isMeasure = isMeasure;\nfunction stringifyEncodingQuery(encQ) {\n    return enumSpecShort(encQ.channel) + ':' + stringifyEncodingQueryFieldDef(encQ);\n}\nexports.stringifyEncodingQuery = stringifyEncodingQuery;\nfunction stringifyEncodingQueryFieldDef(encQ) {\n    var fn = null;\n    var params = [];\n    if (encQ.autoCount === false) {\n        return '-';\n    }\n    if (encQ.aggregate && !isEnumSpec(encQ.aggregate)) {\n        fn = encQ.aggregate;\n    }\n    else if (encQ.timeUnit && !isEnumSpec(encQ.timeUnit)) {\n        fn = encQ.timeUnit;\n    }\n    else if (encQ.bin && !isEnumSpec(encQ.bin)) {\n        fn = 'bin';\n        if (encQ.bin['maxbins']) {\n            params.push({ key: 'maxbins', value: encQ.bin['maxbins'] });\n        }\n    }\n    else if (encQ.autoCount && !isEnumSpec(encQ.autoCount)) {\n        fn = 'count';\n    }\n    else if ((encQ.aggregate && isEnumSpec(encQ.aggregate)) ||\n        (encQ.autoCount && isEnumSpec(encQ.autoCount)) ||\n        (encQ.timeUnit && isEnumSpec(encQ.timeUnit)) ||\n        (encQ.bin && isEnumSpec(encQ.bin))) {\n        fn = exports.SHORT_ENUM_SPEC + '';\n    }\n    // Scale\n    // TODO: convert this chunk into a loop of scale, axis, legend\n    if (encQ.scale && !isEnumSpec(encQ.scale)) {\n        if (encQ.scale && !isEnumSpec(encQ.scale)) {\n            var scaleParams = {};\n            if (encQ.scale['type']) {\n                scaleParams = { type: encQ.scale['type'] };\n            }\n            // TODO: push other scale properties to scaleParams.\n            if (util_1.keys(scaleParams).length > 0) {\n                params.push({\n                    key: 'scale',\n                    value: JSON.stringify(scaleParams)\n                });\n            }\n        }\n    }\n    else if (encQ.scale === false || encQ.scale === null) {\n        params.push({\n            key: 'scale',\n            value: false\n        });\n    }\n    var fieldType = enumSpecShort(encQ.field || '*') + ',' +\n        enumSpecShort(encQ.type || type_1.Type.QUANTITATIVE).substr(0, 1) +\n        params.map(function (p) { return ',' + p.key + '=' + p.value; }).join('');\n    return (fn ? fn + '(' + fieldType + ')' : fieldType);\n}\nexports.stringifyEncodingQueryFieldDef = stringifyEncodingQueryFieldDef;\n//# sourceMappingURL=query.js.map",
    "\"use strict\";\nvar channel_1 = require('vega-lite/src/channel');\nvar config_1 = require('../../config');\nvar query_1 = require('../../query');\nvar util_1 = require('../../util');\nvar effectiveness_1 = require('./effectiveness');\nvar type_1 = require('./type');\n/**\n * Field Type (with Bin and TimeUnit) and Channel Score (Cleveland / Mackinlay based)\n */\nvar TypeChannelScore;\n(function (TypeChannelScore) {\n    TypeChannelScore.TYPE_CHANNEL = 'typeChannel';\n    function init() {\n        var SCORE = {};\n        var ORDERED_TYPE_CHANNEL_SCORE = {\n            x: 0,\n            y: 0,\n            size: -0.45,\n            color: -0.6,\n            opacity: -0.75,\n            text: -0.775,\n            row: -0.8,\n            column: -0.8,\n            shape: -2.5,\n            detail: -3\n        };\n        [type_1.Q, type_1.BIN_Q, type_1.T, type_1.TIMEUNIT_T, type_1.O].forEach(function (type) {\n            util_1.keys(ORDERED_TYPE_CHANNEL_SCORE).forEach(function (channel) {\n                SCORE[featurize(type, channel)] = ORDERED_TYPE_CHANNEL_SCORE[channel];\n            });\n        });\n        // Penalize row/column for bin quantitative / timeUnit_temporal\n        [type_1.BIN_Q, type_1.TIMEUNIT_T, type_1.O].forEach(function (type) {\n            [channel_1.Channel.ROW, channel_1.Channel.COLUMN].forEach(function (channel) {\n                SCORE[featurize(type, channel)] += 0.25;\n            });\n        });\n        var NOMINAL_TYPE_CHANNEL_SCORE = {\n            x: 0,\n            y: 0,\n            color: -0.5,\n            shape: -0.6,\n            row: -0.7,\n            column: -0.7,\n            text: -0.8,\n            size: -1.8,\n            detail: -2,\n            opacity: -2.1\n        };\n        util_1.keys(NOMINAL_TYPE_CHANNEL_SCORE).forEach(function (channel) {\n            SCORE[featurize(type_1.N, channel)] = NOMINAL_TYPE_CHANNEL_SCORE[channel];\n        });\n        return SCORE;\n    }\n    TypeChannelScore.init = init;\n    function featurize(type, channel) {\n        return type + '_' + channel;\n    }\n    TypeChannelScore.featurize = featurize;\n    function getScore(specM, schema, opt) {\n        var encodingQueryByField = specM.getEncodings().reduce(function (m, encQ) {\n            var fieldKey = query_1.stringifyEncodingQueryFieldDef(encQ);\n            (m[fieldKey] = m[fieldKey] || []).push(encQ);\n            return m;\n        }, {});\n        var features = [];\n        util_1.forEach(encodingQueryByField, function (encQs) {\n            var bestFieldFeature = encQs.reduce(function (best, encQ) {\n                var type = effectiveness_1.getExtendedType(encQ);\n                var feature = featurize(type, encQ.channel);\n                var featureScore = effectiveness_1.getFeatureScore(TypeChannelScore.TYPE_CHANNEL, feature);\n                if (best === null || featureScore.score > best.score) {\n                    return featureScore;\n                }\n                return best;\n            }, null);\n            features.push(bestFieldFeature);\n            // TODO: add plus for over-encoding of one field\n        });\n        return features;\n    }\n    TypeChannelScore.getScore = getScore;\n})(TypeChannelScore = exports.TypeChannelScore || (exports.TypeChannelScore = {}));\nvar PreferredAxisScore;\n(function (PreferredAxisScore) {\n    PreferredAxisScore.PREFERRED_AXIS = 'preferredAxis';\n    // FIXME support doing this at runtime\n    function init(opt) {\n        if (opt === void 0) { opt = {}; }\n        opt = util_1.extend({}, config_1.DEFAULT_QUERY_CONFIG, opt);\n        var score = {};\n        var preferredAxes = [{\n                feature: 'bin_' + type_1.Q,\n                opt: 'preferredBinAxis'\n            }, {\n                feature: type_1.T,\n                opt: 'preferredTemporalAxis'\n            }, {\n                feature: type_1.O,\n                opt: 'preferredOrdinalAxis'\n            }, {\n                feature: type_1.N,\n                opt: 'preferredNominalAxis'\n            }];\n        preferredAxes.forEach(function (preferredAxis) {\n            if (opt[preferredAxis.opt] === channel_1.Channel.X) {\n                // penalize the other axis\n                score[preferredAxis.feature + '_' + channel_1.Channel.Y] = -0.01;\n            }\n            else if (opt[preferredAxis.opt] === channel_1.Channel.Y) {\n                // penalize the other axis\n                score[preferredAxis.feature + '_' + channel_1.Channel.X] = -0.01;\n            }\n        });\n        return score;\n    }\n    PreferredAxisScore.init = init;\n    function featurize(type, channel) {\n        return type + '_' + channel;\n    }\n    PreferredAxisScore.featurize = featurize;\n    function getScore(specM, schema, opt) {\n        return specM.getEncodings().reduce(function (features, encQ) {\n            var type = effectiveness_1.getExtendedType(encQ);\n            var feature = featurize(type, encQ.channel);\n            var featureScore = effectiveness_1.getFeatureScore(PreferredAxisScore.PREFERRED_AXIS, feature);\n            if (featureScore) {\n                features.push(featureScore);\n            }\n            return features;\n        }, []);\n    }\n    PreferredAxisScore.getScore = getScore;\n})(PreferredAxisScore = exports.PreferredAxisScore || (exports.PreferredAxisScore = {}));\nvar PreferredFacetScore;\n(function (PreferredFacetScore) {\n    PreferredFacetScore.PREFERRED_FACET = 'preferredFacet';\n    // FIXME support doing this at runtime\n    function init(opt) {\n        opt = util_1.extend({}, config_1.DEFAULT_QUERY_CONFIG, opt);\n        var score = {};\n        if (opt.preferredFacet === channel_1.Channel.ROW) {\n            // penalize the other axis\n            score[channel_1.Channel.COLUMN] = -0.01;\n        }\n        else if (opt.preferredFacet === channel_1.Channel.COLUMN) {\n            // penalize the other axis\n            score[channel_1.Channel.ROW] = -0.01;\n        }\n        return score;\n    }\n    PreferredFacetScore.init = init;\n    function getScore(specM, schema, opt) {\n        return specM.getEncodings().reduce(function (features, encQ) {\n            var featureScore = effectiveness_1.getFeatureScore(PreferredFacetScore.PREFERRED_FACET, encQ.channel);\n            if (featureScore) {\n                features.push(featureScore);\n            }\n            return features;\n        }, []);\n    }\n    PreferredFacetScore.getScore = getScore;\n})(PreferredFacetScore = exports.PreferredFacetScore || (exports.PreferredFacetScore = {}));\nvar MarkChannelScore;\n(function (MarkChannelScore) {\n    // Penalty for certain channel for certain mark types\n    MarkChannelScore.MARK_CHANNEL = 'markChannel';\n    function init() {\n        return {\n            bar_size: -2,\n            tick_size: -2\n        };\n    }\n    MarkChannelScore.init = init;\n    function getScore(specM, schema, opt) {\n        var mark = specM.getMark();\n        return specM.getEncodings().reduce(function (featureScores, encQ) {\n            var feature = mark + '_' + encQ.channel;\n            var featureScore = effectiveness_1.getFeatureScore(MarkChannelScore.MARK_CHANNEL, feature);\n            if (featureScore) {\n                featureScores.push(featureScore);\n            }\n            return featureScores;\n        }, []);\n    }\n    MarkChannelScore.getScore = getScore;\n})(MarkChannelScore = exports.MarkChannelScore || (exports.MarkChannelScore = {}));\n/**\n * Penalize if facet channels are the only dimensions\n */\nvar DimensionScore;\n(function (DimensionScore) {\n    DimensionScore.DIMENSION = 'dimension';\n    function init() {\n        return {\n            row: -2,\n            column: -2,\n            color: 0,\n            opacity: 0,\n            size: 0,\n            shape: 0\n        };\n    }\n    DimensionScore.init = init;\n    function getScore(specM, schema, opt) {\n        if (specM.isAggregate()) {\n            specM.getEncodings().reduce(function (maxFScore, encQ) {\n                if (!encQ.aggregate && !encQ.autoCount) {\n                    var featureScore = effectiveness_1.getFeatureScore(DimensionScore.DIMENSION, encQ.channel + '');\n                    if (featureScore.score > maxFScore.score) {\n                        return featureScore;\n                    }\n                }\n                return maxFScore;\n            }, { type: DimensionScore.DIMENSION, feature: 'No Dimension', score: -5 });\n        }\n        return [];\n    }\n    DimensionScore.getScore = getScore;\n})(DimensionScore = exports.DimensionScore || (exports.DimensionScore = {}));\n//# sourceMappingURL=channel.js.map",
    "\"use strict\";\nvar channel_1 = require('./channel');\nvar mark_1 = require('./mark');\nexports.FEATURE_INDEX = {};\nvar FEATURE_FACTORIES = [];\nfunction getFeatureScore(type, feature) {\n    var score = exports.FEATURE_INDEX[type][feature];\n    if (score !== undefined) {\n        return {\n            score: score,\n            type: type,\n            feature: feature\n        };\n    }\n    return null;\n}\nexports.getFeatureScore = getFeatureScore;\nfunction addFeatureFactory(factory) {\n    FEATURE_FACTORIES.push(factory);\n    exports.FEATURE_INDEX[factory.type] = factory.init();\n}\nexports.addFeatureFactory = addFeatureFactory;\naddFeatureFactory({\n    type: channel_1.TypeChannelScore.TYPE_CHANNEL,\n    init: channel_1.TypeChannelScore.init,\n    getScore: channel_1.TypeChannelScore.getScore\n});\naddFeatureFactory({\n    type: channel_1.PreferredAxisScore.PREFERRED_AXIS,\n    init: channel_1.PreferredAxisScore.init,\n    getScore: channel_1.PreferredAxisScore.getScore\n});\naddFeatureFactory({\n    type: channel_1.PreferredFacetScore.PREFERRED_FACET,\n    init: channel_1.PreferredFacetScore.init,\n    getScore: channel_1.PreferredFacetScore.getScore\n});\naddFeatureFactory({\n    type: channel_1.MarkChannelScore.MARK_CHANNEL,\n    init: channel_1.MarkChannelScore.init,\n    getScore: channel_1.MarkChannelScore.getScore\n});\naddFeatureFactory({\n    type: mark_1.MarkScore.MARK_SCORE,\n    init: mark_1.MarkScore.init,\n    getScore: mark_1.MarkScore.getScore\n});\n// TODO: x/y, row/column preference\n// TODO: stacking\n// TODO: Channel, Cardinality\n// TODO: Penalize over encoding\nfunction getExtendedType(encQ) {\n    return (encQ.bin ? 'bin_' : encQ.timeUnit ? 'timeUnit_' : '') + encQ.type;\n}\nexports.getExtendedType = getExtendedType;\nfunction default_1(specM, schema, opt) {\n    var features = FEATURE_FACTORIES.reduce(function (f, factory) {\n        var scores = factory.getScore(specM, schema, opt);\n        return f.concat(scores);\n    }, []);\n    return {\n        score: features.reduce(function (s, f) {\n            return s + f.score;\n        }, 0),\n        features: features\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = default_1;\n//# sourceMappingURL=effectiveness.js.map",
    "\"use strict\";\nvar channel_1 = require('vega-lite/src/channel');\nvar mark_1 = require('vega-lite/src/mark');\nvar util_1 = require('../../util');\nvar effectiveness_1 = require('./effectiveness');\nvar type_1 = require('./type');\nvar MarkScore;\n(function (MarkScore) {\n    MarkScore.MARK_SCORE = 'markScore';\n    function featurize(xType, yType, hasOcclusion, mark) {\n        return xType + '_' + yType + '_' + hasOcclusion + '_' + mark;\n    }\n    MarkScore.featurize = featurize;\n    function init() {\n        var MEASURES = [type_1.Q, type_1.T];\n        var DIMENSIONS = [type_1.BIN_Q, type_1.TIMEUNIT_T, type_1.O, type_1.N];\n        var DIMENSIONS_OR_NONE = DIMENSIONS.concat([type_1.NONE]);\n        var SCORE = {};\n        // QxQ\n        MEASURES.forEach(function (xType) {\n            MEASURES.forEach(function (yType) {\n                // has occlusion\n                var occludedQQMark = {\n                    point: 0,\n                    text: -0.2,\n                    tick: -0.5,\n                    bar: -2,\n                    line: -2,\n                    area: -2,\n                    rule: -2.5\n                };\n                util_1.forEach(occludedQQMark, function (score, mark) {\n                    var feature = featurize(xType, yType, true, mark);\n                    SCORE[feature] = score;\n                });\n                // no occlusion\n                // TODO: possible to use connected scatter plot\n                var noOccludedQQMark = {\n                    point: 0,\n                    text: -0.2,\n                    tick: -0.5,\n                    bar: -2,\n                    line: -2,\n                    area: -2,\n                    rule: -2.5\n                };\n                util_1.forEach(noOccludedQQMark, function (score, mark) {\n                    var feature = featurize(xType, yType, false, mark);\n                    SCORE[feature] = score;\n                });\n            });\n        });\n        // DxQ, QxD\n        MEASURES.forEach(function (xType) {\n            // has occlusion\n            DIMENSIONS_OR_NONE.forEach(function (yType) {\n                var occludedDimensionMeasureMark = {\n                    tick: 0,\n                    point: -0.2,\n                    text: -0.5,\n                    bar: -2,\n                    line: -2,\n                    area: -2,\n                    rule: -2.5\n                };\n                util_1.forEach(occludedDimensionMeasureMark, function (score, mark) {\n                    var feature = featurize(xType, yType, true, mark);\n                    SCORE[feature] = score;\n                    // also do the inverse\n                    var feature2 = featurize(yType, xType, true, mark);\n                    SCORE[feature2] = score;\n                });\n            });\n            // no occlusion\n            [type_1.NONE, type_1.N].forEach(function (yType) {\n                var noOccludedQxN = {\n                    bar: 0,\n                    point: -0.2,\n                    tick: -0.25,\n                    text: -0.3,\n                    // Line / Area can mislead trend for N\n                    line: -2,\n                    area: -2,\n                    // Non-sense to use rule here\n                    rule: -2.5\n                };\n                util_1.forEach(noOccludedQxN, function (score, mark) {\n                    var feature = featurize(xType, yType, false, mark);\n                    SCORE[feature] = score;\n                    // also do the inverse\n                    var feature2 = featurize(yType, xType, false, mark);\n                    SCORE[feature2] = score;\n                });\n            });\n            [type_1.BIN_Q].forEach(function (yType) {\n                var noOccludedQxBinQ = {\n                    bar: 0,\n                    point: -0.2,\n                    tick: -0.25,\n                    text: -0.3,\n                    // Line / Area isn't the best fit for bin\n                    line: -0.5,\n                    area: -0.5,\n                    // Non-sense to use rule here\n                    rule: -2.5\n                };\n                util_1.forEach(noOccludedQxBinQ, function (score, mark) {\n                    var feature = featurize(xType, yType, false, mark);\n                    SCORE[feature] = score;\n                    // also do the inverse\n                    var feature2 = featurize(yType, xType, false, mark);\n                    SCORE[feature2] = score;\n                });\n            });\n            [type_1.TIMEUNIT_T, type_1.O].forEach(function (yType) {\n                var noOccludedQxBinQ = {\n                    line: 0,\n                    area: -0.1,\n                    bar: -0.2,\n                    point: -0.3,\n                    tick: -0.35,\n                    text: -0.4,\n                    // Non-sense to use rule here\n                    rule: -2.5\n                };\n                util_1.forEach(noOccludedQxBinQ, function (score, mark) {\n                    var feature = featurize(xType, yType, false, mark);\n                    SCORE[feature] = score;\n                    // also do the inverse\n                    var feature2 = featurize(yType, xType, false, mark);\n                    SCORE[feature2] = score;\n                });\n            });\n        });\n        // DxD\n        DIMENSIONS_OR_NONE.forEach(function (xType) {\n            DIMENSIONS_OR_NONE.forEach(function (yType) {\n                // has occlusion\n                var ddMark = {\n                    point: 0,\n                    rect: 0,\n                    text: -0.1,\n                    tick: -1,\n                    bar: -2,\n                    line: -2,\n                    area: -2,\n                    rule: -2.5\n                };\n                // No difference between has occlusion and no occlusion\n                util_1.forEach(ddMark, function (score, mark) {\n                    var feature = featurize(xType, yType, true, mark);\n                    SCORE[feature] = score;\n                });\n                util_1.forEach(ddMark, function (score, mark) {\n                    var feature = featurize(xType, yType, false, mark);\n                    SCORE[feature] = score;\n                });\n            });\n        });\n        return SCORE;\n    }\n    MarkScore.init = init;\n    function getScore(specM, schema, opt) {\n        var mark = specM.getMark();\n        if (mark === mark_1.Mark.CIRCLE || mark === mark_1.Mark.SQUARE) {\n            mark = mark_1.Mark.POINT;\n        }\n        var xEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.X);\n        var xType = xEncQ ? effectiveness_1.getExtendedType(xEncQ) : '-';\n        var yEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.Y);\n        var yType = yEncQ ? effectiveness_1.getExtendedType(yEncQ) : '-';\n        var isOccluded = !specM.isAggregate(); // FIXME\n        var feature = xType + '_' + yType + '_' + isOccluded + '_' + mark;\n        var featureScore = effectiveness_1.getFeatureScore(MarkScore.MARK_SCORE, feature);\n        return [featureScore];\n    }\n    MarkScore.getScore = getScore;\n})(MarkScore = exports.MarkScore || (exports.MarkScore = {}));\n//# sourceMappingURL=mark.js.map",
    "\"use strict\";\nvar type_1 = require('vega-lite/src/type');\n/**\n * Finer grained data types that takes binning and timeUnit into account.\n */\n(function (ExtendedType) {\n    ExtendedType[ExtendedType[\"Q\"] = type_1.Type.QUANTITATIVE] = \"Q\";\n    ExtendedType[ExtendedType[\"BIN_Q\"] = 'bin_' + type_1.Type.QUANTITATIVE] = \"BIN_Q\";\n    ExtendedType[ExtendedType[\"T\"] = type_1.Type.TEMPORAL] = \"T\";\n    ExtendedType[ExtendedType[\"TIMEUNIT_T\"] = 'timeUnit_' + type_1.Type.TEMPORAL] = \"TIMEUNIT_T\";\n    ExtendedType[ExtendedType[\"O\"] = type_1.Type.ORDINAL] = \"O\";\n    ExtendedType[ExtendedType[\"N\"] = type_1.Type.NOMINAL] = \"N\";\n    ExtendedType[ExtendedType[\"NONE\"] = '-'] = \"NONE\";\n})(exports.ExtendedType || (exports.ExtendedType = {}));\nvar ExtendedType = exports.ExtendedType;\nexports.Q = ExtendedType.Q;\nexports.BIN_Q = ExtendedType.BIN_Q;\nexports.T = ExtendedType.T;\nexports.TIMEUNIT_T = ExtendedType.TIMEUNIT_T;\nexports.O = ExtendedType.O;\nexports.N = ExtendedType.N;\nexports.NONE = ExtendedType.NONE;\n//# sourceMappingURL=type.js.map",
    "\"use strict\";\nvar modelgroup_1 = require('../modelgroup');\nexports.effectiveness = require('./effectiveness/effectiveness');\n/**\n * Registry for all encoding ranking functions\n */\nvar rankingRegistry = {};\n/**\n * Add an ordering function to the registry.\n */\nfunction register(name, keyFn) {\n    rankingRegistry[name] = keyFn;\n}\nexports.register = register;\nfunction get(name) {\n    return rankingRegistry[name];\n}\nexports.get = get;\nfunction rank(group, query, schema, level) {\n    if (!query.nest || level === query.nest.length) {\n        if (query.orderBy || query.chooseBy) {\n            group.items.sort(comparator(query.orderBy || query.chooseBy, schema, query.config));\n            if (query.chooseBy) {\n                // for chooseBy -- only keep the top-item\n                group.items = [group.items[0]];\n            }\n        }\n    }\n    else {\n        // sort lower-level nodes first because our ranking takes top-item in the subgroup\n        group.items.forEach(function (subgroup) {\n            rank(subgroup, query, schema, level + 1);\n        });\n        if (query.nest[level].orderGroupBy) {\n            group.items.sort(groupComparator(query.nest[level].orderGroupBy, schema, query.config));\n        }\n    }\n    return group;\n}\nexports.rank = rank;\nfunction getScore(model, rankingName, schema, opt) {\n    if (model.getRankingScore(rankingName) !== undefined) {\n        return model.getRankingScore(rankingName);\n    }\n    var fn = get(rankingName);\n    var score = fn(model, schema, opt);\n    model.setRankingScore(rankingName, score);\n    return score;\n}\nfunction comparator(name, schema, opt) {\n    return function (m1, m2) {\n        return getScore(m2, name, schema, opt).score - getScore(m1, name, schema, opt).score;\n    };\n}\nexports.comparator = comparator;\nfunction groupComparator(name, schema, opt) {\n    return function (g1, g2) {\n        var m1 = modelgroup_1.getTopItem(g1);\n        var m2 = modelgroup_1.getTopItem(g2);\n        return getScore(m2, name, schema, opt).score - getScore(m1, name, schema, opt).score;\n    };\n}\nexports.groupComparator = groupComparator;\nexports.EFFECTIVENESS = 'effectiveness';\nregister(exports.EFFECTIVENESS, exports.effectiveness.default);\n//# sourceMappingURL=ranking.js.map",
    "\"use strict\";\nvar type_1 = require('vega-lite/src/type');\nvar stats_1 = require('datalib/src/stats');\nvar type_2 = require('datalib/src/import/type');\nvar config_1 = require('./config');\nvar util_1 = require('./util');\nvar Schema = (function () {\n    function Schema(fieldSchemas) {\n        this.fieldSchemas = fieldSchemas;\n        this.fieldSchemaIndex = fieldSchemas.reduce(function (m, fieldSchema) {\n            m[fieldSchema.field] = fieldSchema;\n            return m;\n        }, {});\n    }\n    /**\n     * Build a Schema object.\n     *\n     * @param data - a set of raw data\n     * @return a Schema object\n     */\n    Schema.build = function (data, opt) {\n        if (opt === void 0) { opt = {}; }\n        opt = util_1.extend({}, config_1.DEFAULT_QUERY_CONFIG, opt);\n        // create profiles for each variable\n        var summaries = stats_1.summary(data);\n        var types = type_2.inferAll(data); // inferAll does stronger type inference than summary\n        var fieldSchemas = summaries.map(function (summary) {\n            var field = summary.field;\n            var primitiveType = types[field];\n            var distinct = summary.distinct;\n            var type;\n            if (primitiveType === PrimitiveType.NUMBER) {\n                type = type_1.Type.QUANTITATIVE;\n            }\n            else if (primitiveType === PrimitiveType.INTEGER) {\n                // use ordinal or nominal when cardinality of integer type is relatively low\n                if (distinct / summary.count < opt.numberOrdinalProportion) {\n                    // use nominal if the integers are 1,2,3,...,N or 0,1,2,3,...,N-1 where N = cardinality\n                    type = (summary.max - summary.min === distinct - 1 && util_1.contains([0, 1], summary.min)) ? type_1.Type.NOMINAL : type_1.Type.ORDINAL;\n                }\n                else {\n                    type = type_1.Type.QUANTITATIVE;\n                }\n            }\n            else if (primitiveType === PrimitiveType.DATE) {\n                type = type_1.Type.TEMPORAL;\n            }\n            else {\n                type = type_1.Type.NOMINAL;\n            }\n            return {\n                field: field,\n                type: type,\n                primitiveType: primitiveType,\n                stats: summary\n            };\n        });\n        return new Schema(fieldSchemas);\n    };\n    Schema.prototype.fields = function () {\n        return this.fieldSchemas.map(function (fieldSchema) { return fieldSchema.field; });\n    };\n    /**\n     * @return primitive type of the field if exist, otherwise return null\n     */\n    Schema.prototype.primitiveType = function (field) {\n        return this.fieldSchemaIndex[field] ? this.fieldSchemaIndex[field].primitiveType : null;\n    };\n    /**\n     * @return type of measturement of the field if exist, otherwise return null\n     */\n    Schema.prototype.type = function (field) {\n        return this.fieldSchemaIndex[field] ? this.fieldSchemaIndex[field].type : null;\n    };\n    Schema.prototype.cardinality = function (encQ) {\n        if (encQ.aggregate || encQ.autoCount) {\n            return 1;\n        }\n        else if (encQ.bin) {\n            return 1; // FIXME\n        }\n        else if (encQ.timeUnit) {\n            return 1; // FIXME\n        }\n        var fieldSchema = this.fieldSchemaIndex[encQ.field];\n        return fieldSchema ? fieldSchema.stats.distinct : null;\n    };\n    /**\n     * @return a Summary corresponding to the field of the given EncodingQuery\n     */\n    Schema.prototype.stats = function (encQ) {\n        // TODO: differentiate for field with bin / timeUnit vs without\n        var fieldSchema = this.fieldSchemaIndex[encQ.field];\n        return fieldSchema ? fieldSchema.stats : null;\n    };\n    return Schema;\n}());\nexports.Schema = Schema;\n(function (PrimitiveType) {\n    PrimitiveType[PrimitiveType[\"STRING\"] = 'string'] = \"STRING\";\n    PrimitiveType[PrimitiveType[\"NUMBER\"] = 'number'] = \"NUMBER\";\n    PrimitiveType[PrimitiveType[\"INTEGER\"] = 'integer'] = \"INTEGER\";\n    PrimitiveType[PrimitiveType[\"BOOLEAN\"] = 'boolean'] = \"BOOLEAN\";\n    PrimitiveType[PrimitiveType[\"DATE\"] = 'date'] = \"DATE\";\n})(exports.PrimitiveType || (exports.PrimitiveType = {}));\nvar PrimitiveType = exports.PrimitiveType;\n//# sourceMappingURL=schema.js.map",
    "\"use strict\";\nvar util_1 = require('datalib/src/util');\nvar util_2 = require('datalib/src/util');\nexports.keys = util_2.keys;\nexports.duplicate = util_2.duplicate;\nexports.extend = util_2.extend;\nfunction contains(array, item) {\n    return array.indexOf(item) !== -1;\n}\nexports.contains = contains;\n;\nfunction every(arr, f) {\n    var i = 0, k;\n    for (k in arr) {\n        if (!f(arr[k], k, i++)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.every = every;\n;\nfunction forEach(obj, f, thisArg) {\n    if (obj.forEach) {\n        obj.forEach.call(thisArg, f);\n    }\n    else {\n        for (var k in obj) {\n            f.call(thisArg, obj[k], k, obj);\n        }\n    }\n}\nexports.forEach = forEach;\n;\nfunction some(arr, f) {\n    var i = 0, k;\n    for (k in arr) {\n        if (f(arr[k], k, i++)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.some = some;\n;\nfunction nestedMap(array, f) {\n    return array.map(function (a) {\n        if (util_1.isArray(a)) {\n            return nestedMap(a, f);\n        }\n        return f(a);\n    });\n}\nexports.nestedMap = nestedMap;\n/** Returns the array without the elements in item */\nfunction without(array, excludedItems) {\n    return array.filter(function (item) {\n        return !contains(excludedItems, item);\n    });\n}\nexports.without = without;\n//# sourceMappingURL=util.js.map",
    "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define('d3-time', ['exports'], factory) :\n  factory((global.d3_time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t0 = new Date;\n  var t1 = new Date;\n  function newInterval(floori, offseti, count, field) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) {\n      interval.count = function(start, end) {\n        t0.setTime(+start), t1.setTime(+end);\n        floori(t0), floori(t1);\n        return Math.floor(count(t0, t1));\n      };\n\n      interval.every = function(step) {\n        step = Math.floor(step);\n        return !isFinite(step) || !(step > 0) ? null\n            : !(step > 1) ? interval\n            : interval.filter(field\n                ? function(d) { return field(d) % step === 0; }\n                : function(d) { return interval.count(0, d) % step === 0; });\n      };\n    }\n\n    return interval;\n  };\n\n  var millisecond = newInterval(function() {\n    // noop\n  }, function(date, step) {\n    date.setTime(+date + step);\n  }, function(start, end) {\n    return end - start;\n  });\n\n  // An optimized implementation for this simple case.\n  millisecond.every = function(k) {\n    k = Math.floor(k);\n    if (!isFinite(k) || !(k > 0)) return null;\n    if (!(k > 1)) return millisecond;\n    return newInterval(function(date) {\n      date.setTime(Math.floor(date / k) * k);\n    }, function(date, step) {\n      date.setTime(+date + step * k);\n    }, function(start, end) {\n      return (end - start) / k;\n    });\n  };\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getSeconds();\n  });\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getMinutes();\n  });\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getHours();\n  });\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  }, function(date) {\n    return date.getDate() - 1;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n  var tuesday = weekday(2);\n  var wednesday = weekday(3);\n  var thursday = weekday(4);\n  var friday = weekday(5);\n  var saturday = weekday(6);\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  }, function(date) {\n    return date.getMonth();\n  });\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  }, function(date) {\n    return date.getFullYear();\n  });\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getUTCSeconds();\n  });\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getUTCMinutes();\n  });\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getUTCHours();\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  }, function(date) {\n    return date.getUTCDate() - 1;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n  var utcTuesday = utcWeekday(2);\n  var utcWednesday = utcWeekday(3);\n  var utcThursday = utcWeekday(4);\n  var utcFriday = utcWeekday(5);\n  var utcSaturday = utcWeekday(6);\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  }, function(date) {\n    return date.getUTCMonth();\n  });\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  }, function(date) {\n    return date.getUTCFullYear();\n  });\n\n  var milliseconds = millisecond.range;\n  var seconds = second.range;\n  var minutes = minute.range;\n  var hours = hour.range;\n  var days = day.range;\n  var sundays = sunday.range;\n  var mondays = monday.range;\n  var tuesdays = tuesday.range;\n  var wednesdays = wednesday.range;\n  var thursdays = thursday.range;\n  var fridays = friday.range;\n  var saturdays = saturday.range;\n  var weeks = sunday.range;\n  var months = month.range;\n  var years = year.range;\n\n  var utcMillisecond = millisecond;\n  var utcMilliseconds = milliseconds;\n  var utcSeconds = utcSecond.range;\n  var utcMinutes = utcMinute.range;\n  var utcHours = utcHour.range;\n  var utcDays = utcDay.range;\n  var utcSundays = utcSunday.range;\n  var utcMondays = utcMonday.range;\n  var utcTuesdays = utcTuesday.range;\n  var utcWednesdays = utcWednesday.range;\n  var utcThursdays = utcThursday.range;\n  var utcFridays = utcFriday.range;\n  var utcSaturdays = utcSaturday.range;\n  var utcWeeks = utcSunday.range;\n  var utcMonths = utcMonth.range;\n  var utcYears = utcYear.range;\n\n  var version = \"0.1.1\";\n\n  exports.version = version;\n  exports.milliseconds = milliseconds;\n  exports.seconds = seconds;\n  exports.minutes = minutes;\n  exports.hours = hours;\n  exports.days = days;\n  exports.sundays = sundays;\n  exports.mondays = mondays;\n  exports.tuesdays = tuesdays;\n  exports.wednesdays = wednesdays;\n  exports.thursdays = thursdays;\n  exports.fridays = fridays;\n  exports.saturdays = saturdays;\n  exports.weeks = weeks;\n  exports.months = months;\n  exports.years = years;\n  exports.utcMillisecond = utcMillisecond;\n  exports.utcMilliseconds = utcMilliseconds;\n  exports.utcSeconds = utcSeconds;\n  exports.utcMinutes = utcMinutes;\n  exports.utcHours = utcHours;\n  exports.utcDays = utcDays;\n  exports.utcSundays = utcSundays;\n  exports.utcMondays = utcMondays;\n  exports.utcTuesdays = utcTuesdays;\n  exports.utcWednesdays = utcWednesdays;\n  exports.utcThursdays = utcThursdays;\n  exports.utcFridays = utcFridays;\n  exports.utcSaturdays = utcSaturdays;\n  exports.utcWeeks = utcWeeks;\n  exports.utcMonths = utcMonths;\n  exports.utcYears = utcYears;\n  exports.millisecond = millisecond;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.sunday = sunday;\n  exports.monday = monday;\n  exports.tuesday = tuesday;\n  exports.wednesday = wednesday;\n  exports.thursday = thursday;\n  exports.friday = friday;\n  exports.saturday = saturday;\n  exports.week = sunday;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcSunday = utcSunday;\n  exports.utcMonday = utcMonday;\n  exports.utcTuesday = utcTuesday;\n  exports.utcWednesday = utcWednesday;\n  exports.utcThursday = utcThursday;\n  exports.utcFriday = utcFriday;\n  exports.utcSaturday = utcSaturday;\n  exports.utcWeek = utcSunday;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n  exports.interval = newInterval;\n\n}));",
    "var util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],\n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n\n    // increase step size if too many bins\n    while (Math.ceil(span/step) > maxb) { step *= base; }\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n",
    "var d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);",
    "var u = module.exports;\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (typeof Buffer === 'function' && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\n// parse a date with optional d3.time-format format\nu.date = function(s, format) {\n  var d = format ? format : Date;\n  return s == null || s === '' ? null : d.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) || u.isString(x) ?\n      // Output valid JSON and JS source strings.\n      // See http://timelessrepo.com/json-isnt-a-javascript-subset\n      JSON.stringify(x).replace('\\u2028','\\\\u2028').replace('\\u2029', '\\\\u2029')\n    : x;\n};\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  /* jshint evil: true */\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, Function('x', 'return x[' + u.field(f).map(u.str).join('][') + '];'));\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a, b) {\n    var i, n, f, c;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i];\n      c = u.cmp(f(a), f(b));\n      if (c) return c * sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  return (a < b || a == null) && b != null ? -1 :\n    (a > b || b == null) && a != null ? 1 :\n    ((b = b instanceof Date ? +b : b),\n     (a = a instanceof Date ? +a : a)) !== a && b === b ? -1 :\n    b !== b && a === a ? 1 : 0;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n// permutes an array using a Knuth shuffle\nu.permute = function(a) {\n  var m = a.length,\n      swap,\n      i;\n\n  while (m) {\n    i = Math.floor(Math.random() * m--);\n    swap = a[m];\n    a[m] = a[i];\n    a[i] = swap;\n  }\n};\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n",
    "var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');\n\nmodule.exports = function (obj, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var space = opts.space || '';\n    if (typeof space === 'number') space = Array(space+1).join(' ');\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n    var replacer = opts.replacer || function(key, value) { return value; };\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (parent, key, node, level) {\n        var indent = space ? ('\\n' + new Array(level + 1).join(space)) : '';\n        var colonSeparator = space ? ': ' : ':';\n\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        node = replacer.call(parent, key, node);\n\n        if (node === undefined) {\n            return;\n        }\n        if (typeof node !== 'object' || node === null) {\n            return json.stringify(node);\n        }\n        if (isArray(node)) {\n            var out = [];\n            for (var i = 0; i < node.length; i++) {\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\n                out.push(indent + space + item);\n            }\n            return '[' + out.join(',') + indent + ']';\n        }\n        else {\n            if (seen.indexOf(node) !== -1) {\n                if (cycles) return json.stringify('__cycle__');\n                throw new TypeError('Converting circular structure to JSON');\n            }\n            else seen.push(node);\n\n            var keys = objectKeys(node).sort(cmp && cmp(node));\n            var out = [];\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var value = stringify(node, key, node[key], level+1);\n\n                if(!value) continue;\n\n                var keyValue = json.stringify(key)\n                    + colonSeparator\n                    + value;\n                ;\n                out.push(indent + space + keyValue);\n            }\n            seen.splice(seen.indexOf(node), 1);\n            return '{' + out.join(',') + indent + '}';\n        }\n    })({ '': obj }, '', obj, 0);\n};\n\nvar isArray = Array.isArray || function (x) {\n    return {}.toString.call(x) === '[object Array]';\n};\n\nvar objectKeys = Object.keys || function (obj) {\n    var has = Object.prototype.hasOwnProperty || function () { return true };\n    var keys = [];\n    for (var key in obj) {\n        if (has.call(obj, key)) keys.push(key);\n    }\n    return keys;\n};\n",
    "exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n",
    "var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n",
    "var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n",
    "\"use strict\";\n(function (AggregateOp) {\n    AggregateOp[AggregateOp[\"VALUES\"] = 'values'] = \"VALUES\";\n    AggregateOp[AggregateOp[\"COUNT\"] = 'count'] = \"COUNT\";\n    AggregateOp[AggregateOp[\"VALID\"] = 'valid'] = \"VALID\";\n    AggregateOp[AggregateOp[\"MISSING\"] = 'missing'] = \"MISSING\";\n    AggregateOp[AggregateOp[\"DISTINCT\"] = 'distinct'] = \"DISTINCT\";\n    AggregateOp[AggregateOp[\"SUM\"] = 'sum'] = \"SUM\";\n    AggregateOp[AggregateOp[\"MEAN\"] = 'mean'] = \"MEAN\";\n    AggregateOp[AggregateOp[\"AVERAGE\"] = 'average'] = \"AVERAGE\";\n    AggregateOp[AggregateOp[\"VARIANCE\"] = 'variance'] = \"VARIANCE\";\n    AggregateOp[AggregateOp[\"VARIANCEP\"] = 'variancep'] = \"VARIANCEP\";\n    AggregateOp[AggregateOp[\"STDEV\"] = 'stdev'] = \"STDEV\";\n    AggregateOp[AggregateOp[\"STDEVP\"] = 'stdevp'] = \"STDEVP\";\n    AggregateOp[AggregateOp[\"MEDIAN\"] = 'median'] = \"MEDIAN\";\n    AggregateOp[AggregateOp[\"Q1\"] = 'q1'] = \"Q1\";\n    AggregateOp[AggregateOp[\"Q3\"] = 'q3'] = \"Q3\";\n    AggregateOp[AggregateOp[\"MODESKEW\"] = 'modeskew'] = \"MODESKEW\";\n    AggregateOp[AggregateOp[\"MIN\"] = 'min'] = \"MIN\";\n    AggregateOp[AggregateOp[\"MAX\"] = 'max'] = \"MAX\";\n    AggregateOp[AggregateOp[\"ARGMIN\"] = 'argmin'] = \"ARGMIN\";\n    AggregateOp[AggregateOp[\"ARGMAX\"] = 'argmax'] = \"ARGMAX\";\n})(exports.AggregateOp || (exports.AggregateOp = {}));\nvar AggregateOp = exports.AggregateOp;\nexports.AGGREGATE_OPS = [\n    AggregateOp.VALUES,\n    AggregateOp.COUNT,\n    AggregateOp.VALID,\n    AggregateOp.MISSING,\n    AggregateOp.DISTINCT,\n    AggregateOp.SUM,\n    AggregateOp.MEAN,\n    AggregateOp.AVERAGE,\n    AggregateOp.VARIANCE,\n    AggregateOp.VARIANCEP,\n    AggregateOp.STDEV,\n    AggregateOp.STDEVP,\n    AggregateOp.MEDIAN,\n    AggregateOp.Q1,\n    AggregateOp.Q3,\n    AggregateOp.MODESKEW,\n    AggregateOp.MIN,\n    AggregateOp.MAX,\n    AggregateOp.ARGMIN,\n    AggregateOp.ARGMAX,\n];\n/** Additive-based aggregation operations.  These can be applied to stack. */\nexports.SUM_OPS = [\n    AggregateOp.COUNT,\n    AggregateOp.SUM,\n    AggregateOp.DISTINCT\n];\nexports.SHARED_DOMAIN_OPS = [\n    AggregateOp.MEAN,\n    AggregateOp.AVERAGE,\n    AggregateOp.STDEV,\n    AggregateOp.STDEVP,\n    AggregateOp.MEDIAN,\n    AggregateOp.Q1,\n    AggregateOp.Q3,\n    AggregateOp.MIN,\n    AggregateOp.MAX,\n];\n// TODO: move supportedTypes, supportedEnums from schema to here\n//# sourceMappingURL=aggregate.js.map",
    "/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\n\"use strict\";\nvar util_1 = require('./util');\n(function (Channel) {\n    Channel[Channel[\"X\"] = 'x'] = \"X\";\n    Channel[Channel[\"Y\"] = 'y'] = \"Y\";\n    Channel[Channel[\"X2\"] = 'x2'] = \"X2\";\n    Channel[Channel[\"Y2\"] = 'y2'] = \"Y2\";\n    Channel[Channel[\"ROW\"] = 'row'] = \"ROW\";\n    Channel[Channel[\"COLUMN\"] = 'column'] = \"COLUMN\";\n    Channel[Channel[\"SHAPE\"] = 'shape'] = \"SHAPE\";\n    Channel[Channel[\"SIZE\"] = 'size'] = \"SIZE\";\n    Channel[Channel[\"COLOR\"] = 'color'] = \"COLOR\";\n    Channel[Channel[\"TEXT\"] = 'text'] = \"TEXT\";\n    Channel[Channel[\"DETAIL\"] = 'detail'] = \"DETAIL\";\n    Channel[Channel[\"LABEL\"] = 'label'] = \"LABEL\";\n    Channel[Channel[\"PATH\"] = 'path'] = \"PATH\";\n    Channel[Channel[\"ORDER\"] = 'order'] = \"ORDER\";\n    Channel[Channel[\"OPACITY\"] = 'opacity'] = \"OPACITY\";\n})(exports.Channel || (exports.Channel = {}));\nvar Channel = exports.Channel;\nexports.X = Channel.X;\nexports.Y = Channel.Y;\nexports.X2 = Channel.X2;\nexports.Y2 = Channel.Y2;\nexports.ROW = Channel.ROW;\nexports.COLUMN = Channel.COLUMN;\nexports.SHAPE = Channel.SHAPE;\nexports.SIZE = Channel.SIZE;\nexports.COLOR = Channel.COLOR;\nexports.TEXT = Channel.TEXT;\nexports.DETAIL = Channel.DETAIL;\nexports.LABEL = Channel.LABEL;\nexports.PATH = Channel.PATH;\nexports.ORDER = Channel.ORDER;\nexports.OPACITY = Channel.OPACITY;\nexports.CHANNELS = [exports.X, exports.Y, exports.X2, exports.Y2, exports.ROW, exports.COLUMN, exports.SIZE, exports.SHAPE, exports.COLOR, exports.PATH, exports.ORDER, exports.OPACITY, exports.TEXT, exports.DETAIL, exports.LABEL];\nexports.UNIT_CHANNELS = util_1.without(exports.CHANNELS, [exports.ROW, exports.COLUMN]);\nexports.UNIT_SCALE_CHANNELS = util_1.without(exports.UNIT_CHANNELS, [exports.PATH, exports.ORDER, exports.DETAIL, exports.TEXT, exports.LABEL, exports.X2, exports.Y2]);\nexports.NONSPATIAL_CHANNELS = util_1.without(exports.UNIT_CHANNELS, [exports.X, exports.Y, exports.X2, exports.Y2]);\nexports.NONSPATIAL_SCALE_CHANNELS = util_1.without(exports.UNIT_SCALE_CHANNELS, [exports.X, exports.Y, exports.X2, exports.Y2]);\n/** Channels that can serve as groupings for stacked charts. */\nexports.STACK_GROUP_CHANNELS = [exports.COLOR, exports.DETAIL, exports.ORDER, exports.OPACITY, exports.SIZE];\n;\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nfunction supportMark(channel, mark) {\n    return !!getSupportedMark(channel)[mark];\n}\nexports.supportMark = supportMark;\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to boolean values.\n */\nfunction getSupportedMark(channel) {\n    switch (channel) {\n        case exports.X:\n        case exports.Y:\n        case exports.COLOR:\n        case exports.DETAIL:\n        case exports.ORDER:\n        case exports.OPACITY:\n        case exports.ROW:\n        case exports.COLUMN:\n            return {\n                point: true, tick: true, rule: true, circle: true, square: true,\n                bar: true, line: true, area: true, text: true\n            };\n        case exports.X2:\n        case exports.Y2:\n            return {\n                rule: true, bar: true, area: true\n            };\n        case exports.SIZE:\n            return {\n                point: true, tick: true, rule: true, circle: true, square: true,\n                bar: true, text: true\n            };\n        case exports.SHAPE:\n            return { point: true };\n        case exports.TEXT:\n            return { text: true };\n        case exports.PATH:\n            return { line: true };\n    }\n    return {};\n}\nexports.getSupportedMark = getSupportedMark;\n;\n/**\n * Return whether a channel supports dimension / measure role\n * @param  channel\n * @return A dictionary mapping role to boolean values.\n */\nfunction getSupportedRole(channel) {\n    switch (channel) {\n        case exports.X:\n        case exports.Y:\n        case exports.COLOR:\n        case exports.OPACITY:\n        case exports.LABEL:\n        case exports.DETAIL:\n            return {\n                measure: true,\n                dimension: true\n            };\n        case exports.ROW:\n        case exports.COLUMN:\n        case exports.SHAPE:\n            return {\n                measure: false,\n                dimension: true\n            };\n        case exports.X2:\n        case exports.Y2:\n        case exports.SIZE:\n        case exports.TEXT:\n            return {\n                measure: true,\n                dimension: false\n            };\n        case exports.PATH:\n            return {\n                measure: false,\n                dimension: true\n            };\n    }\n    throw new Error('Invalid encoding channel' + channel);\n}\nexports.getSupportedRole = getSupportedRole;\nfunction hasScale(channel) {\n    return !util_1.contains([exports.DETAIL, exports.PATH, exports.TEXT, exports.LABEL, exports.ORDER], channel);\n}\nexports.hasScale = hasScale;\n//# sourceMappingURL=channel.js.map",
    "\"use strict\";\nvar channel_1 = require('./channel');\nvar util_1 = require('./util');\nfunction countRetinal(encoding) {\n    var count = 0;\n    if (encoding.color) {\n        count++;\n    }\n    if (encoding.opacity) {\n        count++;\n    }\n    if (encoding.size) {\n        count++;\n    }\n    if (encoding.shape) {\n        count++;\n    }\n    return count;\n}\nexports.countRetinal = countRetinal;\nfunction channels(encoding) {\n    return channel_1.CHANNELS.filter(function (channel) {\n        return has(encoding, channel);\n    });\n}\nexports.channels = channels;\n// TOD: rename this to hasChannelField and only use we really want it.\nfunction has(encoding, channel) {\n    var channelEncoding = encoding && encoding[channel];\n    return channelEncoding && (channelEncoding.field !== undefined ||\n        // TODO: check that we have field in the array\n        (util_1.isArray(channelEncoding) && channelEncoding.length > 0));\n}\nexports.has = has;\nfunction isAggregate(encoding) {\n    return util_1.some(channel_1.CHANNELS, function (channel) {\n        if (has(encoding, channel) && encoding[channel].aggregate) {\n            return true;\n        }\n        return false;\n    });\n}\nexports.isAggregate = isAggregate;\nfunction isRanged(encoding) {\n    return encoding && ((!!encoding.x && !!encoding.x2) || (!!encoding.y && !!encoding.y2));\n}\nexports.isRanged = isRanged;\nfunction fieldDefs(encoding) {\n    var arr = [];\n    channel_1.CHANNELS.forEach(function (channel) {\n        if (has(encoding, channel)) {\n            if (util_1.isArray(encoding[channel])) {\n                encoding[channel].forEach(function (fieldDef) {\n                    arr.push(fieldDef);\n                });\n            }\n            else {\n                arr.push(encoding[channel]);\n            }\n        }\n    });\n    return arr;\n}\nexports.fieldDefs = fieldDefs;\n;\nfunction forEach(encoding, f, thisArg) {\n    channelMappingForEach(channel_1.CHANNELS, encoding, f, thisArg);\n}\nexports.forEach = forEach;\nfunction channelMappingForEach(channels, mapping, f, thisArg) {\n    var i = 0;\n    channels.forEach(function (channel) {\n        if (has(mapping, channel)) {\n            if (util_1.isArray(mapping[channel])) {\n                mapping[channel].forEach(function (fieldDef) {\n                    f.call(thisArg, fieldDef, channel, i++);\n                });\n            }\n            else {\n                f.call(thisArg, mapping[channel], channel, i++);\n            }\n        }\n    });\n}\nexports.channelMappingForEach = channelMappingForEach;\nfunction map(encoding, f, thisArg) {\n    return channelMappingMap(channel_1.CHANNELS, encoding, f, thisArg);\n}\nexports.map = map;\nfunction channelMappingMap(channels, mapping, f, thisArg) {\n    var arr = [];\n    channels.forEach(function (channel) {\n        if (has(mapping, channel)) {\n            if (util_1.isArray(mapping[channel])) {\n                mapping[channel].forEach(function (fieldDef) {\n                    arr.push(f.call(thisArg, fieldDef, channel));\n                });\n            }\n            else {\n                arr.push(f.call(thisArg, mapping[channel], channel));\n            }\n        }\n    });\n    return arr;\n}\nexports.channelMappingMap = channelMappingMap;\nfunction reduce(encoding, f, init, thisArg) {\n    return channelMappingReduce(channel_1.CHANNELS, encoding, f, init, thisArg);\n}\nexports.reduce = reduce;\nfunction channelMappingReduce(channels, mapping, f, init, thisArg) {\n    var r = init;\n    channel_1.CHANNELS.forEach(function (channel) {\n        if (has(mapping, channel)) {\n            if (util_1.isArray(mapping[channel])) {\n                mapping[channel].forEach(function (fieldDef) {\n                    r = f.call(thisArg, r, fieldDef, channel);\n                });\n            }\n            else {\n                r = f.call(thisArg, r, mapping[channel], channel);\n            }\n        }\n    });\n    return r;\n}\nexports.channelMappingReduce = channelMappingReduce;\n//# sourceMappingURL=encoding.js.map",
    "\"use strict\";\n(function (Mark) {\n    Mark[Mark[\"AREA\"] = 'area'] = \"AREA\";\n    Mark[Mark[\"BAR\"] = 'bar'] = \"BAR\";\n    Mark[Mark[\"LINE\"] = 'line'] = \"LINE\";\n    Mark[Mark[\"POINT\"] = 'point'] = \"POINT\";\n    Mark[Mark[\"TEXT\"] = 'text'] = \"TEXT\";\n    Mark[Mark[\"TICK\"] = 'tick'] = \"TICK\";\n    Mark[Mark[\"RULE\"] = 'rule'] = \"RULE\";\n    Mark[Mark[\"CIRCLE\"] = 'circle'] = \"CIRCLE\";\n    Mark[Mark[\"SQUARE\"] = 'square'] = \"SQUARE\";\n    Mark[Mark[\"ERRORBAR\"] = 'errorBar'] = \"ERRORBAR\";\n})(exports.Mark || (exports.Mark = {}));\nvar Mark = exports.Mark;\nexports.AREA = Mark.AREA;\nexports.BAR = Mark.BAR;\nexports.LINE = Mark.LINE;\nexports.POINT = Mark.POINT;\nexports.TEXT = Mark.TEXT;\nexports.TICK = Mark.TICK;\nexports.RULE = Mark.RULE;\nexports.CIRCLE = Mark.CIRCLE;\nexports.SQUARE = Mark.SQUARE;\nexports.ERRORBAR = Mark.ERRORBAR;\nexports.PRIMITIVE_MARKS = [exports.AREA, exports.BAR, exports.LINE, exports.POINT, exports.TEXT, exports.TICK, exports.RULE, exports.CIRCLE, exports.SQUARE];\n//# sourceMappingURL=mark.js.map",
    "\"use strict\";\n(function (ScaleType) {\n    ScaleType[ScaleType[\"LINEAR\"] = 'linear'] = \"LINEAR\";\n    ScaleType[ScaleType[\"LOG\"] = 'log'] = \"LOG\";\n    ScaleType[ScaleType[\"POW\"] = 'pow'] = \"POW\";\n    ScaleType[ScaleType[\"SQRT\"] = 'sqrt'] = \"SQRT\";\n    ScaleType[ScaleType[\"QUANTILE\"] = 'quantile'] = \"QUANTILE\";\n    ScaleType[ScaleType[\"QUANTIZE\"] = 'quantize'] = \"QUANTIZE\";\n    ScaleType[ScaleType[\"ORDINAL\"] = 'ordinal'] = \"ORDINAL\";\n    ScaleType[ScaleType[\"TIME\"] = 'time'] = \"TIME\";\n    ScaleType[ScaleType[\"UTC\"] = 'utc'] = \"UTC\";\n})(exports.ScaleType || (exports.ScaleType = {}));\nvar ScaleType = exports.ScaleType;\n(function (NiceTime) {\n    NiceTime[NiceTime[\"SECOND\"] = 'second'] = \"SECOND\";\n    NiceTime[NiceTime[\"MINUTE\"] = 'minute'] = \"MINUTE\";\n    NiceTime[NiceTime[\"HOUR\"] = 'hour'] = \"HOUR\";\n    NiceTime[NiceTime[\"DAY\"] = 'day'] = \"DAY\";\n    NiceTime[NiceTime[\"WEEK\"] = 'week'] = \"WEEK\";\n    NiceTime[NiceTime[\"MONTH\"] = 'month'] = \"MONTH\";\n    NiceTime[NiceTime[\"YEAR\"] = 'year'] = \"YEAR\";\n})(exports.NiceTime || (exports.NiceTime = {}));\nvar NiceTime = exports.NiceTime;\nexports.defaultScaleConfig = {\n    round: true,\n    textBandWidth: 90,\n    bandSize: 21,\n    padding: 1,\n    useRawDomain: false,\n    opacity: [0.3, 0.8],\n    nominalColorRange: 'category10',\n    sequentialColorRange: ['#AFC6A3', '#09622A'],\n    shapeRange: 'shapes',\n    fontSizeRange: [8, 40],\n    ruleSizeRange: [1, 5],\n    tickSizeRange: [1, 20]\n};\nexports.defaultFacetScaleConfig = {\n    round: true,\n    padding: 16\n};\n//# sourceMappingURL=scale.js.map",
    "\"use strict\";\nvar channel_1 = require('./channel');\nvar encoding_1 = require('./encoding');\nvar mark_1 = require('./mark');\nvar util_1 = require('./util');\n(function (StackOffset) {\n    StackOffset[StackOffset[\"ZERO\"] = 'zero'] = \"ZERO\";\n    StackOffset[StackOffset[\"CENTER\"] = 'center'] = \"CENTER\";\n    StackOffset[StackOffset[\"NORMALIZE\"] = 'normalize'] = \"NORMALIZE\";\n    StackOffset[StackOffset[\"NONE\"] = 'none'] = \"NONE\";\n})(exports.StackOffset || (exports.StackOffset = {}));\nvar StackOffset = exports.StackOffset;\nfunction stack(mark, encoding, config) {\n    var stacked = (config && config.mark) ? config.mark.stacked : undefined;\n    // Should not have stack explicitly disabled\n    if (util_1.contains([StackOffset.NONE, null, false], stacked)) {\n        return null;\n    }\n    // Should have stackable mark\n    if (!util_1.contains([mark_1.BAR, mark_1.AREA], mark)) {\n        return null;\n    }\n    // Should be aggregate plot\n    if (!encoding_1.isAggregate(encoding)) {\n        return null;\n    }\n    // Should have grouping level of detail\n    var stackByChannels = channel_1.STACK_GROUP_CHANNELS.reduce(function (sc, channel) {\n        if (encoding_1.has(encoding, channel) && !encoding[channel].aggregate) {\n            sc.push(channel);\n        }\n        return sc;\n    }, []);\n    if (stackByChannels.length === 0) {\n        return null;\n    }\n    // Has only one aggregate axis\n    var hasXField = encoding_1.has(encoding, channel_1.X);\n    var hasYField = encoding_1.has(encoding, channel_1.Y);\n    var xIsAggregate = hasXField && !!encoding.x.aggregate;\n    var yIsAggregate = hasYField && !!encoding.y.aggregate;\n    if (xIsAggregate !== yIsAggregate) {\n        return {\n            groupbyChannel: xIsAggregate ? (hasYField ? channel_1.Y : null) : (hasXField ? channel_1.X : null),\n            fieldChannel: xIsAggregate ? channel_1.X : channel_1.Y,\n            stackByChannels: stackByChannels,\n            offset: stacked || StackOffset.ZERO\n        };\n    }\n    return null;\n}\nexports.stack = stack;\n//# sourceMappingURL=stack.js.map",
    "\"use strict\";\nvar util_1 = require('./util');\nvar channel_1 = require('./channel');\n(function (TimeUnit) {\n    TimeUnit[TimeUnit[\"YEAR\"] = 'year'] = \"YEAR\";\n    TimeUnit[TimeUnit[\"MONTH\"] = 'month'] = \"MONTH\";\n    TimeUnit[TimeUnit[\"DAY\"] = 'day'] = \"DAY\";\n    TimeUnit[TimeUnit[\"DATE\"] = 'date'] = \"DATE\";\n    TimeUnit[TimeUnit[\"HOURS\"] = 'hours'] = \"HOURS\";\n    TimeUnit[TimeUnit[\"MINUTES\"] = 'minutes'] = \"MINUTES\";\n    TimeUnit[TimeUnit[\"SECONDS\"] = 'seconds'] = \"SECONDS\";\n    TimeUnit[TimeUnit[\"MILLISECONDS\"] = 'milliseconds'] = \"MILLISECONDS\";\n    TimeUnit[TimeUnit[\"YEARMONTH\"] = 'yearmonth'] = \"YEARMONTH\";\n    TimeUnit[TimeUnit[\"YEARMONTHDAY\"] = 'yearmonthday'] = \"YEARMONTHDAY\";\n    TimeUnit[TimeUnit[\"YEARMONTHDATE\"] = 'yearmonthdate'] = \"YEARMONTHDATE\";\n    TimeUnit[TimeUnit[\"YEARDAY\"] = 'yearday'] = \"YEARDAY\";\n    TimeUnit[TimeUnit[\"YEARDATE\"] = 'yeardate'] = \"YEARDATE\";\n    TimeUnit[TimeUnit[\"YEARMONTHDAYHOURS\"] = 'yearmonthdayhours'] = \"YEARMONTHDAYHOURS\";\n    TimeUnit[TimeUnit[\"YEARMONTHDAYHOURSMINUTES\"] = 'yearmonthdayhoursminutes'] = \"YEARMONTHDAYHOURSMINUTES\";\n    TimeUnit[TimeUnit[\"YEARMONTHDAYHOURSMINUTESSECONDS\"] = 'yearmonthdayhoursminutesseconds'] = \"YEARMONTHDAYHOURSMINUTESSECONDS\";\n    TimeUnit[TimeUnit[\"HOURSMINUTES\"] = 'hoursminutes'] = \"HOURSMINUTES\";\n    TimeUnit[TimeUnit[\"HOURSMINUTESSECONDS\"] = 'hoursminutesseconds'] = \"HOURSMINUTESSECONDS\";\n    TimeUnit[TimeUnit[\"MINUTESSECONDS\"] = 'minutesseconds'] = \"MINUTESSECONDS\";\n    TimeUnit[TimeUnit[\"SECONDSMILLISECONDS\"] = 'secondsmilliseconds'] = \"SECONDSMILLISECONDS\";\n    TimeUnit[TimeUnit[\"QUARTER\"] = 'quarter'] = \"QUARTER\";\n    TimeUnit[TimeUnit[\"YEARQUARTER\"] = 'yearquarter'] = \"YEARQUARTER\";\n    TimeUnit[TimeUnit[\"QUARTERMONTH\"] = 'quartermonth'] = \"QUARTERMONTH\";\n    TimeUnit[TimeUnit[\"YEARQUARTERMONTH\"] = 'yearquartermonth'] = \"YEARQUARTERMONTH\";\n})(exports.TimeUnit || (exports.TimeUnit = {}));\nvar TimeUnit = exports.TimeUnit;\nexports.TIMEUNITS = [\n    TimeUnit.YEAR,\n    TimeUnit.MONTH,\n    TimeUnit.DAY,\n    TimeUnit.DATE,\n    TimeUnit.HOURS,\n    TimeUnit.MINUTES,\n    TimeUnit.SECONDS,\n    TimeUnit.MILLISECONDS,\n    TimeUnit.YEARMONTH,\n    TimeUnit.YEARMONTHDAY,\n    TimeUnit.YEARMONTHDATE,\n    TimeUnit.YEARDAY,\n    TimeUnit.YEARDATE,\n    TimeUnit.YEARMONTHDAYHOURS,\n    TimeUnit.YEARMONTHDAYHOURSMINUTES,\n    TimeUnit.YEARMONTHDAYHOURSMINUTESSECONDS,\n    TimeUnit.HOURSMINUTES,\n    TimeUnit.HOURSMINUTESSECONDS,\n    TimeUnit.MINUTESSECONDS,\n    TimeUnit.SECONDSMILLISECONDS,\n    TimeUnit.QUARTER,\n    TimeUnit.YEARQUARTER,\n    TimeUnit.QUARTERMONTH,\n    TimeUnit.YEARQUARTERMONTH,\n];\n/** Returns true if container contains the containee, false otherwise. */\nfunction containsTimeUnit(fullTimeUnit, timeUnit) {\n    var fullTimeUnitStr = fullTimeUnit.toString();\n    var timeUnitStr = timeUnit.toString();\n    return fullTimeUnitStr.indexOf(timeUnitStr) > -1;\n}\nexports.containsTimeUnit = containsTimeUnit;\n/**\n * Returns Vega expresssion for a given timeUnit and fieldRef\n */\nfunction expression(timeUnit, fieldRef, onlyRef) {\n    if (onlyRef === void 0) { onlyRef = false; }\n    var out = 'datetime(';\n    function func(fun, addComma) {\n        if (addComma === void 0) { addComma = true; }\n        if (onlyRef) {\n            return fieldRef + (addComma ? ', ' : '');\n        }\n        else {\n            var res = '';\n            if (fun === 'quarter') {\n                // Divide by 3 to get the corresponding quarter number, multiply by 3\n                // to scale to the first month of the corresponding quarter(0,3,6,9).\n                res = 'floor(month(' + fieldRef + ')' + '/3)*3';\n            }\n            else {\n                res = fun + '(' + fieldRef + ')';\n            }\n            return res + (addComma ? ', ' : '');\n        }\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.YEAR)) {\n        out += func('year');\n    }\n    else {\n        out += '2006, '; // January 1 2006 is a Sunday\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n        out += func('month');\n    }\n    else if (containsTimeUnit(timeUnit, TimeUnit.QUARTER)) {\n        out += func('quarter');\n    }\n    else {\n        // month starts at 0 in javascript\n        out += '0, ';\n    }\n    // need to add 1 because days start at 1\n    if (containsTimeUnit(timeUnit, TimeUnit.DAY)) {\n        out += func('day', false) + '+1, ';\n    }\n    else if (containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n        out += func('date');\n    }\n    else {\n        out += '1, ';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n        out += func('hours');\n    }\n    else {\n        out += '0, ';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n        out += func('minutes');\n    }\n    else {\n        out += '0, ';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n        out += func('seconds');\n    }\n    else {\n        out += '0, ';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MILLISECONDS)) {\n        out += func('milliseconds', false);\n    }\n    else {\n        out += '0';\n    }\n    return out + ')';\n}\nexports.expression = expression;\n/** Generate the complete raw domain. */\nfunction rawDomain(timeUnit, channel) {\n    if (util_1.contains([channel_1.ROW, channel_1.COLUMN, channel_1.SHAPE, channel_1.COLOR], channel)) {\n        return null;\n    }\n    switch (timeUnit) {\n        case TimeUnit.SECONDS:\n            return util_1.range(0, 60);\n        case TimeUnit.MINUTES:\n            return util_1.range(0, 60);\n        case TimeUnit.HOURS:\n            return util_1.range(0, 24);\n        case TimeUnit.DAY:\n            return util_1.range(0, 7);\n        case TimeUnit.DATE:\n            return util_1.range(1, 32);\n        case TimeUnit.MONTH:\n            return util_1.range(0, 12);\n        case TimeUnit.QUARTER:\n            return [0, 3, 6, 9];\n    }\n    return null;\n}\nexports.rawDomain = rawDomain;\n/** returns the smallest nice unit for scale.nice */\nfunction smallestUnit(timeUnit) {\n    if (!timeUnit) {\n        return undefined;\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n        return 'second';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n        return 'minute';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n        return 'hour';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.DAY) ||\n        containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n        return 'day';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n        return 'month';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.YEAR)) {\n        return 'year';\n    }\n    return undefined;\n}\nexports.smallestUnit = smallestUnit;\n/** returns the template name used for axis labels for a time unit */\nfunction template(timeUnit, field, shortTimeLabels) {\n    if (!timeUnit) {\n        return undefined;\n    }\n    var dateComponents = [];\n    if (containsTimeUnit(timeUnit, TimeUnit.YEAR)) {\n        dateComponents.push(shortTimeLabels ? '%y' : '%Y');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.QUARTER)) {\n        // special template for quarter\n        dateComponents.push('\\'}}Q{{' + field + ' | quarter}}{{' + field + ' | time:\\'');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n        dateComponents.push(shortTimeLabels ? '%b' : '%B');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.DAY)) {\n        dateComponents.push(shortTimeLabels ? '%a' : '%A');\n    }\n    else if (containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n        dateComponents.push('%d');\n    }\n    var timeComponents = [];\n    if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n        timeComponents.push('%H');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n        timeComponents.push('%M');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n        timeComponents.push('%S');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MILLISECONDS)) {\n        timeComponents.push('%L');\n    }\n    var out = [];\n    if (dateComponents.length > 0) {\n        out.push(dateComponents.join('-'));\n    }\n    if (timeComponents.length > 0) {\n        out.push(timeComponents.join(':'));\n    }\n    if (out.length > 0) {\n        // clean up empty formatting expressions that may have been generated by the quarter time unit\n        var template_1 = '{{' + field + ' | time:\\'' + out.join(' ') + '\\'}}';\n        // FIXME: Remove this RegExp Hack!!!\n        return template_1.replace(new RegExp('{{' + field + ' \\\\| time:\\'\\'}}', 'g'), '');\n    }\n    else {\n        return undefined;\n    }\n}\nexports.template = template;\n//# sourceMappingURL=timeunit.js.map",
    "/** Constants and utilities for data type */\n\"use strict\";\n(function (Type) {\n    Type[Type[\"QUANTITATIVE\"] = 'quantitative'] = \"QUANTITATIVE\";\n    Type[Type[\"ORDINAL\"] = 'ordinal'] = \"ORDINAL\";\n    Type[Type[\"TEMPORAL\"] = 'temporal'] = \"TEMPORAL\";\n    Type[Type[\"NOMINAL\"] = 'nominal'] = \"NOMINAL\";\n})(exports.Type || (exports.Type = {}));\nvar Type = exports.Type;\nexports.QUANTITATIVE = Type.QUANTITATIVE;\nexports.ORDINAL = Type.ORDINAL;\nexports.TEMPORAL = Type.TEMPORAL;\nexports.NOMINAL = Type.NOMINAL;\n/**\n * Mapping from full type names to short type names.\n * @type {Object}\n */\nexports.SHORT_TYPE = {\n    quantitative: 'Q',\n    temporal: 'T',\n    nominal: 'N',\n    ordinal: 'O'\n};\n/**\n * Mapping from short type names to full type names.\n * @type {Object}\n */\nexports.TYPE_FROM_SHORT_TYPE = {\n    Q: exports.QUANTITATIVE,\n    T: exports.TEMPORAL,\n    O: exports.ORDINAL,\n    N: exports.NOMINAL\n};\n/**\n * Get full, lowercase type name for a given type.\n * @param  type\n * @return Full type name.\n */\nfunction getFullName(type) {\n    var typeString = type; // force type as string so we can translate short types\n    return exports.TYPE_FROM_SHORT_TYPE[typeString.toUpperCase()] ||\n        typeString.toLowerCase();\n}\nexports.getFullName = getFullName;\n//# sourceMappingURL=type.js.map",
    "/// <reference path=\"../typings/datalib.d.ts\"/>\n/// <reference path=\"../typings/json-stable-stringify.d.ts\"/>\n\"use strict\";\nvar stringify = require('json-stable-stringify');\nvar util_1 = require('datalib/src/util');\nexports.keys = util_1.keys;\nexports.extend = util_1.extend;\nexports.duplicate = util_1.duplicate;\nexports.isArray = util_1.isArray;\nexports.vals = util_1.vals;\nexports.truncate = util_1.truncate;\nexports.toMap = util_1.toMap;\nexports.isObject = util_1.isObject;\nexports.isString = util_1.isString;\nexports.isNumber = util_1.isNumber;\nexports.isBoolean = util_1.isBoolean;\nvar util_2 = require('datalib/src/util');\nvar generate_1 = require('datalib/src/generate');\nexports.range = generate_1.range;\nvar encoding_1 = require('./encoding');\nexports.has = encoding_1.has;\nvar channel_1 = require('./channel');\nexports.Channel = channel_1.Channel;\nvar util_3 = require('datalib/src/util');\n/**\n * Creates an object composed of the picked object properties.\n *\n * Example:  (from lodash)\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n * pick(object, ['a', 'c']);\n * //  { 'a': 1, 'c': 3 }\n *\n */\nfunction pick(obj, props) {\n    var copy = {};\n    props.forEach(function (prop) {\n        if (obj.hasOwnProperty(prop)) {\n            copy[prop] = obj[prop];\n        }\n    });\n    return copy;\n}\nexports.pick = pick;\n/**\n * The opposite of _.pick; this method creates an object composed of the own\n * and inherited enumerable string keyed properties of object that are not omitted.\n */\nfunction omit(obj, props) {\n    var copy = util_2.duplicate(obj);\n    props.forEach(function (prop) {\n        delete copy[prop];\n    });\n    return copy;\n}\nexports.omit = omit;\nfunction hash(a) {\n    if (util_3.isString(a) || util_3.isNumber(a) || util_3.isBoolean(a)) {\n        return String(a);\n    }\n    return stringify(a);\n}\nexports.hash = hash;\nfunction contains(array, item) {\n    return array.indexOf(item) > -1;\n}\nexports.contains = contains;\n/** Returns the array without the elements in item */\nfunction without(array, excludedItems) {\n    return array.filter(function (item) {\n        return !contains(excludedItems, item);\n    });\n}\nexports.without = without;\nfunction union(array, other) {\n    return array.concat(without(other, array));\n}\nexports.union = union;\nfunction forEach(obj, f, thisArg) {\n    if (obj.forEach) {\n        obj.forEach.call(thisArg, f);\n    }\n    else {\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                f.call(thisArg, obj[k], k, obj);\n            }\n        }\n    }\n}\nexports.forEach = forEach;\nfunction reduce(obj, f, init, thisArg) {\n    if (obj.reduce) {\n        return obj.reduce.call(thisArg, f, init);\n    }\n    else {\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                init = f.call(thisArg, init, obj[k], k, obj);\n            }\n        }\n        return init;\n    }\n}\nexports.reduce = reduce;\nfunction map(obj, f, thisArg) {\n    if (obj.map) {\n        return obj.map.call(thisArg, f);\n    }\n    else {\n        var output = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                output.push(f.call(thisArg, obj[k], k, obj));\n            }\n        }\n        return output;\n    }\n}\nexports.map = map;\nfunction some(arr, f) {\n    var i = 0;\n    for (var k = 0; k < arr.length; k++) {\n        if (f(arr[k], k, i++)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.some = some;\nfunction every(arr, f) {\n    var i = 0;\n    for (var k = 0; k < arr.length; k++) {\n        if (!f(arr[k], k, i++)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.every = every;\nfunction flatten(arrays) {\n    return [].concat.apply([], arrays);\n}\nexports.flatten = flatten;\nfunction mergeDeep(dest) {\n    var src = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        src[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < src.length; i++) {\n        dest = deepMerge_(dest, src[i]);\n    }\n    return dest;\n}\nexports.mergeDeep = mergeDeep;\n;\n// recursively merges src into dest\nfunction deepMerge_(dest, src) {\n    if (typeof src !== 'object' || src === null) {\n        return dest;\n    }\n    for (var p in src) {\n        if (!src.hasOwnProperty(p)) {\n            continue;\n        }\n        if (src[p] === undefined) {\n            continue;\n        }\n        if (typeof src[p] !== 'object' || src[p] === null) {\n            dest[p] = src[p];\n        }\n        else if (typeof dest[p] !== 'object' || dest[p] === null) {\n            dest[p] = mergeDeep(src[p].constructor === Array ? [] : {}, src[p]);\n        }\n        else {\n            mergeDeep(dest[p], src[p]);\n        }\n    }\n    return dest;\n}\n// FIXME remove this\nvar dlBin = require('datalib/src/bins/bins');\nfunction getbins(stats, maxbins) {\n    return dlBin({\n        min: stats.min,\n        max: stats.max,\n        maxbins: maxbins\n    });\n}\nexports.getbins = getbins;\nfunction unique(values, f) {\n    var results = [];\n    var u = {}, v, i, n;\n    for (i = 0, n = values.length; i < n; ++i) {\n        v = f ? f(values[i]) : values[i];\n        if (v in u) {\n            continue;\n        }\n        u[v] = 1;\n        results.push(values[i]);\n    }\n    return results;\n}\nexports.unique = unique;\n;\nfunction warning(message) {\n    console.warn('[VL Warning]', message);\n}\nexports.warning = warning;\nfunction error(message) {\n    console.error('[VL Error]', message);\n}\nexports.error = error;\n/**\n * Returns true if the two dicitonaries disagree. Applies only to defioned values.\n */\nfunction differ(dict, other) {\n    for (var key in dict) {\n        if (dict.hasOwnProperty(key)) {\n            if (other[key] && dict[key] && other[key] !== dict[key]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexports.differ = differ;\n//# sourceMappingURL=util.js.map"
  ]
}